#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use std::borrow;
use std::boxed;
use std::convert::TryFrom;
use std::ffi;
use std::fmt;
use std::fmt::Display;
use std::fs;
use std::hash::Hash;
use std::hash::Hasher;
use std::io::Write;
use std::mem;
use std::ops::Deref;
use std::os::raw;
use std::os::unix;
use std::os::unix::io::{FromRawFd, IntoRawFd};
use std::ptr;
use std::sync;

use differential_dataflow::collection;
use timely::communication;
use timely::dataflow::scopes;
use timely::worker;

use serde::Deserialize;
use serde::Serialize;

use abomonation::Abomonation;
use differential_datalog::arcval;
use differential_datalog::decl_enum_into_record;
use differential_datalog::decl_record_mutator_enum;
use differential_datalog::decl_record_mutator_struct;
use differential_datalog::decl_record_mutator_val_enum;
use differential_datalog::decl_struct_into_record;
use differential_datalog::decl_val_enum_into_record;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::RelIdentifier;
use differential_datalog::record::UpdCmd;
use differential_datalog::record::{FromRecord, IntoRecord, Mutator};
use differential_datalog::uint::*;
use differential_datalog::DDlogConvert;

use fnv::{FnvHashMap, FnvHashSet};
use lazy_static::lazy_static;
use libc::size_t;
use num_traits::identities::One;

use crate::api::updcmd2upd;

pub mod api;
pub mod ovsdb;
pub mod update_handler;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

/* FlatBuffers code generated by `flatc` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf_generated;

pub fn string_append_str(mut s1: String, s2: &str) -> String {
    s1.push_str(s2);
    s1
}

#[allow(clippy::ptr_arg)]
pub fn string_append(mut s1: String, s2: &String) -> String {
    s1.push_str(s2.as_str());
    s1
}

/// A default implementation of `DDlogConvert` that just forwards calls
/// to generated functions of equal name.
#[derive(Debug)]
pub struct DDlogConverter {}

impl DDlogConvert for DDlogConverter {
    type Value = Value;

    fn relid2name(relId: RelId) -> Option<&'static str> {
        relid2name(relId)
    }

    fn indexid2name(idxId: IdxId) -> Option<&'static str> {
        indexid2name(idxId)
    }

    fn updcmd2upd(upd_cmd: &UpdCmd) -> Result<Update<Self::Value>, String> {
        updcmd2upd(upd_cmd)
    }
}

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> Result<Self, Self::Error> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}


pub use __std::*;
mod __std {
    use super::*;
    /// Rust implementation of DDlog standard library functions and types.
    extern crate num;
    
    use differential_datalog::arcval;
    use differential_datalog::record::*;
    
    use std::cmp;
    use std::collections::btree_map;
    use std::collections::btree_set;
    use std::collections::{BTreeMap, BTreeSet};
    use std::fmt;
    use std::fmt::Display;
    use std::hash::Hash;
    use std::hash::Hasher;
    use std::iter::FromIterator;
    use std::marker;
    use std::ops;
    use std::slice;
    use std::vec;
    use std::vec::Vec;
    use twox_hash::XxHash;
    
    /* FlatBuffers bindings generated by `ddlog` */
    #[cfg(feature = "flatbuf")]
    use flatbuf::{FBIter, FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};
    
    /* FlatBuffers runtime */
    #[cfg(feature = "flatbuf")]
    use flatbuffers as fbrt;
    
    const XX_SEED1: u64 = 0x23b691a751d0e108;
    const XX_SEED2: u64 = 0x20b09801dce5ff84;
    
    // Ref
    pub type std_Ref<A> = arcval::ArcVal<A>;
    
    pub fn std_ref_new<A: Clone>(x: &A) -> std_Ref<A> {
        arcval::ArcVal::from(x.clone())
    }
    
    pub fn std_deref<A: Clone>(x: &std_Ref<A>) -> &A {
        x.deref()
    }
    
    #[cfg(feature = "flatbuf")]
    impl<T, FB> FromFlatBuffer<FB> for std_Ref<T>
    where
        T: FromFlatBuffer<FB>,
    {
        fn from_flatbuf(fb: FB) -> Response<Self> {
            Ok(std_Ref::from(T::from_flatbuf(fb)?))
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Ref<T>
    where
        T: ToFlatBuffer<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferTable<'b> for std_Ref<T>
    where
        T: ToFlatBufferTable<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_table(
            &self,
            fbb: &mut fbrt::FlatBufferBuilder<'b>,
        ) -> fbrt::WIPOffset<Self::Target> {
            self.deref().to_flatbuf_table(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferVectorElement<'b> for std_Ref<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf_vector_element(fbb)
        }
    }
    
    // min/max
    pub fn std_max<A: Ord + Clone>(x: &A, y: &A) -> A {
        if *x >= *y {
            x.clone()
        } else {
            y.clone()
        }
    }
    
    pub fn std_min<A: Ord + Clone>(x: &A, y: &A) -> A {
        if *x <= *y {
            x.clone()
        } else {
            y.clone()
        }
    }
    
    // Arithmetic functions
    pub fn std_pow32<T: num::One + ops::Mul + Clone>(base: &T, exp: &u32) -> T {
        num::pow::pow(base.clone(), *exp as usize)
    }
    
    // Option
    pub fn option2std<T: Clone>(x: Option<T>) -> std_Option<T> {
        match x {
            None => std_Option::std_None,
            Some(v) => std_Option::std_Some { x: v },
        }
    }
    
    // Range
    pub fn std_range<A: Clone + Ord + ops::Add<Output = A> + PartialOrd>(
        from: &A,
        to: &A,
        step: &A,
    ) -> std_Vec<A> {
        let mut vec = std_Vec::new();
        let mut x = from.clone();
        while x <= *to {
            vec.push(x.clone());
            x = x + step.clone();
        }
        vec
    }
    
    // Vector
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Vec<T> {
        pub x: Vec<T>,
    }
    
    /* This is needed so we can support for-loops over `Vec`'s
     */
    pub struct VecIter<'a, X> {
        iter: slice::Iter<'a, X>,
    }
    
    impl<'a, X> VecIter<'a, X> {
        pub fn new(vec: &'a std_Vec<X>) -> VecIter<'a, X> {
            VecIter { iter: vec.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for VecIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T> std_Vec<T> {
        pub fn iter(&'a self) -> VecIter<'a, T> {
            VecIter::new(self)
        }
    }
    
    impl<T> std_Vec<T> {
        pub fn new() -> Self {
            std_Vec { x: Vec::new() }
        }
        pub fn with_capacity(capacity: usize) -> Self {
            std_Vec {
                x: Vec::with_capacity(capacity),
            }
        }
        pub fn push(&mut self, v: T) {
            self.x.push(v);
        }
    }
    
    impl<T: Clone> std_Vec<T> {
        pub fn extend_from_slice(&mut self, other: &[T]) {
            self.x.extend_from_slice(other);
        }
    }
    
    impl<T: FromRecord> FromRecord for std_Vec<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            Vec::from_record(val).map(|x| std_Vec { x })
        }
    }
    
    impl<T: IntoRecord> IntoRecord for std_Vec<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord> Mutator<std_Vec<T>> for Record {
        fn mutate(&self, vec: &mut std_Vec<T>) -> Result<(), String> {
            self.mutate(&mut vec.x)
        }
    }
    
    impl<T: Display> Display for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug> fmt::Debug for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T> IntoIterator for std_Vec<T> {
        type Item = T;
        type IntoIter = vec::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Vec<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            for x in FBIter::from_vector(fb) {
                vec.push(T::from_flatbuf(x)?);
            }
            Ok(vec)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Vec<T>
    where
        T: Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            vec.extend_from_slice(fb);
            Ok(vec)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Vec<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_vec_len<X: Ord + Clone>(v: &std_Vec<X>) -> u64 {
        v.x.len() as u64
    }
    
    pub fn std_vec_empty<X: Ord + Clone>() -> std_Vec<X> {
        std_Vec::new()
    }
    
    pub fn std_vec_singleton<X: Ord + Clone>(x: &X) -> std_Vec<X> {
        std_Vec { x: vec![x.clone()] }
    }
    
    pub fn std_vec_push<X: Ord + Clone>(v: &mut std_Vec<X>, x: &X) {
        v.push((*x).clone());
    }
    
    pub fn std_vec_push_imm<X: Ord + Clone>(v: &std_Vec<X>, x: &X) -> std_Vec<X> {
        let mut v2 = v.clone();
        v2.push((*x).clone());
        v2
    }
    
    pub fn std_vec_contains<X: Ord>(v: &std_Vec<X>, x: &X) -> bool {
        v.x.contains(x)
    }
    
    pub fn std_vec_is_empty<X: Ord>(v: &std_Vec<X>) -> bool {
        v.x.is_empty()
    }
    
    pub fn std_vec_nth<X: Ord + Clone>(v: &std_Vec<X>, n: &u64) -> std_Option<X> {
        option2std(v.x.get(*n as usize).cloned())
    }
    
    pub fn std_vec2set<X: Ord + Clone>(s: &std_Vec<X>) -> std_Set<X> {
        std_Set {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    // Set
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Set<T: Ord> {
        pub x: BTreeSet<T>,
    }
    
    /* This is needed so we can support for-loops over `Set`'s
     */
    pub struct SetIter<'a, X> {
        iter: btree_set::Iter<'a, X>,
    }
    
    impl<'a, X: Ord> SetIter<'a, X> {
        pub fn new(set: &'a std_Set<X>) -> SetIter<'a, X> {
            SetIter { iter: set.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for SetIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T: Ord> std_Set<T> {
        pub fn iter(&'a self) -> SetIter<'a, T> {
            SetIter::new(self)
        }
    }
    
    impl<T: Ord> std_Set<T> {
        pub fn new() -> Self {
            std_Set { x: BTreeSet::new() }
        }
        pub fn insert(&mut self, v: T) {
            self.x.insert(v);
        }
    }
    
    impl<T: FromRecord + Ord> FromRecord for std_Set<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeSet::from_record(val).map(|x| std_Set { x })
        }
    }
    
    impl<T: IntoRecord + Ord> IntoRecord for std_Set<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord + Ord> Mutator<std_Set<T>> for Record {
        fn mutate(&self, set: &mut std_Set<T>) -> Result<(), String> {
            self.mutate(&mut set.x)
        }
    }
    
    impl<T: Ord> IntoIterator for std_Set<T> {
        type Item = T;
        type IntoIter = btree_set::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<T: Ord> FromIterator<T> for std_Set<T> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = T>,
        {
            std_Set {
                x: BTreeSet::from_iter(iter),
            }
        }
    }
    
    impl<T: Display + Ord> Display for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug + Ord> fmt::Debug for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Set<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut set = std_Set::new();
            for x in FBIter::from_vector(fb) {
                set.insert(T::from_flatbuf(x)?);
            }
            Ok(set)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Set<T>
    where
        T: Ord + Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut set = std_Set::new();
            for x in fb.iter() {
                set.insert(x.clone());
            }
            Ok(set)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Set<T>
    where
        T: Ord + ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_set_size<X: Ord + Clone>(s: &std_Set<X>) -> u64 {
        s.x.len() as u64
    }
    
    pub fn std_set_empty<X: Ord + Clone>() -> std_Set<X> {
        std_Set::new()
    }
    
    pub fn std_set_singleton<X: Ord + Clone>(v: &X) -> std_Set<X> {
        let mut s = std_Set::new();
        s.insert(v.clone());
        s
    }
    
    pub fn std_set_insert<X: Ord + Clone>(s: &mut std_Set<X>, v: &X) {
        s.x.insert((*v).clone());
    }
    
    pub fn std_set_insert_imm<X: Ord + Clone>(s: &std_Set<X>, v: &X) -> std_Set<X> {
        let mut s2 = s.clone();
        s2.insert((*v).clone());
        s2
    }
    
    pub fn std_set_contains<X: Ord>(s: &std_Set<X>, v: &X) -> bool {
        s.x.contains(v)
    }
    
    pub fn std_set_is_empty<X: Ord>(s: &std_Set<X>) -> bool {
        s.x.is_empty()
    }
    
    pub fn std_set_nth<X: Ord + Clone>(s: &std_Set<X>, n: &u64) -> std_Option<X> {
        option2std(s.x.iter().nth(*n as usize).cloned())
    }
    
    pub fn std_set2vec<X: Ord + Clone>(s: &std_Set<X>) -> std_Vec<X> {
        std_Vec {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    pub fn std_set_union<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        let mut s = s1.clone();
        s.x.append(&mut s2.x.clone());
        s
    }
    
    pub fn std_set_unions<X: Ord + Clone>(sets: &std_Vec<std_Set<X>>) -> std_Set<X> {
        let mut s = BTreeSet::new();
        for si in sets.x.iter() {
            s.append(&mut si.x.clone());
        }
        std_Set { x: s }
    }
    
    // Map
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Map<K: Ord, V> {
        pub x: BTreeMap<K, V>,
    }
    
    /* This is needed so we can support for-loops over `Map`'s
     */
    pub struct MapIter<'a, K, V> {
        iter: btree_map::Iter<'a, K, V>,
    }
    
    impl<'a, K: Ord, V> MapIter<'a, K, V> {
        pub fn new(map: &'a std_Map<K, V>) -> MapIter<'a, K, V> {
            MapIter { iter: map.x.iter() }
        }
    }
    
    impl<'a, K: Clone, V: Clone> Iterator for MapIter<'a, K, V> {
        type Item = (K, V);
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next().map(|(k, v)| (k.clone(), v.clone()))
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, K: Ord, V> std_Map<K, V> {
        pub fn iter(&'a self) -> MapIter<'a, K, V> {
            MapIter::new(self)
        }
    }
    
    impl<K: Ord, V> std_Map<K, V> {
        pub fn new() -> Self {
            std_Map { x: BTreeMap::new() }
        }
        pub fn insert(&mut self, k: K, v: V) {
            self.x.insert(k, v);
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord> FromRecord for std_Map<K, V> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeMap::from_record(val).map(|x| std_Map { x })
        }
    }
    
    impl<K: IntoRecord + Ord, V: IntoRecord> IntoRecord for std_Map<K, V> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord + PartialEq> Mutator<std_Map<K, V>> for Record {
        fn mutate(&self, map: &mut std_Map<K, V>) -> Result<(), String> {
            self.mutate(&mut map.x)
        }
    }
    
    impl<K: Ord, V> IntoIterator for std_Map<K, V> {
        type Item = (K, V);
        type IntoIter = btree_map::IntoIter<K, V>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<K: Ord, V> FromIterator<(K, V)> for std_Map<K, V> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = (K, V)>,
        {
            std_Map {
                x: BTreeMap::from_iter(iter),
            }
        }
    }
    
    impl<K: Display + Ord, V: Display> Display for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({},{})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<K: fmt::Debug + Ord, V: fmt::Debug> fmt::Debug for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({:?},{:?})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, K, V, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Map<K, V>
    where
        F: fbrt::Follow<'a> + 'a,
        K: Ord,
        (K, V): FromFlatBuffer<F::Inner>,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut m = std_Map::new();
            for x in FBIter::from_vector(fb) {
                let (k, v) = <(K, V)>::from_flatbuf(x)?;
                m.insert(k, v);
            }
            Ok(m)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, K, V, T> ToFlatBuffer<'b> for std_Map<K, V>
    where
        K: Ord + Clone,
        V: Clone,
        (K, V): ToFlatBufferVectorElement<'b, Target = T>,
        T: 'b + fbrt::Push + Copy,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<<(K, V) as ToFlatBufferVectorElement<'b>>::Target> = self
                .iter()
                .map(|(k, v)| (k, v).to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_map_empty<K: Ord + Clone, V: Clone>() -> std_Map<K, V> {
        std_Map::new()
    }
    
    pub fn std_map_singleton<K: Ord + Clone, V: Clone>(k: &K, v: &V) -> std_Map<K, V> {
        let mut m = std_Map::new();
        m.insert(k.clone(), v.clone());
        m
    }
    
    pub fn std_map_insert<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K, v: &V) {
        m.x.insert((*k).clone(), (*v).clone());
    }
    
    pub fn std_map_remove<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K) {
        m.x.remove(k);
    }
    
    pub fn std_map_insert_imm<K: Ord + Clone, V: Clone>(
        m: &std_Map<K, V>,
        k: &K,
        v: &V,
    ) -> std_Map<K, V> {
        let mut m2 = m.clone();
        m2.insert((*k).clone(), (*v).clone());
        m2
    }
    
    pub fn std_map_get<K: Ord, V: Clone>(m: &std_Map<K, V>, k: &K) -> std_Option<V> {
        option2std(m.x.get(k).cloned())
    }
    
    pub fn std_map_contains_key<K: Ord, V: Clone>(s: &std_Map<K, V>, k: &K) -> bool {
        s.x.contains_key(k)
    }
    
    pub fn std_map_is_empty<K: Ord, V: Clone>(m: &std_Map<K, V>) -> bool {
        m.x.is_empty()
    }
    
    pub fn std_map_union<K: Ord + Clone, V: Clone>(
        m1: &std_Map<K, V>,
        m2: &std_Map<K, V>,
    ) -> std_Map<K, V> {
        let mut m = m1.clone();
        m.x.append(&mut m2.x.clone());
        m
    }
    
    // strings
    
    pub fn std___builtin_2string<T: Display>(x: &T) -> String {
        format!("{}", *x).to_string()
    }
    
    pub fn std_hex<T: fmt::LowerHex>(x: &T) -> String {
        format!("{:x}", *x).to_string()
    }
    
    pub fn std_parse_dec_u64(s: &String) -> std_Option<u64> {
        option2std(s.parse::<u64>().ok())
    }
    
    pub fn std_parse_dec_i64(s: &String) -> std_Option<i64> {
        option2std(s.parse::<i64>().ok())
    }
    
    pub fn std_string_join(strings: &std_Vec<String>, sep: &String) -> String {
        strings.x.join(sep.as_str())
    }
    
    pub fn std_string_split(s: &String, sep: &String) -> std_Vec<String> {
        std_Vec {
            x: s.split(sep).map(|x| x.to_owned()).collect(),
        }
    }
    
    pub fn std_string_contains(s1: &String, s2: &String) -> bool {
        s1.contains(s2.as_str())
    }
    
    pub fn std_string_substr(s: &String, start: &u64, end: &u64) -> String {
        let len = s.len();
        let from = cmp::min(*start as usize, len);
        let to = cmp::max(from, cmp::min(*end as usize, len));
        s[from..to].to_string()
    }
    
    pub fn std_string_len(s: &String) -> u64 {
        s.len() as u64
    }
    
    pub fn std_str_to_lower(s: &String) -> String {
        s.to_lowercase()
    }
    
    // Hashing
    
    pub fn std_hash64<T: Hash>(x: &T) -> u64 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        hasher.finish()
    }
    
    pub fn std_hash128<T: Hash>(x: &T) -> u128 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        let w1 = hasher.finish();
        let mut hasher = XxHash::with_seed(XX_SEED2);
        x.hash(&mut hasher);
        let w2 = hasher.finish();
        ((w1 as u128) << 64) | (w2 as u128)
    }
    
    pub type ProjectFunc<X> = fn(&Value) -> X;
    
    /*
     * Group type (used in aggregation operators)
     */
    pub struct std_Group<'a, X> {
        /* TODO: remove "pub" */
        pub group: &'a [(&'a Value, Weight)],
        pub project: &'a ProjectFunc<X>,
    }
    
    /* This is needed so we can support for-loops over `Group`'s
     */
    pub struct GroupIter<'a, X> {
        iter: slice::Iter<'a, (&'a Value, Weight)>,
        project: &'a ProjectFunc<X>,
    }
    
    impl<'a, X> GroupIter<'a, X> {
        pub fn new(grp: &std_Group<'a, X>) -> GroupIter<'a, X> {
            GroupIter {
                iter: grp.group.iter(),
                project: grp.project,
            }
        }
    }
    
    impl<'a, X> Iterator for GroupIter<'a, X> {
        type Item = X;
    
        fn next(&mut self) -> Option<Self::Item> {
            match self.iter.next() {
                None => None,
                Some((x, _)) => Some((self.project)(x)),
            }
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        pub fn new(
            group: &'a [(&'a Value, Weight)],
            project: &'static ProjectFunc<X>,
        ) -> std_Group<'a, X> {
            std_Group {
                group: group,
                project: project,
            }
        }
    
        fn size(&self) -> u64 {
            self.group.len() as u64
        }
    
        fn first(&'a self) -> X {
            (self.project)(self.group[0].0)
        }
    
        fn nth_unchecked(&'a self, n: u64) -> X {
            (self.project)(self.group[n as usize].0)
        }
    
        pub fn iter(&'a self) -> GroupIter<'a, X> {
            GroupIter::new(self)
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        fn nth(&'a self, n: u64) -> std_Option<X> {
            if self.size() > n {
                std_Option::std_Some {
                    x: (self.project)(self.group[n as usize].0),
                }
            } else {
                std_Option::std_None
            }
        }
    }
    
    /*
     * Standard aggregation function
     */
    pub fn std_group_count<A>(g: &std_Group<A>) -> u64 {
        g.size()
    }
    
    pub fn std_group_first<A>(g: &std_Group<A>) -> A {
        g.first()
    }
    
    pub fn std_group_nth<A>(g: &std_Group<A>, n: &u64) -> std_Option<A> {
        g.nth(*n)
    }
    
    pub fn std_group2set<A: Ord + Clone>(g: &std_Group<A>) -> std_Set<A> {
        let mut res = std_Set::new();
        for v in g.iter() {
            std_set_insert(&mut res, &v);
        }
        res
    }
    
    pub fn std_group_set_unions<A: Ord + Clone>(g: &std_Group<std_Set<A>>) -> std_Set<A> {
        let mut res = std_Set::new();
        for gr in g.iter() {
            for v in gr.iter() {
                std_set_insert(&mut res, v);
            }
        }
        res
    }
    
    pub fn std_group_setref_unions<A: Ord + Clone>(
        g: &std_Group<std_Ref<std_Set<A>>>,
    ) -> std_Ref<std_Set<A>> {
        if g.size() == 1 {
            g.first()
        } else {
            let mut res: std_Ref<std_Set<A>> = std_ref_new(&std_Set::new());
            {
                let mut rres = std_Ref::get_mut(&mut res).unwrap();
                for gr in g.iter() {
                    for v in gr.iter() {
                        std_set_insert(&mut rres, &v);
                    }
                }
            }
            res
        }
    }
    
    pub fn std_group2vec<A: Ord + Clone>(g: &std_Group<A>) -> std_Vec<A> {
        let mut res = std_Vec::with_capacity(g.size() as usize);
        for v in g.iter() {
            std_vec_push(&mut res, &v);
        }
        res
    }
    
    pub fn std_group2map<K: Ord + Clone, V: Clone>(g: &std_Group<(K, V)>) -> std_Map<K, V> {
        let mut res = std_Map::new();
        for (k, v) in g.iter() {
            std_map_insert(&mut res, &k, &v);
        }
        res
    }
    
    pub fn std_group_min<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().min().unwrap()
    }
    
    pub fn std_group_max<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().max().unwrap()
    }
    
    pub fn std_group_sum<A: ops::Add + ops::AddAssign>(g: &std_Group<A>) -> A {
        let mut res = std_group_first(g);
        for v in g.iter().skip(1) {
            res += v;
        }
        res
    }
    
    /* Tuples */
    #[derive(Copy, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct tuple0;
    
    impl FromRecord for tuple0 {
        fn from_record(val: &Record) -> Result<Self, String> {
            <()>::from_record(val).map(|_| tuple0)
        }
    }
    
    impl IntoRecord for tuple0 {
        fn into_record(self) -> Record {
            ().into_record()
        }
    }
    
    macro_rules! decl_tuple {
        ( $name:ident, $( $t:tt ),+ ) => {
            #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
            pub struct $name< $($t),* >($(pub $t),*);
            impl <$($t: FromRecord),*> FromRecord for $name<$($t),*> {
                fn from_record(val: &Record) -> Result<Self, String> {
                    <($($t),*)>::from_record(val).map(|($($t),*)|$name($($t),*))
                }
            }
    
            impl <$($t: IntoRecord),*> IntoRecord for $name<$($t),*> {
                fn into_record(self) -> Record {
                    let $name($($t),*) = self;
                    Record::Tuple(vec![$($t.into_record()),*])
                }
            }
    
            impl <$($t: FromRecord),*> Mutator<$name<$($t),*>> for Record {
                fn mutate(&self, x: &mut $name<$($t),*>) -> Result<(), String> {
                    *x = <$name<$($t),*>>::from_record(self)?;
                    Ok(())
                }
            }
        };
    }
    
    decl_tuple!(tuple2, T1, T2);
    decl_tuple!(tuple3, T1, T2, T3);
    decl_tuple!(tuple4, T1, T2, T3, T4);
    decl_tuple!(tuple5, T1, T2, T3, T4, T5);
    decl_tuple!(tuple6, T1, T2, T3, T4, T5, T6);
    decl_tuple!(tuple7, T1, T2, T3, T4, T5, T6, T7);
    decl_tuple!(tuple8, T1, T2, T3, T4, T5, T6, T7, T8);
    decl_tuple!(tuple9, T1, T2, T3, T4, T5, T6, T7, T8, T9);
    decl_tuple!(tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
    decl_tuple!(tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
    decl_tuple!(tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
    decl_tuple!(tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
    decl_tuple!(tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
    decl_tuple!(tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
    decl_tuple!(tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    decl_tuple!(tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
    decl_tuple!(
        tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18
    );
    decl_tuple!(
        tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19
    );
    decl_tuple!(
        tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20
    );
    
    // Endianness
    pub fn std_ntohl(x: &u32) -> u32 {
        u32::from_be(*x)
    }
    
    pub fn std_ntohs(x: &u16) -> u16 {
        u16::from_be(*x)
    }
    
    pub fn std_htonl(x: &u32) -> u32 {
        u32::to_be(*x)
    }
    
    pub fn std_htons(x: &u16) -> u16 {
        u16::to_be(*x)
    }
}
pub use __log::*;
mod __log {
    use super::*;
    use std::collections;
    use std::ffi;
    use std::sync;
    
    type log_callback_t = Box<dyn Fn(log_log_level_t, &str) + Send + Sync>;
    
    lazy_static! {
        /* Logger configuration for each module consists of the maximal enabled
         * log level (messages above this level are ignored) and callback.
         */
        static ref LOG_CONFIG: sync::RwLock<collections::HashMap<log_module_t, (log_callback_t, log_log_level_t)>> = {
            sync::RwLock::new(collections::HashMap::new())
        };
    }
    
    /*
     * Logging API exposed to the DDlog program.
     * (see detailed documentation in `log.dl`)
     */
    pub fn log_log(module: &log_module_t, level: &log_log_level_t, msg: &String) -> bool {
        if let Some((cb, current_level)) = LOG_CONFIG.read().unwrap().get(&module) {
            if *level <= *current_level {
                cb(*level, msg.as_str());
            }
        };
        true
    }
    
    /*
     * Configuration API
     * (detailed documentation in `ddlog_log.h`)
     *
     * `cb = None` - disables logging for the given module.
     *
     * NOTE: we set callback and log level simultaneously.  A more flexible API
     * would allow changing log level without changing the callback.
     */
    pub fn log_set_callback(
        module: log_module_t,
        cb: Option<log_callback_t>,
        max_level: log_log_level_t,
    ) {
        match cb {
            Some(cb) => {
                LOG_CONFIG.write().unwrap().insert(module, (cb, max_level));
            }
            None => {
                LOG_CONFIG.write().unwrap().remove(&module);
            }
        }
    }
    
    /*
     * C bindings for the config API
     */
    #[no_mangle]
    pub unsafe extern "C" fn ddlog_log_set_callback(
        module: raw::c_int,
        cb: Option<extern "C" fn(arg: libc::uintptr_t, level: raw::c_int, msg: *const raw::c_char)>,
        cb_arg: libc::uintptr_t,
        max_level: raw::c_int,
    ) {
        match cb {
            Some(cb) => log_set_callback(
                module as log_module_t,
                Some(Box::new(move |level, msg| {
                    cb(
                        cb_arg,
                        level as raw::c_int,
                        ffi::CString::new(msg).unwrap_or_default().as_ptr(),
                    )
                })),
                max_level as log_log_level_t,
            ),
            None => log_set_callback(module as log_module_t, None, max_level as log_log_level_t),
        }
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Bool {
    ty: TyS
}
impl Abomonation for Bool{}
impl <> record::FromRecord for Bool<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Bool" if _args.len() == 1 => {
                        Ok(Bool{ty: <TyS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Bool in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Bool" => {
                        Ok(Bool{ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Bool in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Bool, <>, ty);
decl_record_mutator_struct!(Bool, <>, ty: TyS);
impl fmt::Display for Bool {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Bool{ty} => {
                __formatter.write_str("Bool{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Bool {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct BoolElim {
    trueCase: TmS,
    falseCase: TmS,
    tm: TmS
}
impl Abomonation for BoolElim{}
impl <> record::FromRecord for BoolElim<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolElim" if _args.len() == 3 => {
                        Ok(BoolElim{trueCase: <TmS>::from_record(&_args[0])?, falseCase: <TmS>::from_record(&_args[1])?, tm: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolElim in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolElim" => {
                        Ok(BoolElim{trueCase: record::arg_extract::<TmS>(_args, "trueCase")?, falseCase: record::arg_extract::<TmS>(_args, "falseCase")?, tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolElim in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(BoolElim, <>, trueCase, falseCase, tm);
decl_record_mutator_struct!(BoolElim, <>, trueCase: TmS, falseCase: TmS, tm: TmS);
impl fmt::Display for BoolElim {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BoolElim{trueCase,falseCase,tm} => {
                __formatter.write_str("BoolElim{")?;
                fmt::Debug::fmt(trueCase, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(falseCase, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for BoolElim {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct BoolElimInput {
    trueCase: TmS,
    falseCase: TmS,
    tm: TmS
}
impl Abomonation for BoolElimInput{}
impl <> record::FromRecord for BoolElimInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolElimInput" if _args.len() == 3 => {
                        Ok(BoolElimInput{trueCase: <TmS>::from_record(&_args[0])?, falseCase: <TmS>::from_record(&_args[1])?, tm: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolElimInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolElimInput" => {
                        Ok(BoolElimInput{trueCase: record::arg_extract::<TmS>(_args, "trueCase")?, falseCase: record::arg_extract::<TmS>(_args, "falseCase")?, tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolElimInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(BoolElimInput, <>, trueCase, falseCase, tm);
decl_record_mutator_struct!(BoolElimInput, <>, trueCase: TmS, falseCase: TmS, tm: TmS);
impl fmt::Display for BoolElimInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BoolElimInput{trueCase,falseCase,tm} => {
                __formatter.write_str("BoolElimInput{")?;
                fmt::Debug::fmt(trueCase, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(falseCase, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for BoolElimInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct BoolInput {
    ty: TyS
}
impl Abomonation for BoolInput{}
impl <> record::FromRecord for BoolInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolInput" if _args.len() == 1 => {
                        Ok(BoolInput{ty: <TyS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "BoolInput" => {
                        Ok(BoolInput{ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type BoolInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(BoolInput, <>, ty);
decl_record_mutator_struct!(BoolInput, <>, ty: TyS);
impl fmt::Display for BoolInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BoolInput{ty} => {
                __formatter.write_str("BoolInput{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for BoolInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Comp {
    g: CtxMorphS,
    f: CtxMorphS,
    gf: CtxMorphS
}
impl Abomonation for Comp{}
impl <> record::FromRecord for Comp<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Comp" if _args.len() == 3 => {
                        Ok(Comp{g: <CtxMorphS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, gf: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Comp in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Comp" => {
                        Ok(Comp{g: record::arg_extract::<CtxMorphS>(_args, "g")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, gf: record::arg_extract::<CtxMorphS>(_args, "gf")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Comp in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Comp, <>, g, f, gf);
decl_record_mutator_struct!(Comp, <>, g: CtxMorphS, f: CtxMorphS, gf: CtxMorphS);
impl fmt::Display for Comp {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Comp{g,f,gf} => {
                __formatter.write_str("Comp{")?;
                fmt::Debug::fmt(g, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(gf, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Comp {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CompInput {
    g: CtxMorphS,
    f: CtxMorphS,
    gf: CtxMorphS
}
impl Abomonation for CompInput{}
impl <> record::FromRecord for CompInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CompInput" if _args.len() == 3 => {
                        Ok(CompInput{g: <CtxMorphS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, gf: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CompInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CompInput" => {
                        Ok(CompInput{g: record::arg_extract::<CtxMorphS>(_args, "g")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, gf: record::arg_extract::<CtxMorphS>(_args, "gf")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CompInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CompInput, <>, g, f, gf);
decl_record_mutator_struct!(CompInput, <>, g: CtxMorphS, f: CtxMorphS, gf: CtxMorphS);
impl fmt::Display for CompInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CompInput{g,f,gf} => {
                __formatter.write_str("CompInput{")?;
                fmt::Debug::fmt(g, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(gf, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CompInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Comprehension {
    without: CtxS,
    ty: TyS,
    with: CtxS
}
impl Abomonation for Comprehension{}
impl <> record::FromRecord for Comprehension<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Comprehension" if _args.len() == 3 => {
                        Ok(Comprehension{without: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, with: <CtxS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Comprehension in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Comprehension" => {
                        Ok(Comprehension{without: record::arg_extract::<CtxS>(_args, "without")?, ty: record::arg_extract::<TyS>(_args, "ty")?, with: record::arg_extract::<CtxS>(_args, "with")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Comprehension in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Comprehension, <>, without, ty, with);
decl_record_mutator_struct!(Comprehension, <>, without: CtxS, ty: TyS, with: CtxS);
impl fmt::Display for Comprehension {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Comprehension{without,ty,with} => {
                __formatter.write_str("Comprehension{")?;
                fmt::Debug::fmt(without, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(with, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Comprehension {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ComprehensionInput {
    without: CtxS,
    ty: TyS,
    with: CtxS
}
impl Abomonation for ComprehensionInput{}
impl <> record::FromRecord for ComprehensionInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ComprehensionInput" if _args.len() == 3 => {
                        Ok(ComprehensionInput{without: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, with: <CtxS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ComprehensionInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ComprehensionInput" => {
                        Ok(ComprehensionInput{without: record::arg_extract::<CtxS>(_args, "without")?, ty: record::arg_extract::<TyS>(_args, "ty")?, with: record::arg_extract::<CtxS>(_args, "with")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ComprehensionInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ComprehensionInput, <>, without, ty, with);
decl_record_mutator_struct!(ComprehensionInput, <>, without: CtxS, ty: TyS, with: CtxS);
impl fmt::Display for ComprehensionInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ComprehensionInput{without,ty,with} => {
                __formatter.write_str("ComprehensionInput{")?;
                fmt::Debug::fmt(without, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(with, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ComprehensionInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Ctx {
    ctx: CtxS
}
impl Abomonation for Ctx{}
impl <> record::FromRecord for Ctx<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Ctx" if _args.len() == 1 => {
                        Ok(Ctx{ctx: <CtxS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Ctx in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Ctx" => {
                        Ok(Ctx{ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Ctx in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Ctx, <>, ctx);
decl_record_mutator_struct!(Ctx, <>, ctx: CtxS);
impl fmt::Display for Ctx {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Ctx{ctx} => {
                __formatter.write_str("Ctx{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Ctx {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxEmpty {
    ctx: CtxS
}
impl Abomonation for CtxEmpty{}
impl <> record::FromRecord for CtxEmpty<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEmpty" if _args.len() == 1 => {
                        Ok(CtxEmpty{ctx: <CtxS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEmpty in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEmpty" => {
                        Ok(CtxEmpty{ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEmpty in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxEmpty, <>, ctx);
decl_record_mutator_struct!(CtxEmpty, <>, ctx: CtxS);
impl fmt::Display for CtxEmpty {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxEmpty{ctx} => {
                __formatter.write_str("CtxEmpty{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxEmpty {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxEmptyInput {
    ctx: CtxS
}
impl Abomonation for CtxEmptyInput{}
impl <> record::FromRecord for CtxEmptyInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEmptyInput" if _args.len() == 1 => {
                        Ok(CtxEmptyInput{ctx: <CtxS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEmptyInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEmptyInput" => {
                        Ok(CtxEmptyInput{ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEmptyInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxEmptyInput, <>, ctx);
decl_record_mutator_struct!(CtxEmptyInput, <>, ctx: CtxS);
impl fmt::Display for CtxEmptyInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxEmptyInput{ctx} => {
                __formatter.write_str("CtxEmptyInput{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxEmptyInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxEq {
    l: CtxS,
    r: CtxS
}
impl Abomonation for CtxEq{}
impl <> record::FromRecord for CtxEq<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEq" if _args.len() == 2 => {
                        Ok(CtxEq{l: <CtxS>::from_record(&_args[0])?, r: <CtxS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEq in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEq" => {
                        Ok(CtxEq{l: record::arg_extract::<CtxS>(_args, "l")?, r: record::arg_extract::<CtxS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEq in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxEq, <>, l, r);
decl_record_mutator_struct!(CtxEq, <>, l: CtxS, r: CtxS);
impl fmt::Display for CtxEq {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxEq{l,r} => {
                __formatter.write_str("CtxEq{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxEq {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxEqInput {
    l: CtxS,
    r: CtxS
}
impl Abomonation for CtxEqInput{}
impl <> record::FromRecord for CtxEqInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEqInput" if _args.len() == 2 => {
                        Ok(CtxEqInput{l: <CtxS>::from_record(&_args[0])?, r: <CtxS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEqInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxEqInput" => {
                        Ok(CtxEqInput{l: record::arg_extract::<CtxS>(_args, "l")?, r: record::arg_extract::<CtxS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxEqInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxEqInput, <>, l, r);
decl_record_mutator_struct!(CtxEqInput, <>, l: CtxS, r: CtxS);
impl fmt::Display for CtxEqInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxEqInput{l,r} => {
                __formatter.write_str("CtxEqInput{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxEqInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxInput {
    ctx: CtxS
}
impl Abomonation for CtxInput{}
impl <> record::FromRecord for CtxInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxInput" if _args.len() == 1 => {
                        Ok(CtxInput{ctx: <CtxS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxInput" => {
                        Ok(CtxInput{ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxInput, <>, ctx);
decl_record_mutator_struct!(CtxInput, <>, ctx: CtxS);
impl fmt::Display for CtxInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxInput{ctx} => {
                __formatter.write_str("CtxInput{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxMorph {
    f: CtxMorphS,
    from: CtxS,
    to: CtxS
}
impl Abomonation for CtxMorph{}
impl <> record::FromRecord for CtxMorph<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorph" if _args.len() == 3 => {
                        Ok(CtxMorph{f: <CtxMorphS>::from_record(&_args[0])?, from: <CtxS>::from_record(&_args[1])?, to: <CtxS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorph in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorph" => {
                        Ok(CtxMorph{f: record::arg_extract::<CtxMorphS>(_args, "f")?, from: record::arg_extract::<CtxS>(_args, "from")?, to: record::arg_extract::<CtxS>(_args, "to")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorph in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxMorph, <>, f, from, to);
decl_record_mutator_struct!(CtxMorph, <>, f: CtxMorphS, from: CtxS, to: CtxS);
impl fmt::Display for CtxMorph {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxMorph{f,from,to} => {
                __formatter.write_str("CtxMorph{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(from, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(to, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxMorph {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxMorphEq {
    l: CtxMorphS,
    r: CtxMorphS
}
impl Abomonation for CtxMorphEq{}
impl <> record::FromRecord for CtxMorphEq<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphEq" if _args.len() == 2 => {
                        Ok(CtxMorphEq{l: <CtxMorphS>::from_record(&_args[0])?, r: <CtxMorphS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphEq in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphEq" => {
                        Ok(CtxMorphEq{l: record::arg_extract::<CtxMorphS>(_args, "l")?, r: record::arg_extract::<CtxMorphS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphEq in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxMorphEq, <>, l, r);
decl_record_mutator_struct!(CtxMorphEq, <>, l: CtxMorphS, r: CtxMorphS);
impl fmt::Display for CtxMorphEq {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxMorphEq{l,r} => {
                __formatter.write_str("CtxMorphEq{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxMorphEq {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxMorphEqInput {
    l: CtxMorphS,
    r: CtxMorphS
}
impl Abomonation for CtxMorphEqInput{}
impl <> record::FromRecord for CtxMorphEqInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphEqInput" if _args.len() == 2 => {
                        Ok(CtxMorphEqInput{l: <CtxMorphS>::from_record(&_args[0])?, r: <CtxMorphS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphEqInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphEqInput" => {
                        Ok(CtxMorphEqInput{l: record::arg_extract::<CtxMorphS>(_args, "l")?, r: record::arg_extract::<CtxMorphS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphEqInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxMorphEqInput, <>, l, r);
decl_record_mutator_struct!(CtxMorphEqInput, <>, l: CtxMorphS, r: CtxMorphS);
impl fmt::Display for CtxMorphEqInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxMorphEqInput{l,r} => {
                __formatter.write_str("CtxMorphEqInput{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxMorphEqInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxMorphInput {
    f: CtxMorphS,
    from: CtxS,
    to: CtxS
}
impl Abomonation for CtxMorphInput{}
impl <> record::FromRecord for CtxMorphInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphInput" if _args.len() == 3 => {
                        Ok(CtxMorphInput{f: <CtxMorphS>::from_record(&_args[0])?, from: <CtxS>::from_record(&_args[1])?, to: <CtxS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphInput" => {
                        Ok(CtxMorphInput{f: record::arg_extract::<CtxMorphS>(_args, "f")?, from: record::arg_extract::<CtxS>(_args, "from")?, to: record::arg_extract::<CtxS>(_args, "to")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxMorphInput, <>, f, from, to);
decl_record_mutator_struct!(CtxMorphInput, <>, f: CtxMorphS, from: CtxS, to: CtxS);
impl fmt::Display for CtxMorphInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxMorphInput{f,from,to} => {
                __formatter.write_str("CtxMorphInput{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(from, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(to, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxMorphInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxMorphS {
    id: u32
}
impl Abomonation for CtxMorphS{}
impl <> record::FromRecord for CtxMorphS<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphS" if _args.len() == 1 => {
                        Ok(CtxMorphS{id: <u32>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphS in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxMorphS" => {
                        Ok(CtxMorphS{id: record::arg_extract::<u32>(_args, "id")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxMorphS in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxMorphS, <>, id);
decl_record_mutator_struct!(CtxMorphS, <>, id: u32);
impl fmt::Display for CtxMorphS {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxMorphS{id} => {
                __formatter.write_str("CtxMorphS{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxMorphS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct CtxS {
    id: u32
}
impl Abomonation for CtxS{}
impl <> record::FromRecord for CtxS<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxS" if _args.len() == 1 => {
                        Ok(CtxS{id: <u32>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxS in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "CtxS" => {
                        Ok(CtxS{id: record::arg_extract::<u32>(_args, "id")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type CtxS in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(CtxS, <>, id);
decl_record_mutator_struct!(CtxS, <>, id: u32);
impl fmt::Display for CtxS {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CtxS{id} => {
                __formatter.write_str("CtxS{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for CtxS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Extension {
    f: CtxMorphS,
    tm: TmS,
    e: CtxMorphS
}
impl Abomonation for Extension{}
impl <> record::FromRecord for Extension<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Extension" if _args.len() == 3 => {
                        Ok(Extension{f: <CtxMorphS>::from_record(&_args[0])?, tm: <TmS>::from_record(&_args[1])?, e: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Extension in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Extension" => {
                        Ok(Extension{f: record::arg_extract::<CtxMorphS>(_args, "f")?, tm: record::arg_extract::<TmS>(_args, "tm")?, e: record::arg_extract::<CtxMorphS>(_args, "e")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Extension in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Extension, <>, f, tm, e);
decl_record_mutator_struct!(Extension, <>, f: CtxMorphS, tm: TmS, e: CtxMorphS);
impl fmt::Display for Extension {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Extension{f,tm,e} => {
                __formatter.write_str("Extension{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(e, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Extension {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ExtensionInput {
    f: CtxMorphS,
    tm: TmS,
    e: CtxMorphS
}
impl Abomonation for ExtensionInput{}
impl <> record::FromRecord for ExtensionInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ExtensionInput" if _args.len() == 3 => {
                        Ok(ExtensionInput{f: <CtxMorphS>::from_record(&_args[0])?, tm: <TmS>::from_record(&_args[1])?, e: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ExtensionInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ExtensionInput" => {
                        Ok(ExtensionInput{f: record::arg_extract::<CtxMorphS>(_args, "f")?, tm: record::arg_extract::<TmS>(_args, "tm")?, e: record::arg_extract::<CtxMorphS>(_args, "e")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ExtensionInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ExtensionInput, <>, f, tm, e);
decl_record_mutator_struct!(ExtensionInput, <>, f: CtxMorphS, tm: TmS, e: CtxMorphS);
impl fmt::Display for ExtensionInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExtensionInput{f,tm,e} => {
                __formatter.write_str("ExtensionInput{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(e, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ExtensionInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct False {
    tm: TmS
}
impl Abomonation for False{}
impl <> record::FromRecord for False<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "False" if _args.len() == 1 => {
                        Ok(False{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type False in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "False" => {
                        Ok(False{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type False in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(False, <>, tm);
decl_record_mutator_struct!(False, <>, tm: TmS);
impl fmt::Display for False {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            False{tm} => {
                __formatter.write_str("False{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for False {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct FalseInput {
    tm: TmS
}
impl Abomonation for FalseInput{}
impl <> record::FromRecord for FalseInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "FalseInput" if _args.len() == 1 => {
                        Ok(FalseInput{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type FalseInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "FalseInput" => {
                        Ok(FalseInput{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type FalseInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(FalseInput, <>, tm);
decl_record_mutator_struct!(FalseInput, <>, tm: TmS);
impl fmt::Display for FalseInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FalseInput{tm} => {
                __formatter.write_str("FalseInput{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for FalseInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Id {
    left: TmS,
    right: TmS,
    ty: TyS
}
impl Abomonation for Id{}
impl <> record::FromRecord for Id<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Id" if _args.len() == 3 => {
                        Ok(Id{left: <TmS>::from_record(&_args[0])?, right: <TmS>::from_record(&_args[1])?, ty: <TyS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Id in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Id" => {
                        Ok(Id{left: record::arg_extract::<TmS>(_args, "left")?, right: record::arg_extract::<TmS>(_args, "right")?, ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Id in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Id, <>, left, right, ty);
decl_record_mutator_struct!(Id, <>, left: TmS, right: TmS, ty: TyS);
impl fmt::Display for Id {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Id{left,right,ty} => {
                __formatter.write_str("Id{")?;
                fmt::Debug::fmt(left, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(right, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Id {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct IdInput {
    left: TmS,
    right: TmS,
    ty: TyS
}
impl Abomonation for IdInput{}
impl <> record::FromRecord for IdInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdInput" if _args.len() == 3 => {
                        Ok(IdInput{left: <TmS>::from_record(&_args[0])?, right: <TmS>::from_record(&_args[1])?, ty: <TyS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdInput" => {
                        Ok(IdInput{left: record::arg_extract::<TmS>(_args, "left")?, right: record::arg_extract::<TmS>(_args, "right")?, ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(IdInput, <>, left, right, ty);
decl_record_mutator_struct!(IdInput, <>, left: TmS, right: TmS, ty: TyS);
impl fmt::Display for IdInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            IdInput{left,right,ty} => {
                __formatter.write_str("IdInput{")?;
                fmt::Debug::fmt(left, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(right, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for IdInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct IdMorph {
    f: CtxMorphS
}
impl Abomonation for IdMorph{}
impl <> record::FromRecord for IdMorph<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdMorph" if _args.len() == 1 => {
                        Ok(IdMorph{f: <CtxMorphS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdMorph in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdMorph" => {
                        Ok(IdMorph{f: record::arg_extract::<CtxMorphS>(_args, "f")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdMorph in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(IdMorph, <>, f);
decl_record_mutator_struct!(IdMorph, <>, f: CtxMorphS);
impl fmt::Display for IdMorph {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            IdMorph{f} => {
                __formatter.write_str("IdMorph{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for IdMorph {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct IdMorphInput {
    f: CtxMorphS
}
impl Abomonation for IdMorphInput{}
impl <> record::FromRecord for IdMorphInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdMorphInput" if _args.len() == 1 => {
                        Ok(IdMorphInput{f: <CtxMorphS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdMorphInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "IdMorphInput" => {
                        Ok(IdMorphInput{f: record::arg_extract::<CtxMorphS>(_args, "f")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type IdMorphInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(IdMorphInput, <>, f);
decl_record_mutator_struct!(IdMorphInput, <>, f: CtxMorphS);
impl fmt::Display for IdMorphInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            IdMorphInput{f} => {
                __formatter.write_str("IdMorphInput{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for IdMorphInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ProjCtx {
    ctx: CtxS,
    ty: TyS,
    f: CtxMorphS
}
impl Abomonation for ProjCtx{}
impl <> record::FromRecord for ProjCtx<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjCtx" if _args.len() == 3 => {
                        Ok(ProjCtx{ctx: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, f: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjCtx in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjCtx" => {
                        Ok(ProjCtx{ctx: record::arg_extract::<CtxS>(_args, "ctx")?, ty: record::arg_extract::<TyS>(_args, "ty")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjCtx in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ProjCtx, <>, ctx, ty, f);
decl_record_mutator_struct!(ProjCtx, <>, ctx: CtxS, ty: TyS, f: CtxMorphS);
impl fmt::Display for ProjCtx {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ProjCtx{ctx,ty,f} => {
                __formatter.write_str("ProjCtx{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ProjCtx {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ProjCtxInput {
    ctx: CtxS,
    ty: TyS,
    f: CtxMorphS
}
impl Abomonation for ProjCtxInput{}
impl <> record::FromRecord for ProjCtxInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjCtxInput" if _args.len() == 3 => {
                        Ok(ProjCtxInput{ctx: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, f: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjCtxInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjCtxInput" => {
                        Ok(ProjCtxInput{ctx: record::arg_extract::<CtxS>(_args, "ctx")?, ty: record::arg_extract::<TyS>(_args, "ty")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjCtxInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ProjCtxInput, <>, ctx, ty, f);
decl_record_mutator_struct!(ProjCtxInput, <>, ctx: CtxS, ty: TyS, f: CtxMorphS);
impl fmt::Display for ProjCtxInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ProjCtxInput{ctx,ty,f} => {
                __formatter.write_str("ProjCtxInput{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ProjCtxInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ProjTm {
    ctx: CtxS,
    ty: TyS,
    tm: TmS
}
impl Abomonation for ProjTm{}
impl <> record::FromRecord for ProjTm<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjTm" if _args.len() == 3 => {
                        Ok(ProjTm{ctx: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, tm: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjTm in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjTm" => {
                        Ok(ProjTm{ctx: record::arg_extract::<CtxS>(_args, "ctx")?, ty: record::arg_extract::<TyS>(_args, "ty")?, tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjTm in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ProjTm, <>, ctx, ty, tm);
decl_record_mutator_struct!(ProjTm, <>, ctx: CtxS, ty: TyS, tm: TmS);
impl fmt::Display for ProjTm {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ProjTm{ctx,ty,tm} => {
                __formatter.write_str("ProjTm{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ProjTm {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ProjTmInput {
    ctx: CtxS,
    ty: TyS,
    tm: TmS
}
impl Abomonation for ProjTmInput{}
impl <> record::FromRecord for ProjTmInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjTmInput" if _args.len() == 3 => {
                        Ok(ProjTmInput{ctx: <CtxS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, tm: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjTmInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ProjTmInput" => {
                        Ok(ProjTmInput{ctx: record::arg_extract::<CtxS>(_args, "ctx")?, ty: record::arg_extract::<TyS>(_args, "ty")?, tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ProjTmInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ProjTmInput, <>, ctx, ty, tm);
decl_record_mutator_struct!(ProjTmInput, <>, ctx: CtxS, ty: TyS, tm: TmS);
impl fmt::Display for ProjTmInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ProjTmInput{ctx,ty,tm} => {
                __formatter.write_str("ProjTmInput{")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ProjTmInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Refl {
    tm: TmS
}
impl Abomonation for Refl{}
impl <> record::FromRecord for Refl<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Refl" if _args.len() == 1 => {
                        Ok(Refl{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Refl in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Refl" => {
                        Ok(Refl{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Refl in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Refl, <>, tm);
decl_record_mutator_struct!(Refl, <>, tm: TmS);
impl fmt::Display for Refl {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Refl{tm} => {
                __formatter.write_str("Refl{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Refl {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct ReflInput {
    tm: TmS
}
impl Abomonation for ReflInput{}
impl <> record::FromRecord for ReflInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ReflInput" if _args.len() == 1 => {
                        Ok(ReflInput{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ReflInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ReflInput" => {
                        Ok(ReflInput{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type ReflInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ReflInput, <>, tm);
decl_record_mutator_struct!(ReflInput, <>, tm: TmS);
impl fmt::Display for ReflInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ReflInput{tm} => {
                __formatter.write_str("ReflInput{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ReflInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Tm {
    tm: TmS,
    ty: TyS
}
impl Abomonation for Tm{}
impl <> record::FromRecord for Tm<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Tm" if _args.len() == 2 => {
                        Ok(Tm{tm: <TmS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Tm in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Tm" => {
                        Ok(Tm{tm: record::arg_extract::<TmS>(_args, "tm")?, ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Tm in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Tm, <>, tm, ty);
decl_record_mutator_struct!(Tm, <>, tm: TmS, ty: TyS);
impl fmt::Display for Tm {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Tm{tm,ty} => {
                __formatter.write_str("Tm{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Tm {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmBar {
    tm: TmS,
    f: CtxMorphS
}
impl Abomonation for TmBar{}
impl <> record::FromRecord for TmBar<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmBar" if _args.len() == 2 => {
                        Ok(TmBar{tm: <TmS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmBar in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmBar" => {
                        Ok(TmBar{tm: record::arg_extract::<TmS>(_args, "tm")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmBar in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmBar, <>, tm, f);
decl_record_mutator_struct!(TmBar, <>, tm: TmS, f: CtxMorphS);
impl fmt::Display for TmBar {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmBar{tm,f} => {
                __formatter.write_str("TmBar{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmBar {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmEq {
    l: TmS,
    r: TmS
}
impl Abomonation for TmEq{}
impl <> record::FromRecord for TmEq<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmEq" if _args.len() == 2 => {
                        Ok(TmEq{l: <TmS>::from_record(&_args[0])?, r: <TmS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmEq in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmEq" => {
                        Ok(TmEq{l: record::arg_extract::<TmS>(_args, "l")?, r: record::arg_extract::<TmS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmEq in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmEq, <>, l, r);
decl_record_mutator_struct!(TmEq, <>, l: TmS, r: TmS);
impl fmt::Display for TmEq {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmEq{l,r} => {
                __formatter.write_str("TmEq{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmEq {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmEqInput {
    l: TmS,
    r: TmS
}
impl Abomonation for TmEqInput{}
impl <> record::FromRecord for TmEqInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmEqInput" if _args.len() == 2 => {
                        Ok(TmEqInput{l: <TmS>::from_record(&_args[0])?, r: <TmS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmEqInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmEqInput" => {
                        Ok(TmEqInput{l: record::arg_extract::<TmS>(_args, "l")?, r: record::arg_extract::<TmS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmEqInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmEqInput, <>, l, r);
decl_record_mutator_struct!(TmEqInput, <>, l: TmS, r: TmS);
impl fmt::Display for TmEqInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmEqInput{l,r} => {
                __formatter.write_str("TmEqInput{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmEqInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmInput {
    tm: TmS,
    ty: TyS
}
impl Abomonation for TmInput{}
impl <> record::FromRecord for TmInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmInput" if _args.len() == 2 => {
                        Ok(TmInput{tm: <TmS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmInput" => {
                        Ok(TmInput{tm: record::arg_extract::<TmS>(_args, "tm")?, ty: record::arg_extract::<TyS>(_args, "ty")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmInput, <>, tm, ty);
decl_record_mutator_struct!(TmInput, <>, tm: TmS, ty: TyS);
impl fmt::Display for TmInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmInput{tm,ty} => {
                __formatter.write_str("TmInput{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmS {
    id: u32
}
impl Abomonation for TmS{}
impl <> record::FromRecord for TmS<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmS" if _args.len() == 1 => {
                        Ok(TmS{id: <u32>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmS in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmS" => {
                        Ok(TmS{id: record::arg_extract::<u32>(_args, "id")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmS in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmS, <>, id);
decl_record_mutator_struct!(TmS, <>, id: u32);
impl fmt::Display for TmS {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmS{id} => {
                __formatter.write_str("TmS{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmSubst {
    tm: TmS,
    f: CtxMorphS,
    sub: TmS
}
impl Abomonation for TmSubst{}
impl <> record::FromRecord for TmSubst<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmSubst" if _args.len() == 3 => {
                        Ok(TmSubst{tm: <TmS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, sub: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmSubst in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmSubst" => {
                        Ok(TmSubst{tm: record::arg_extract::<TmS>(_args, "tm")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, sub: record::arg_extract::<TmS>(_args, "sub")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmSubst in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmSubst, <>, tm, f, sub);
decl_record_mutator_struct!(TmSubst, <>, tm: TmS, f: CtxMorphS, sub: TmS);
impl fmt::Display for TmSubst {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmSubst{tm,f,sub} => {
                __formatter.write_str("TmSubst{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(sub, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmSubst {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TmSubstInput {
    tm: TmS,
    f: CtxMorphS,
    sub: TmS
}
impl Abomonation for TmSubstInput{}
impl <> record::FromRecord for TmSubstInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmSubstInput" if _args.len() == 3 => {
                        Ok(TmSubstInput{tm: <TmS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, sub: <TmS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmSubstInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TmSubstInput" => {
                        Ok(TmSubstInput{tm: record::arg_extract::<TmS>(_args, "tm")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, sub: record::arg_extract::<TmS>(_args, "sub")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TmSubstInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TmSubstInput, <>, tm, f, sub);
decl_record_mutator_struct!(TmSubstInput, <>, tm: TmS, f: CtxMorphS, sub: TmS);
impl fmt::Display for TmSubstInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TmSubstInput{tm,f,sub} => {
                __formatter.write_str("TmSubstInput{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(sub, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TmSubstInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct True {
    tm: TmS
}
impl Abomonation for True{}
impl <> record::FromRecord for True<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "True" if _args.len() == 1 => {
                        Ok(True{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type True in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "True" => {
                        Ok(True{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type True in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(True, <>, tm);
decl_record_mutator_struct!(True, <>, tm: TmS);
impl fmt::Display for True {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            True{tm} => {
                __formatter.write_str("True{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for True {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TrueInput {
    tm: TmS
}
impl Abomonation for TrueInput{}
impl <> record::FromRecord for TrueInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TrueInput" if _args.len() == 1 => {
                        Ok(TrueInput{tm: <TmS>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TrueInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TrueInput" => {
                        Ok(TrueInput{tm: record::arg_extract::<TmS>(_args, "tm")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TrueInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TrueInput, <>, tm);
decl_record_mutator_struct!(TrueInput, <>, tm: TmS);
impl fmt::Display for TrueInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TrueInput{tm} => {
                __formatter.write_str("TrueInput{")?;
                fmt::Debug::fmt(tm, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TrueInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Ty {
    ty: TyS,
    ctx: CtxS
}
impl Abomonation for Ty{}
impl <> record::FromRecord for Ty<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Ty" if _args.len() == 2 => {
                        Ok(Ty{ty: <TyS>::from_record(&_args[0])?, ctx: <CtxS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Ty in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Ty" => {
                        Ok(Ty{ty: record::arg_extract::<TyS>(_args, "ty")?, ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Ty in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Ty, <>, ty, ctx);
decl_record_mutator_struct!(Ty, <>, ty: TyS, ctx: CtxS);
impl fmt::Display for Ty {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Ty{ty,ctx} => {
                __formatter.write_str("Ty{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Ty {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TyEq {
    l: TyS,
    r: TyS
}
impl Abomonation for TyEq{}
impl <> record::FromRecord for TyEq<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyEq" if _args.len() == 2 => {
                        Ok(TyEq{l: <TyS>::from_record(&_args[0])?, r: <TyS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyEq in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyEq" => {
                        Ok(TyEq{l: record::arg_extract::<TyS>(_args, "l")?, r: record::arg_extract::<TyS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyEq in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TyEq, <>, l, r);
decl_record_mutator_struct!(TyEq, <>, l: TyS, r: TyS);
impl fmt::Display for TyEq {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TyEq{l,r} => {
                __formatter.write_str("TyEq{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TyEq {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TyEqInput {
    l: TyS,
    r: TyS
}
impl Abomonation for TyEqInput{}
impl <> record::FromRecord for TyEqInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyEqInput" if _args.len() == 2 => {
                        Ok(TyEqInput{l: <TyS>::from_record(&_args[0])?, r: <TyS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyEqInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyEqInput" => {
                        Ok(TyEqInput{l: record::arg_extract::<TyS>(_args, "l")?, r: record::arg_extract::<TyS>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyEqInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TyEqInput, <>, l, r);
decl_record_mutator_struct!(TyEqInput, <>, l: TyS, r: TyS);
impl fmt::Display for TyEqInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TyEqInput{l,r} => {
                __formatter.write_str("TyEqInput{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TyEqInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TyInput {
    ty: TyS,
    ctx: CtxS
}
impl Abomonation for TyInput{}
impl <> record::FromRecord for TyInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyInput" if _args.len() == 2 => {
                        Ok(TyInput{ty: <TyS>::from_record(&_args[0])?, ctx: <CtxS>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyInput" => {
                        Ok(TyInput{ty: record::arg_extract::<TyS>(_args, "ty")?, ctx: record::arg_extract::<CtxS>(_args, "ctx")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TyInput, <>, ty, ctx);
decl_record_mutator_struct!(TyInput, <>, ty: TyS, ctx: CtxS);
impl fmt::Display for TyInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TyInput{ty,ctx} => {
                __formatter.write_str("TyInput{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ctx, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TyInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TyS {
    id: u32
}
impl Abomonation for TyS{}
impl <> record::FromRecord for TyS<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyS" if _args.len() == 1 => {
                        Ok(TyS{id: <u32>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyS in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TyS" => {
                        Ok(TyS{id: record::arg_extract::<u32>(_args, "id")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TyS in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TyS, <>, id);
decl_record_mutator_struct!(TyS, <>, id: u32);
impl fmt::Display for TyS {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TyS{id} => {
                __formatter.write_str("TyS{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TyS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TySubst {
    ty: TyS,
    f: CtxMorphS,
    sub: TyS
}
impl Abomonation for TySubst{}
impl <> record::FromRecord for TySubst<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TySubst" if _args.len() == 3 => {
                        Ok(TySubst{ty: <TyS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, sub: <TyS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TySubst in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TySubst" => {
                        Ok(TySubst{ty: record::arg_extract::<TyS>(_args, "ty")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, sub: record::arg_extract::<TyS>(_args, "sub")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TySubst in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TySubst, <>, ty, f, sub);
decl_record_mutator_struct!(TySubst, <>, ty: TyS, f: CtxMorphS, sub: TyS);
impl fmt::Display for TySubst {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TySubst{ty,f,sub} => {
                __formatter.write_str("TySubst{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(sub, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TySubst {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TySubstInput {
    ty: TyS,
    f: CtxMorphS,
    sub: TyS
}
impl Abomonation for TySubstInput{}
impl <> record::FromRecord for TySubstInput<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TySubstInput" if _args.len() == 3 => {
                        Ok(TySubstInput{ty: <TyS>::from_record(&_args[0])?, f: <CtxMorphS>::from_record(&_args[1])?, sub: <TyS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TySubstInput in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TySubstInput" => {
                        Ok(TySubstInput{ty: record::arg_extract::<TyS>(_args, "ty")?, f: record::arg_extract::<CtxMorphS>(_args, "f")?, sub: record::arg_extract::<TyS>(_args, "sub")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TySubstInput in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TySubstInput, <>, ty, f, sub);
decl_record_mutator_struct!(TySubstInput, <>, ty: TyS, f: CtxMorphS, sub: TyS);
impl fmt::Display for TySubstInput {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TySubstInput{ty,f,sub} => {
                __formatter.write_str("TySubstInput{")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(sub, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TySubstInput {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Weakening {
    f: CtxMorphS,
    ty: TyS,
    q: CtxMorphS
}
impl Abomonation for Weakening{}
impl <> record::FromRecord for Weakening<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Weakening" if _args.len() == 3 => {
                        Ok(Weakening{f: <CtxMorphS>::from_record(&_args[0])?, ty: <TyS>::from_record(&_args[1])?, q: <CtxMorphS>::from_record(&_args[2])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Weakening in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Weakening" => {
                        Ok(Weakening{f: record::arg_extract::<CtxMorphS>(_args, "f")?, ty: record::arg_extract::<TyS>(_args, "ty")?, q: record::arg_extract::<CtxMorphS>(_args, "q")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Weakening in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Weakening, <>, f, ty, q);
decl_record_mutator_struct!(Weakening, <>, f: CtxMorphS, ty: TyS, q: CtxMorphS);
impl fmt::Display for Weakening {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Weakening{f,ty,q} => {
                __formatter.write_str("Weakening{")?;
                fmt::Debug::fmt(f, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(q, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Weakening {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
pub type log_log_level_t = i32;
pub type log_module_t = i32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Either<A, B> {
    std_Left {
        l: A
    },
    std_Right {
        r: B
    }
}
impl <A: Val, B: Val> Abomonation for std_Either<A, B>{}
impl <A: record::FromRecord + Default,B: record::FromRecord + Default> record::FromRecord for std_Either<A,B> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Left" if _args.len() == 1 => {
                        Ok(std_Either::std_Left{l: <A>::from_record(&_args[0])?})
                    },
                    "std.Right" if _args.len() == 1 => {
                        Ok(std_Either::std_Right{r: <B>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Left" => {
                        Ok(std_Either::std_Left{l: record::arg_extract::<A>(_args, "l")?})
                    },
                    "std.Right" => {
                        Ok(std_Either::std_Right{r: record::arg_extract::<B>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Either, <A,B>, std_Left{l}, std_Right{r});
decl_record_mutator_enum!(std_Either, <A,B>, std_Left{l: A}, std_Right{r: B});
impl <A: fmt::Debug, B: fmt::Debug> fmt::Display for std_Either<A, B> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Either::std_Left{l} => {
                __formatter.write_str("std.Left{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str("}")
            },
            std_Either::std_Right{r} => {
                __formatter.write_str("std.Right{")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug, B: fmt::Debug> fmt::Debug for std_Either<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default, B: Default> Default for std_Either<A, B> {
    fn default() -> Self {
        std_Either::std_Left{l : Default::default()}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Option<A> {
    std_Some {
        x: A
    },
    std_None
}
impl <A: Val> Abomonation for std_Option<A>{}
impl <A: record::FromRecord + Default> record::FromRecord for std_Option<A> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Some" if _args.len() == 1 => {
                        Ok(std_Option::std_Some{x: <A>::from_record(&_args[0])?})
                    },
                    "std.None" if _args.len() == 0 => {
                        Ok(std_Option::std_None{})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Some" => {
                        Ok(std_Option::std_Some{x: record::arg_extract::<A>(_args, "x")?})
                    },
                    "std.None" => {
                        Ok(std_Option::std_None{})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Option, <A>, std_Some{x}, std_None{});
decl_record_mutator_enum!(std_Option, <A>, std_Some{x: A}, std_None{});
impl <A: fmt::Debug> fmt::Display for std_Option<A> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Option::std_Some{x} => {
                __formatter.write_str("std.Some{")?;
                fmt::Debug::fmt(x, __formatter)?;
                __formatter.write_str("}")
            },
            std_Option::std_None{} => {
                __formatter.write_str("std.None{")?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug> fmt::Debug for std_Option<A> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default> Default for std_Option<A> {
    fn default() -> Self {
        std_Option::std_Some{x : Default::default()}
    }
}
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> Result<Self, Self::Error> {
         match rname {
        "Bool" => Ok(Relations::Bool),
        "BoolElim" => Ok(Relations::BoolElim),
        "BoolElimInput" => Ok(Relations::BoolElimInput),
        "BoolInput" => Ok(Relations::BoolInput),
        "Comp" => Ok(Relations::Comp),
        "CompInput" => Ok(Relations::CompInput),
        "Comprehension" => Ok(Relations::Comprehension),
        "ComprehensionInput" => Ok(Relations::ComprehensionInput),
        "Ctx" => Ok(Relations::Ctx),
        "CtxEmpty" => Ok(Relations::CtxEmpty),
        "CtxEmptyInput" => Ok(Relations::CtxEmptyInput),
        "CtxEq" => Ok(Relations::CtxEq),
        "CtxEqInput" => Ok(Relations::CtxEqInput),
        "CtxInput" => Ok(Relations::CtxInput),
        "CtxMorph" => Ok(Relations::CtxMorph),
        "CtxMorphEq" => Ok(Relations::CtxMorphEq),
        "CtxMorphEqInput" => Ok(Relations::CtxMorphEqInput),
        "CtxMorphInput" => Ok(Relations::CtxMorphInput),
        "Extension" => Ok(Relations::Extension),
        "ExtensionInput" => Ok(Relations::ExtensionInput),
        "False" => Ok(Relations::False),
        "FalseInput" => Ok(Relations::FalseInput),
        "Id" => Ok(Relations::Id),
        "IdInput" => Ok(Relations::IdInput),
        "IdMorph" => Ok(Relations::IdMorph),
        "IdMorphInput" => Ok(Relations::IdMorphInput),
        "ProjCtx" => Ok(Relations::ProjCtx),
        "ProjCtxInput" => Ok(Relations::ProjCtxInput),
        "ProjTm" => Ok(Relations::ProjTm),
        "ProjTmInput" => Ok(Relations::ProjTmInput),
        "Refl" => Ok(Relations::Refl),
        "ReflInput" => Ok(Relations::ReflInput),
        "Tm" => Ok(Relations::Tm),
        "TmBar" => Ok(Relations::TmBar),
        "TmEq" => Ok(Relations::TmEq),
        "TmEqInput" => Ok(Relations::TmEqInput),
        "TmInput" => Ok(Relations::TmInput),
        "TmSubst" => Ok(Relations::TmSubst),
        "TmSubstInput" => Ok(Relations::TmSubstInput),
        "True" => Ok(Relations::True),
        "TrueInput" => Ok(Relations::TrueInput),
        "Ty" => Ok(Relations::Ty),
        "TyEq" => Ok(Relations::TyEq),
        "TyEqInput" => Ok(Relations::TyEqInput),
        "TyInput" => Ok(Relations::TyInput),
        "TySubst" => Ok(Relations::TySubst),
        "TySubstInput" => Ok(Relations::TySubstInput),
        "Weakening" => Ok(Relations::Weakening),
        "__Null" => Ok(Relations::__Null),
        "__Prefix_0" => Ok(Relations::__Prefix_0),
        "__Prefix_1" => Ok(Relations::__Prefix_1),
        "__Prefix_2" => Ok(Relations::__Prefix_2),
        "__Prefix_3" => Ok(Relations::__Prefix_3),
        "__Prefix_4" => Ok(Relations::__Prefix_4),
        "__Prefix_5" => Ok(Relations::__Prefix_5),
        "__Prefix_6" => Ok(Relations::__Prefix_6),
        "__Prefix_7" => Ok(Relations::__Prefix_7),
        "__Prefix_8" => Ok(Relations::__Prefix_8),
             _  => Err(())
         }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
        Relations::Bool => true,
        Relations::BoolElim => true,
        Relations::Comp => true,
        Relations::Comprehension => true,
        Relations::Ctx => true,
        Relations::CtxEmpty => true,
        Relations::CtxEq => true,
        Relations::CtxMorph => true,
        Relations::CtxMorphEq => true,
        Relations::Extension => true,
        Relations::False => true,
        Relations::Id => true,
        Relations::IdMorph => true,
        Relations::ProjCtx => true,
        Relations::ProjTm => true,
        Relations::Refl => true,
        Relations::Tm => true,
        Relations::TmBar => true,
        Relations::TmEq => true,
        Relations::TmSubst => true,
        Relations::True => true,
        Relations::Ty => true,
        Relations::TyEq => true,
        Relations::TySubst => true,
        Relations::Weakening => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
        Relations::BoolElimInput => true,
        Relations::BoolInput => true,
        Relations::CompInput => true,
        Relations::ComprehensionInput => true,
        Relations::CtxEmptyInput => true,
        Relations::CtxEqInput => true,
        Relations::CtxInput => true,
        Relations::CtxMorphEqInput => true,
        Relations::CtxMorphInput => true,
        Relations::ExtensionInput => true,
        Relations::FalseInput => true,
        Relations::IdInput => true,
        Relations::IdMorphInput => true,
        Relations::ProjCtxInput => true,
        Relations::ProjTmInput => true,
        Relations::ReflInput => true,
        Relations::TmEqInput => true,
        Relations::TmInput => true,
        Relations::TmSubstInput => true,
        Relations::TrueInput => true,
        Relations::TyEqInput => true,
        Relations::TyInput => true,
        Relations::TySubstInput => true,
            _  => false
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> Result<Self, Self::Error> {
         match rid {
        0 => Ok(Relations::Bool),
        1 => Ok(Relations::BoolElim),
        2 => Ok(Relations::BoolElimInput),
        3 => Ok(Relations::BoolInput),
        4 => Ok(Relations::Comp),
        5 => Ok(Relations::CompInput),
        6 => Ok(Relations::Comprehension),
        7 => Ok(Relations::ComprehensionInput),
        8 => Ok(Relations::Ctx),
        9 => Ok(Relations::CtxEmpty),
        10 => Ok(Relations::CtxEmptyInput),
        11 => Ok(Relations::CtxEq),
        12 => Ok(Relations::CtxEqInput),
        13 => Ok(Relations::CtxInput),
        14 => Ok(Relations::CtxMorph),
        15 => Ok(Relations::CtxMorphEq),
        16 => Ok(Relations::CtxMorphEqInput),
        17 => Ok(Relations::CtxMorphInput),
        18 => Ok(Relations::Extension),
        19 => Ok(Relations::ExtensionInput),
        20 => Ok(Relations::False),
        21 => Ok(Relations::FalseInput),
        22 => Ok(Relations::Id),
        23 => Ok(Relations::IdInput),
        24 => Ok(Relations::IdMorph),
        25 => Ok(Relations::IdMorphInput),
        26 => Ok(Relations::ProjCtx),
        27 => Ok(Relations::ProjCtxInput),
        28 => Ok(Relations::ProjTm),
        29 => Ok(Relations::ProjTmInput),
        30 => Ok(Relations::Refl),
        31 => Ok(Relations::ReflInput),
        32 => Ok(Relations::Tm),
        33 => Ok(Relations::TmBar),
        34 => Ok(Relations::TmEq),
        35 => Ok(Relations::TmEqInput),
        36 => Ok(Relations::TmInput),
        37 => Ok(Relations::TmSubst),
        38 => Ok(Relations::TmSubstInput),
        39 => Ok(Relations::True),
        40 => Ok(Relations::TrueInput),
        41 => Ok(Relations::Ty),
        42 => Ok(Relations::TyEq),
        43 => Ok(Relations::TyEqInput),
        44 => Ok(Relations::TyInput),
        45 => Ok(Relations::TySubst),
        46 => Ok(Relations::TySubstInput),
        47 => Ok(Relations::Weakening),
        48 => Ok(Relations::__Null),
        49 => Ok(Relations::__Prefix_0),
        50 => Ok(Relations::__Prefix_1),
        51 => Ok(Relations::__Prefix_2),
        52 => Ok(Relations::__Prefix_3),
        53 => Ok(Relations::__Prefix_4),
        54 => Ok(Relations::__Prefix_5),
        55 => Ok(Relations::__Prefix_6),
        56 => Ok(Relations::__Prefix_7),
        57 => Ok(Relations::__Prefix_8),
             _  => Err(())
         }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
   match rid {
        0 => Some(&"Bool"),
        1 => Some(&"BoolElim"),
        2 => Some(&"BoolElimInput"),
        3 => Some(&"BoolInput"),
        4 => Some(&"Comp"),
        5 => Some(&"CompInput"),
        6 => Some(&"Comprehension"),
        7 => Some(&"ComprehensionInput"),
        8 => Some(&"Ctx"),
        9 => Some(&"CtxEmpty"),
        10 => Some(&"CtxEmptyInput"),
        11 => Some(&"CtxEq"),
        12 => Some(&"CtxEqInput"),
        13 => Some(&"CtxInput"),
        14 => Some(&"CtxMorph"),
        15 => Some(&"CtxMorphEq"),
        16 => Some(&"CtxMorphEqInput"),
        17 => Some(&"CtxMorphInput"),
        18 => Some(&"Extension"),
        19 => Some(&"ExtensionInput"),
        20 => Some(&"False"),
        21 => Some(&"FalseInput"),
        22 => Some(&"Id"),
        23 => Some(&"IdInput"),
        24 => Some(&"IdMorph"),
        25 => Some(&"IdMorphInput"),
        26 => Some(&"ProjCtx"),
        27 => Some(&"ProjCtxInput"),
        28 => Some(&"ProjTm"),
        29 => Some(&"ProjTmInput"),
        30 => Some(&"Refl"),
        31 => Some(&"ReflInput"),
        32 => Some(&"Tm"),
        33 => Some(&"TmBar"),
        34 => Some(&"TmEq"),
        35 => Some(&"TmEqInput"),
        36 => Some(&"TmInput"),
        37 => Some(&"TmSubst"),
        38 => Some(&"TmSubstInput"),
        39 => Some(&"True"),
        40 => Some(&"TrueInput"),
        41 => Some(&"Ty"),
        42 => Some(&"TyEq"),
        43 => Some(&"TyEqInput"),
        44 => Some(&"TyInput"),
        45 => Some(&"TySubst"),
        46 => Some(&"TySubstInput"),
        47 => Some(&"Weakening"),
        48 => Some(&"__Null"),
        49 => Some(&"__Prefix_0"),
        50 => Some(&"__Prefix_1"),
        51 => Some(&"__Prefix_2"),
        52 => Some(&"__Prefix_3"),
        53 => Some(&"__Prefix_4"),
        54 => Some(&"__Prefix_5"),
        55 => Some(&"__Prefix_6"),
        56 => Some(&"__Prefix_7"),
        57 => Some(&"__Prefix_8"),
       _  => None
   }
}
pub fn relid2cname(rid: RelId) -> Option<&'static ffi::CStr> {
    RELIDMAPC.get(&rid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Bool, "Bool");
        m.insert(Relations::BoolElim, "BoolElim");
        m.insert(Relations::BoolElimInput, "BoolElimInput");
        m.insert(Relations::BoolInput, "BoolInput");
        m.insert(Relations::Comp, "Comp");
        m.insert(Relations::CompInput, "CompInput");
        m.insert(Relations::Comprehension, "Comprehension");
        m.insert(Relations::ComprehensionInput, "ComprehensionInput");
        m.insert(Relations::Ctx, "Ctx");
        m.insert(Relations::CtxEmpty, "CtxEmpty");
        m.insert(Relations::CtxEmptyInput, "CtxEmptyInput");
        m.insert(Relations::CtxEq, "CtxEq");
        m.insert(Relations::CtxEqInput, "CtxEqInput");
        m.insert(Relations::CtxInput, "CtxInput");
        m.insert(Relations::CtxMorph, "CtxMorph");
        m.insert(Relations::CtxMorphEq, "CtxMorphEq");
        m.insert(Relations::CtxMorphEqInput, "CtxMorphEqInput");
        m.insert(Relations::CtxMorphInput, "CtxMorphInput");
        m.insert(Relations::Extension, "Extension");
        m.insert(Relations::ExtensionInput, "ExtensionInput");
        m.insert(Relations::False, "False");
        m.insert(Relations::FalseInput, "FalseInput");
        m.insert(Relations::Id, "Id");
        m.insert(Relations::IdInput, "IdInput");
        m.insert(Relations::IdMorph, "IdMorph");
        m.insert(Relations::IdMorphInput, "IdMorphInput");
        m.insert(Relations::ProjCtx, "ProjCtx");
        m.insert(Relations::ProjCtxInput, "ProjCtxInput");
        m.insert(Relations::ProjTm, "ProjTm");
        m.insert(Relations::ProjTmInput, "ProjTmInput");
        m.insert(Relations::Refl, "Refl");
        m.insert(Relations::ReflInput, "ReflInput");
        m.insert(Relations::Tm, "Tm");
        m.insert(Relations::TmBar, "TmBar");
        m.insert(Relations::TmEq, "TmEq");
        m.insert(Relations::TmEqInput, "TmEqInput");
        m.insert(Relations::TmInput, "TmInput");
        m.insert(Relations::TmSubst, "TmSubst");
        m.insert(Relations::TmSubstInput, "TmSubstInput");
        m.insert(Relations::True, "True");
        m.insert(Relations::TrueInput, "TrueInput");
        m.insert(Relations::Ty, "Ty");
        m.insert(Relations::TyEq, "TyEq");
        m.insert(Relations::TyEqInput, "TyEqInput");
        m.insert(Relations::TyInput, "TyInput");
        m.insert(Relations::TySubst, "TySubst");
        m.insert(Relations::TySubstInput, "TySubstInput");
        m.insert(Relations::Weakening, "Weakening");
        m.insert(Relations::__Null, "__Null");
        m.insert(Relations::__Prefix_0, "__Prefix_0");
        m.insert(Relations::__Prefix_1, "__Prefix_1");
        m.insert(Relations::__Prefix_2, "__Prefix_2");
        m.insert(Relations::__Prefix_3, "__Prefix_3");
        m.insert(Relations::__Prefix_4, "__Prefix_4");
        m.insert(Relations::__Prefix_5, "__Prefix_5");
        m.insert(Relations::__Prefix_6, "__Prefix_6");
        m.insert(Relations::__Prefix_7, "__Prefix_7");
        m.insert(Relations::__Prefix_8, "__Prefix_8");
        m
   };
}
lazy_static! {
    pub static ref RELIDMAPC: FnvHashMap<RelId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("Bool").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(1, ffi::CString::new("BoolElim").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(2, ffi::CString::new("BoolElimInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(3, ffi::CString::new("BoolInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(4, ffi::CString::new("Comp").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(5, ffi::CString::new("CompInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(6, ffi::CString::new("Comprehension").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(7, ffi::CString::new("ComprehensionInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(8, ffi::CString::new("Ctx").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(9, ffi::CString::new("CtxEmpty").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(10, ffi::CString::new("CtxEmptyInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(11, ffi::CString::new("CtxEq").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(12, ffi::CString::new("CtxEqInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(13, ffi::CString::new("CtxInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(14, ffi::CString::new("CtxMorph").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(15, ffi::CString::new("CtxMorphEq").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(16, ffi::CString::new("CtxMorphEqInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(17, ffi::CString::new("CtxMorphInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(18, ffi::CString::new("Extension").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(19, ffi::CString::new("ExtensionInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(20, ffi::CString::new("False").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(21, ffi::CString::new("FalseInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(22, ffi::CString::new("Id").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(23, ffi::CString::new("IdInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(24, ffi::CString::new("IdMorph").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(25, ffi::CString::new("IdMorphInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(26, ffi::CString::new("ProjCtx").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(27, ffi::CString::new("ProjCtxInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(28, ffi::CString::new("ProjTm").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(29, ffi::CString::new("ProjTmInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(30, ffi::CString::new("Refl").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(31, ffi::CString::new("ReflInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(32, ffi::CString::new("Tm").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(33, ffi::CString::new("TmBar").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(34, ffi::CString::new("TmEq").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(35, ffi::CString::new("TmEqInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(36, ffi::CString::new("TmInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(37, ffi::CString::new("TmSubst").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(38, ffi::CString::new("TmSubstInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(39, ffi::CString::new("True").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(40, ffi::CString::new("TrueInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(41, ffi::CString::new("Ty").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(42, ffi::CString::new("TyEq").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(43, ffi::CString::new("TyEqInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(44, ffi::CString::new("TyInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(45, ffi::CString::new("TySubst").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(46, ffi::CString::new("TySubstInput").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(47, ffi::CString::new("Weakening").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(48, ffi::CString::new("__Null").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(49, ffi::CString::new("__Prefix_0").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(50, ffi::CString::new("__Prefix_1").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(51, ffi::CString::new("__Prefix_2").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(52, ffi::CString::new("__Prefix_3").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(53, ffi::CString::new("__Prefix_4").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(54, ffi::CString::new("__Prefix_5").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(55, ffi::CString::new("__Prefix_6").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(56, ffi::CString::new("__Prefix_7").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(57, ffi::CString::new("__Prefix_8").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m
   };
}
lazy_static! {
    pub static ref INPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::BoolElimInput, "BoolElimInput");
        m.insert(Relations::BoolInput, "BoolInput");
        m.insert(Relations::CompInput, "CompInput");
        m.insert(Relations::ComprehensionInput, "ComprehensionInput");
        m.insert(Relations::CtxEmptyInput, "CtxEmptyInput");
        m.insert(Relations::CtxEqInput, "CtxEqInput");
        m.insert(Relations::CtxInput, "CtxInput");
        m.insert(Relations::CtxMorphEqInput, "CtxMorphEqInput");
        m.insert(Relations::CtxMorphInput, "CtxMorphInput");
        m.insert(Relations::ExtensionInput, "ExtensionInput");
        m.insert(Relations::FalseInput, "FalseInput");
        m.insert(Relations::IdInput, "IdInput");
        m.insert(Relations::IdMorphInput, "IdMorphInput");
        m.insert(Relations::ProjCtxInput, "ProjCtxInput");
        m.insert(Relations::ProjTmInput, "ProjTmInput");
        m.insert(Relations::ReflInput, "ReflInput");
        m.insert(Relations::TmEqInput, "TmEqInput");
        m.insert(Relations::TmInput, "TmInput");
        m.insert(Relations::TmSubstInput, "TmSubstInput");
        m.insert(Relations::TrueInput, "TrueInput");
        m.insert(Relations::TyEqInput, "TyEqInput");
        m.insert(Relations::TyInput, "TyInput");
        m.insert(Relations::TySubstInput, "TySubstInput");
        m
    };
}
lazy_static! {
    pub static ref OUTPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Bool, "Bool");
        m.insert(Relations::BoolElim, "BoolElim");
        m.insert(Relations::Comp, "Comp");
        m.insert(Relations::Comprehension, "Comprehension");
        m.insert(Relations::Ctx, "Ctx");
        m.insert(Relations::CtxEmpty, "CtxEmpty");
        m.insert(Relations::CtxEq, "CtxEq");
        m.insert(Relations::CtxMorph, "CtxMorph");
        m.insert(Relations::CtxMorphEq, "CtxMorphEq");
        m.insert(Relations::Extension, "Extension");
        m.insert(Relations::False, "False");
        m.insert(Relations::Id, "Id");
        m.insert(Relations::IdMorph, "IdMorph");
        m.insert(Relations::ProjCtx, "ProjCtx");
        m.insert(Relations::ProjTm, "ProjTm");
        m.insert(Relations::Refl, "Refl");
        m.insert(Relations::Tm, "Tm");
        m.insert(Relations::TmBar, "TmBar");
        m.insert(Relations::TmEq, "TmEq");
        m.insert(Relations::TmSubst, "TmSubst");
        m.insert(Relations::True, "True");
        m.insert(Relations::Ty, "Ty");
        m.insert(Relations::TyEq, "TyEq");
        m.insert(Relations::TySubst, "TySubst");
        m.insert(Relations::Weakening, "Weakening");
        m
    };
}
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> Result<Self, Self::Error> {
         match iname {
        "__Null_by_none" => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> Result<Self, Self::Error> {
         match iid {
        0 => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
   match iid {
        0 => Some(&"__Null_by_none"),
       _  => None
   }
}
pub fn indexid2cname(iid: IdxId) -> Option<&'static ffi::CStr> {
    IDXIDMAPC.get(&iid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref IDXIDMAP: FnvHashMap<Indexes, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Indexes::__Null_by_none, "__Null_by_none");
        m
   };
}
lazy_static! {
    pub static ref IDXIDMAPC: FnvHashMap<IdxId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("__Null_by_none").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert index name to C string").unwrap()));
        m
   };
}
pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {
    match rel {
        Relations::Bool => {
            Ok(Value::Bool(<Bool>::from_record(_rec)?))
        },
        Relations::BoolElim => {
            Ok(Value::BoolElim(<BoolElim>::from_record(_rec)?))
        },
        Relations::BoolElimInput => {
            Ok(Value::BoolElimInput(<BoolElimInput>::from_record(_rec)?))
        },
        Relations::BoolInput => {
            Ok(Value::BoolInput(<BoolInput>::from_record(_rec)?))
        },
        Relations::Comp => {
            Ok(Value::Comp(<Comp>::from_record(_rec)?))
        },
        Relations::CompInput => {
            Ok(Value::CompInput(<CompInput>::from_record(_rec)?))
        },
        Relations::Comprehension => {
            Ok(Value::Comprehension(<Comprehension>::from_record(_rec)?))
        },
        Relations::ComprehensionInput => {
            Ok(Value::ComprehensionInput(<ComprehensionInput>::from_record(_rec)?))
        },
        Relations::Ctx => {
            Ok(Value::Ctx(<Ctx>::from_record(_rec)?))
        },
        Relations::CtxEmpty => {
            Ok(Value::CtxEmpty(<CtxEmpty>::from_record(_rec)?))
        },
        Relations::CtxEmptyInput => {
            Ok(Value::CtxEmptyInput(<CtxEmptyInput>::from_record(_rec)?))
        },
        Relations::CtxEq => {
            Ok(Value::CtxEq(<CtxEq>::from_record(_rec)?))
        },
        Relations::CtxEqInput => {
            Ok(Value::CtxEqInput(<CtxEqInput>::from_record(_rec)?))
        },
        Relations::CtxInput => {
            Ok(Value::CtxInput(<CtxInput>::from_record(_rec)?))
        },
        Relations::CtxMorph => {
            Ok(Value::CtxMorph(<CtxMorph>::from_record(_rec)?))
        },
        Relations::CtxMorphEq => {
            Ok(Value::CtxMorphEq(<CtxMorphEq>::from_record(_rec)?))
        },
        Relations::CtxMorphEqInput => {
            Ok(Value::CtxMorphEqInput(<CtxMorphEqInput>::from_record(_rec)?))
        },
        Relations::CtxMorphInput => {
            Ok(Value::CtxMorphInput(<CtxMorphInput>::from_record(_rec)?))
        },
        Relations::Extension => {
            Ok(Value::Extension(<Extension>::from_record(_rec)?))
        },
        Relations::ExtensionInput => {
            Ok(Value::ExtensionInput(<ExtensionInput>::from_record(_rec)?))
        },
        Relations::False => {
            Ok(Value::False(<False>::from_record(_rec)?))
        },
        Relations::FalseInput => {
            Ok(Value::FalseInput(<FalseInput>::from_record(_rec)?))
        },
        Relations::Id => {
            Ok(Value::Id(<Id>::from_record(_rec)?))
        },
        Relations::IdInput => {
            Ok(Value::IdInput(<IdInput>::from_record(_rec)?))
        },
        Relations::IdMorph => {
            Ok(Value::IdMorph(<IdMorph>::from_record(_rec)?))
        },
        Relations::IdMorphInput => {
            Ok(Value::IdMorphInput(<IdMorphInput>::from_record(_rec)?))
        },
        Relations::ProjCtx => {
            Ok(Value::ProjCtx(<ProjCtx>::from_record(_rec)?))
        },
        Relations::ProjCtxInput => {
            Ok(Value::ProjCtxInput(<ProjCtxInput>::from_record(_rec)?))
        },
        Relations::ProjTm => {
            Ok(Value::ProjTm(<ProjTm>::from_record(_rec)?))
        },
        Relations::ProjTmInput => {
            Ok(Value::ProjTmInput(<ProjTmInput>::from_record(_rec)?))
        },
        Relations::Refl => {
            Ok(Value::Refl(<Refl>::from_record(_rec)?))
        },
        Relations::ReflInput => {
            Ok(Value::ReflInput(<ReflInput>::from_record(_rec)?))
        },
        Relations::Tm => {
            Ok(Value::Tm(<Tm>::from_record(_rec)?))
        },
        Relations::TmBar => {
            Ok(Value::TmBar(<TmBar>::from_record(_rec)?))
        },
        Relations::TmEq => {
            Ok(Value::TmEq(<TmEq>::from_record(_rec)?))
        },
        Relations::TmEqInput => {
            Ok(Value::TmEqInput(<TmEqInput>::from_record(_rec)?))
        },
        Relations::TmInput => {
            Ok(Value::TmInput(<TmInput>::from_record(_rec)?))
        },
        Relations::TmSubst => {
            Ok(Value::TmSubst(<TmSubst>::from_record(_rec)?))
        },
        Relations::TmSubstInput => {
            Ok(Value::TmSubstInput(<TmSubstInput>::from_record(_rec)?))
        },
        Relations::True => {
            Ok(Value::True(<True>::from_record(_rec)?))
        },
        Relations::TrueInput => {
            Ok(Value::TrueInput(<TrueInput>::from_record(_rec)?))
        },
        Relations::Ty => {
            Ok(Value::Ty(<Ty>::from_record(_rec)?))
        },
        Relations::TyEq => {
            Ok(Value::TyEq(<TyEq>::from_record(_rec)?))
        },
        Relations::TyEqInput => {
            Ok(Value::TyEqInput(<TyEqInput>::from_record(_rec)?))
        },
        Relations::TyInput => {
            Ok(Value::TyInput(<TyInput>::from_record(_rec)?))
        },
        Relations::TySubst => {
            Ok(Value::TySubst(<TySubst>::from_record(_rec)?))
        },
        Relations::TySubstInput => {
            Ok(Value::TySubstInput(<TySubstInput>::from_record(_rec)?))
        },
        Relations::Weakening => {
            Ok(Value::Weakening(<Weakening>::from_record(_rec)?))
        },
        Relations::__Null => {
            Ok(Value::tuple0__(<()>::from_record(_rec)?))
        },
        Relations::__Prefix_0 => {
            Ok(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new(<(TmS, TmS, TmS, TmS, CtxMorphS, CtxMorphS)>::from_record(_rec)?)))
        },
        Relations::__Prefix_1 => {
            Ok(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new(<(TmS, TmS, TmS, TmS, CtxMorphS, CtxMorphS)>::from_record(_rec)?)))
        },
        Relations::__Prefix_2 => {
            Ok(Value::tuple3__CtxS_TyS_TyS(<(CtxS, TyS, TyS)>::from_record(_rec)?))
        },
        Relations::__Prefix_3 => {
            Ok(Value::tuple4__CtxS_TmS_CtxMorphS_TyS(<(CtxS, TmS, CtxMorphS, TyS)>::from_record(_rec)?))
        },
        Relations::__Prefix_4 => {
            Ok(Value::tuple2__CtxS_CtxMorphS(<(CtxS, CtxMorphS)>::from_record(_rec)?))
        },
        Relations::__Prefix_5 => {
            Ok(Value::tuple2__TmS_TyS(<(TmS, TyS)>::from_record(_rec)?))
        },
        Relations::__Prefix_6 => {
            Ok(Value::tuple2__TmS_TyS(<(TmS, TyS)>::from_record(_rec)?))
        },
        Relations::__Prefix_7 => {
            Ok(Value::tuple2__TmS_TyS(<(TmS, TyS)>::from_record(_rec)?))
        },
        Relations::__Prefix_8 => {
            Ok(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new(<(TmS, TmS, TmS, TmS, CtxMorphS, CtxMorphS)>::from_record(_rec)?)))
        }
    }
}
pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {
    match rel {
        _ => Err(format!("relation {:?} does not have a primary key", rel))
    }
}
pub fn idxkey_from_record(idx: Indexes, _rec: &record::Record) -> Result<Value, String> {
    match idx {
        Indexes::__Null_by_none => {
            Ok(Value::tuple0__(<()>::from_record(_rec)?))
        },
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::__Null_by_none => ( 48, 0),
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    Bool = 0,
    BoolElim = 1,
    BoolElimInput = 2,
    BoolInput = 3,
    Comp = 4,
    CompInput = 5,
    Comprehension = 6,
    ComprehensionInput = 7,
    Ctx = 8,
    CtxEmpty = 9,
    CtxEmptyInput = 10,
    CtxEq = 11,
    CtxEqInput = 12,
    CtxInput = 13,
    CtxMorph = 14,
    CtxMorphEq = 15,
    CtxMorphEqInput = 16,
    CtxMorphInput = 17,
    Extension = 18,
    ExtensionInput = 19,
    False = 20,
    FalseInput = 21,
    Id = 22,
    IdInput = 23,
    IdMorph = 24,
    IdMorphInput = 25,
    ProjCtx = 26,
    ProjCtxInput = 27,
    ProjTm = 28,
    ProjTmInput = 29,
    Refl = 30,
    ReflInput = 31,
    Tm = 32,
    TmBar = 33,
    TmEq = 34,
    TmEqInput = 35,
    TmInput = 36,
    TmSubst = 37,
    TmSubstInput = 38,
    True = 39,
    TrueInput = 40,
    Ty = 41,
    TyEq = 42,
    TyEqInput = 43,
    TyInput = 44,
    TySubst = 45,
    TySubstInput = 46,
    Weakening = 47,
    __Null = 48,
    __Prefix_0 = 49,
    __Prefix_1 = 50,
    __Prefix_2 = 51,
    __Prefix_3 = 52,
    __Prefix_4 = 53,
    __Prefix_5 = 54,
    __Prefix_6 = 55,
    __Prefix_7 = 56,
    __Prefix_8 = 57
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Indexes {
    __Null_by_none = 0
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub enum Value {
    tuple0__(()),
    tuple2__CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS)),
    tuple3__CtxMorphS_CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS, CtxMorphS)),
    tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS, CtxMorphS, CtxMorphS)),
    tuple3__CtxMorphS_CtxMorphS_TyS((CtxMorphS, CtxMorphS, TyS)),
    tuple4__CtxMorphS_CtxMorphS_TyS_TyS((CtxMorphS, CtxMorphS, TyS, TyS)),
    tuple2__CtxMorphS_CtxS((CtxMorphS, CtxS)),
    tuple3__CtxMorphS_CtxS_CtxS((CtxMorphS, CtxS, CtxS)),
    tuple2__CtxMorphS_TmS((CtxMorphS, TmS)),
    tuple2__CtxMorphS_TyS((CtxMorphS, TyS)),
    tuple3__CtxMorphS_TyS_TyS((CtxMorphS, TyS, TyS)),
    tuple2__CtxS_CtxMorphS((CtxS, CtxMorphS)),
    tuple3__CtxS_CtxMorphS_CtxMorphS((CtxS, CtxMorphS, CtxMorphS)),
    tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS((CtxS, CtxMorphS, CtxMorphS, CtxMorphS)),
    tuple4__CtxS_CtxMorphS_CtxMorphS_TyS((CtxS, CtxMorphS, CtxMorphS, TyS)),
    tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS(boxed::Box<(CtxS, CtxMorphS, CtxMorphS, TyS, TyS)>),
    tuple3__CtxS_CtxMorphS_TyS((CtxS, CtxMorphS, TyS)),
    tuple4__CtxS_CtxMorphS_TyS_TyS((CtxS, CtxMorphS, TyS, TyS)),
    tuple2__CtxS_CtxS((CtxS, CtxS)),
    tuple3__CtxS_CtxS_CtxMorphS((CtxS, CtxS, CtxMorphS)),
    tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS(boxed::Box<(CtxS, CtxS, CtxMorphS, CtxMorphS, TyS)>),
    tuple4__CtxS_CtxS_TmS_TmS((CtxS, CtxS, TmS, TmS)),
    tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS(boxed::Box<(CtxS, CtxS, TmS, TmS, TyS, TyS)>),
    tuple3__CtxS_CtxS_TyS((CtxS, CtxS, TyS)),
    tuple4__CtxS_CtxS_TyS_TyS((CtxS, CtxS, TyS, TyS)),
    tuple2__CtxS_TmS((CtxS, TmS)),
    tuple3__CtxS_TmS_CtxMorphS((CtxS, TmS, CtxMorphS)),
    tuple4__CtxS_TmS_CtxMorphS_TyS((CtxS, TmS, CtxMorphS, TyS)),
    tuple3__CtxS_TmS_TmS((CtxS, TmS, TmS)),
    tuple4__CtxS_TmS_TmS_CtxMorphS((CtxS, TmS, TmS, CtxMorphS)),
    tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(boxed::Box<(CtxS, TmS, TmS, CtxMorphS, TyS)>),
    tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(boxed::Box<(CtxS, TmS, TmS, TmS, CtxMorphS)>),
    tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(boxed::Box<(CtxS, TmS, TmS, TmS, CtxMorphS, CtxMorphS, TyS)>),
    tuple4__CtxS_TmS_TmS_TyS((CtxS, TmS, TmS, TyS)),
    tuple5__CtxS_TmS_TmS_TyS_TyS(boxed::Box<(CtxS, TmS, TmS, TyS, TyS)>),
    tuple3__CtxS_TmS_TyS((CtxS, TmS, TyS)),
    tuple2__CtxS_TyS((CtxS, TyS)),
    tuple3__CtxS_TyS_TyS((CtxS, TyS, TyS)),
    tuple2__TmS_CtxMorphS((TmS, CtxMorphS)),
    tuple3__TmS_CtxMorphS_CtxMorphS((TmS, CtxMorphS, CtxMorphS)),
    tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((TmS, CtxMorphS, CtxMorphS, CtxMorphS)),
    tuple4__TmS_CtxMorphS_CtxMorphS_TyS((TmS, CtxMorphS, CtxMorphS, TyS)),
    tuple3__TmS_CtxMorphS_TyS((TmS, CtxMorphS, TyS)),
    tuple2__TmS_TmS((TmS, TmS)),
    tuple3__TmS_TmS_CtxMorphS((TmS, TmS, CtxMorphS)),
    tuple4__TmS_TmS_CtxMorphS_CtxMorphS((TmS, TmS, CtxMorphS, CtxMorphS)),
    tuple4__TmS_TmS_CtxMorphS_TyS((TmS, TmS, CtxMorphS, TyS)),
    tuple5__TmS_TmS_CtxMorphS_TyS_TyS(boxed::Box<(TmS, TmS, CtxMorphS, TyS, TyS)>),
    tuple3__TmS_TmS_TmS((TmS, TmS, TmS)),
    tuple4__TmS_TmS_TmS_CtxMorphS((TmS, TmS, TmS, CtxMorphS)),
    tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box<(TmS, TmS, TmS, CtxMorphS, CtxMorphS)>),
    tuple5__TmS_TmS_TmS_TmS_CtxMorphS(boxed::Box<(TmS, TmS, TmS, TmS, CtxMorphS)>),
    tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box<(TmS, TmS, TmS, TmS, CtxMorphS, CtxMorphS)>),
    tuple3__TmS_TmS_TyS((TmS, TmS, TyS)),
    tuple4__TmS_TmS_TyS_TyS((TmS, TmS, TyS, TyS)),
    tuple2__TmS_TyS((TmS, TyS)),
    tuple2__TyS_CtxMorphS((TyS, CtxMorphS)),
    tuple3__TyS_CtxMorphS_TyS((TyS, CtxMorphS, TyS)),
    tuple2__TyS_CtxS((TyS, CtxS)),
    tuple2__TyS_TyS((TyS, TyS)),
    Bool(Bool),
    BoolElim(BoolElim),
    BoolElimInput(BoolElimInput),
    BoolInput(BoolInput),
    Comp(Comp),
    CompInput(CompInput),
    Comprehension(Comprehension),
    ComprehensionInput(ComprehensionInput),
    Ctx(Ctx),
    CtxEmpty(CtxEmpty),
    CtxEmptyInput(CtxEmptyInput),
    CtxEq(CtxEq),
    CtxEqInput(CtxEqInput),
    CtxInput(CtxInput),
    CtxMorph(CtxMorph),
    CtxMorphEq(CtxMorphEq),
    CtxMorphEqInput(CtxMorphEqInput),
    CtxMorphInput(CtxMorphInput),
    CtxMorphS(CtxMorphS),
    CtxS(CtxS),
    Extension(Extension),
    ExtensionInput(ExtensionInput),
    False(False),
    FalseInput(FalseInput),
    Id(Id),
    IdInput(IdInput),
    IdMorph(IdMorph),
    IdMorphInput(IdMorphInput),
    ProjCtx(ProjCtx),
    ProjCtxInput(ProjCtxInput),
    ProjTm(ProjTm),
    ProjTmInput(ProjTmInput),
    Refl(Refl),
    ReflInput(ReflInput),
    Tm(Tm),
    TmBar(TmBar),
    TmEq(TmEq),
    TmEqInput(TmEqInput),
    TmInput(TmInput),
    TmS(TmS),
    TmSubst(TmSubst),
    TmSubstInput(TmSubstInput),
    True(True),
    TrueInput(TrueInput),
    Ty(Ty),
    TyEq(TyEq),
    TyEqInput(TyEqInput),
    TyInput(TyInput),
    TyS(TyS),
    TySubst(TySubst),
    TySubstInput(TySubstInput),
    Weakening(Weakening)
}
impl Abomonation for Value {}
impl Default for Value {
    fn default() -> Value {Value::tuple0__(())}
}
impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Value::tuple0__ (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxMorphS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxMorphS_CtxMorphS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxMorphS_CtxS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxMorphS_CtxS_CtxS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxMorphS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxMorphS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_CtxMorphS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_CtxMorphS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxS_CtxS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_CtxS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_CtxS_TmS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_CtxS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_CtxS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_TmS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_TmS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_TmS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__CtxS_TmS_TmS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple5__CtxS_TmS_TmS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_TmS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__CtxS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__CtxS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TmS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_CtxMorphS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TmS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TmS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TmS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_TmS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple5__TmS_TmS_CtxMorphS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TmS_TmS_TmS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_TmS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple5__TmS_TmS_TmS_TmS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TmS_TmS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple4__TmS_TmS_TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TmS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TyS_CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::tuple3__TyS_CtxMorphS_TyS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TyS_CtxS (v) => write!(f, "{:?}", *v),
            Value::tuple2__TyS_TyS (v) => write!(f, "{:?}", *v),
            Value::Bool (v) => write!(f, "{:?}", *v),
            Value::BoolElim (v) => write!(f, "{:?}", *v),
            Value::BoolElimInput (v) => write!(f, "{:?}", *v),
            Value::BoolInput (v) => write!(f, "{:?}", *v),
            Value::Comp (v) => write!(f, "{:?}", *v),
            Value::CompInput (v) => write!(f, "{:?}", *v),
            Value::Comprehension (v) => write!(f, "{:?}", *v),
            Value::ComprehensionInput (v) => write!(f, "{:?}", *v),
            Value::Ctx (v) => write!(f, "{:?}", *v),
            Value::CtxEmpty (v) => write!(f, "{:?}", *v),
            Value::CtxEmptyInput (v) => write!(f, "{:?}", *v),
            Value::CtxEq (v) => write!(f, "{:?}", *v),
            Value::CtxEqInput (v) => write!(f, "{:?}", *v),
            Value::CtxInput (v) => write!(f, "{:?}", *v),
            Value::CtxMorph (v) => write!(f, "{:?}", *v),
            Value::CtxMorphEq (v) => write!(f, "{:?}", *v),
            Value::CtxMorphEqInput (v) => write!(f, "{:?}", *v),
            Value::CtxMorphInput (v) => write!(f, "{:?}", *v),
            Value::CtxMorphS (v) => write!(f, "{:?}", *v),
            Value::CtxS (v) => write!(f, "{:?}", *v),
            Value::Extension (v) => write!(f, "{:?}", *v),
            Value::ExtensionInput (v) => write!(f, "{:?}", *v),
            Value::False (v) => write!(f, "{:?}", *v),
            Value::FalseInput (v) => write!(f, "{:?}", *v),
            Value::Id (v) => write!(f, "{:?}", *v),
            Value::IdInput (v) => write!(f, "{:?}", *v),
            Value::IdMorph (v) => write!(f, "{:?}", *v),
            Value::IdMorphInput (v) => write!(f, "{:?}", *v),
            Value::ProjCtx (v) => write!(f, "{:?}", *v),
            Value::ProjCtxInput (v) => write!(f, "{:?}", *v),
            Value::ProjTm (v) => write!(f, "{:?}", *v),
            Value::ProjTmInput (v) => write!(f, "{:?}", *v),
            Value::Refl (v) => write!(f, "{:?}", *v),
            Value::ReflInput (v) => write!(f, "{:?}", *v),
            Value::Tm (v) => write!(f, "{:?}", *v),
            Value::TmBar (v) => write!(f, "{:?}", *v),
            Value::TmEq (v) => write!(f, "{:?}", *v),
            Value::TmEqInput (v) => write!(f, "{:?}", *v),
            Value::TmInput (v) => write!(f, "{:?}", *v),
            Value::TmS (v) => write!(f, "{:?}", *v),
            Value::TmSubst (v) => write!(f, "{:?}", *v),
            Value::TmSubstInput (v) => write!(f, "{:?}", *v),
            Value::True (v) => write!(f, "{:?}", *v),
            Value::TrueInput (v) => write!(f, "{:?}", *v),
            Value::Ty (v) => write!(f, "{:?}", *v),
            Value::TyEq (v) => write!(f, "{:?}", *v),
            Value::TyEqInput (v) => write!(f, "{:?}", *v),
            Value::TyInput (v) => write!(f, "{:?}", *v),
            Value::TyS (v) => write!(f, "{:?}", *v),
            Value::TySubst (v) => write!(f, "{:?}", *v),
            Value::TySubstInput (v) => write!(f, "{:?}", *v),
            Value::Weakening (v) => write!(f, "{:?}", *v)
        }
    }
}
decl_val_enum_into_record!(Value, <>, tuple0__(x), tuple2__CtxMorphS_CtxMorphS(x), tuple3__CtxMorphS_CtxMorphS_CtxMorphS(x), tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS(x), tuple3__CtxMorphS_CtxMorphS_TyS(x), tuple4__CtxMorphS_CtxMorphS_TyS_TyS(x), tuple2__CtxMorphS_CtxS(x), tuple3__CtxMorphS_CtxS_CtxS(x), tuple2__CtxMorphS_TmS(x), tuple2__CtxMorphS_TyS(x), tuple3__CtxMorphS_TyS_TyS(x), tuple2__CtxS_CtxMorphS(x), tuple3__CtxS_CtxMorphS_CtxMorphS(x), tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS(x), tuple4__CtxS_CtxMorphS_CtxMorphS_TyS(x), tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS(x), tuple3__CtxS_CtxMorphS_TyS(x), tuple4__CtxS_CtxMorphS_TyS_TyS(x), tuple2__CtxS_CtxS(x), tuple3__CtxS_CtxS_CtxMorphS(x), tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS(x), tuple4__CtxS_CtxS_TmS_TmS(x), tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS(x), tuple3__CtxS_CtxS_TyS(x), tuple4__CtxS_CtxS_TyS_TyS(x), tuple2__CtxS_TmS(x), tuple3__CtxS_TmS_CtxMorphS(x), tuple4__CtxS_TmS_CtxMorphS_TyS(x), tuple3__CtxS_TmS_TmS(x), tuple4__CtxS_TmS_TmS_CtxMorphS(x), tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(x), tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(x), tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(x), tuple4__CtxS_TmS_TmS_TyS(x), tuple5__CtxS_TmS_TmS_TyS_TyS(x), tuple3__CtxS_TmS_TyS(x), tuple2__CtxS_TyS(x), tuple3__CtxS_TyS_TyS(x), tuple2__TmS_CtxMorphS(x), tuple3__TmS_CtxMorphS_CtxMorphS(x), tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS(x), tuple4__TmS_CtxMorphS_CtxMorphS_TyS(x), tuple3__TmS_CtxMorphS_TyS(x), tuple2__TmS_TmS(x), tuple3__TmS_TmS_CtxMorphS(x), tuple4__TmS_TmS_CtxMorphS_CtxMorphS(x), tuple4__TmS_TmS_CtxMorphS_TyS(x), tuple5__TmS_TmS_CtxMorphS_TyS_TyS(x), tuple3__TmS_TmS_TmS(x), tuple4__TmS_TmS_TmS_CtxMorphS(x), tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(x), tuple5__TmS_TmS_TmS_TmS_CtxMorphS(x), tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(x), tuple3__TmS_TmS_TyS(x), tuple4__TmS_TmS_TyS_TyS(x), tuple2__TmS_TyS(x), tuple2__TyS_CtxMorphS(x), tuple3__TyS_CtxMorphS_TyS(x), tuple2__TyS_CtxS(x), tuple2__TyS_TyS(x), Bool(x), BoolElim(x), BoolElimInput(x), BoolInput(x), Comp(x), CompInput(x), Comprehension(x), ComprehensionInput(x), Ctx(x), CtxEmpty(x), CtxEmptyInput(x), CtxEq(x), CtxEqInput(x), CtxInput(x), CtxMorph(x), CtxMorphEq(x), CtxMorphEqInput(x), CtxMorphInput(x), CtxMorphS(x), CtxS(x), Extension(x), ExtensionInput(x), False(x), FalseInput(x), Id(x), IdInput(x), IdMorph(x), IdMorphInput(x), ProjCtx(x), ProjCtxInput(x), ProjTm(x), ProjTmInput(x), Refl(x), ReflInput(x), Tm(x), TmBar(x), TmEq(x), TmEqInput(x), TmInput(x), TmS(x), TmSubst(x), TmSubstInput(x), True(x), TrueInput(x), Ty(x), TyEq(x), TyEqInput(x), TyInput(x), TyS(x), TySubst(x), TySubstInput(x), Weakening(x));
decl_record_mutator_val_enum!(Value, <>, tuple0__(()), tuple2__CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS)), tuple3__CtxMorphS_CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS, CtxMorphS)), tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS((CtxMorphS, CtxMorphS, CtxMorphS, CtxMorphS)), tuple3__CtxMorphS_CtxMorphS_TyS((CtxMorphS, CtxMorphS, TyS)), tuple4__CtxMorphS_CtxMorphS_TyS_TyS((CtxMorphS, CtxMorphS, TyS, TyS)), tuple2__CtxMorphS_CtxS((CtxMorphS, CtxS)), tuple3__CtxMorphS_CtxS_CtxS((CtxMorphS, CtxS, CtxS)), tuple2__CtxMorphS_TmS((CtxMorphS, TmS)), tuple2__CtxMorphS_TyS((CtxMorphS, TyS)), tuple3__CtxMorphS_TyS_TyS((CtxMorphS, TyS, TyS)), tuple2__CtxS_CtxMorphS((CtxS, CtxMorphS)), tuple3__CtxS_CtxMorphS_CtxMorphS((CtxS, CtxMorphS, CtxMorphS)), tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS((CtxS, CtxMorphS, CtxMorphS, CtxMorphS)), tuple4__CtxS_CtxMorphS_CtxMorphS_TyS((CtxS, CtxMorphS, CtxMorphS, TyS)), tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS((CtxS, CtxMorphS, CtxMorphS, TyS, TyS)), tuple3__CtxS_CtxMorphS_TyS((CtxS, CtxMorphS, TyS)), tuple4__CtxS_CtxMorphS_TyS_TyS((CtxS, CtxMorphS, TyS, TyS)), tuple2__CtxS_CtxS((CtxS, CtxS)), tuple3__CtxS_CtxS_CtxMorphS((CtxS, CtxS, CtxMorphS)), tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS((CtxS, CtxS, CtxMorphS, CtxMorphS, TyS)), tuple4__CtxS_CtxS_TmS_TmS((CtxS, CtxS, TmS, TmS)), tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS((CtxS, CtxS, TmS, TmS, TyS, TyS)), tuple3__CtxS_CtxS_TyS((CtxS, CtxS, TyS)), tuple4__CtxS_CtxS_TyS_TyS((CtxS, CtxS, TyS, TyS)), tuple2__CtxS_TmS((CtxS, TmS)), tuple3__CtxS_TmS_CtxMorphS((CtxS, TmS, CtxMorphS)), tuple4__CtxS_TmS_CtxMorphS_TyS((CtxS, TmS, CtxMorphS, TyS)), tuple3__CtxS_TmS_TmS((CtxS, TmS, TmS)), tuple4__CtxS_TmS_TmS_CtxMorphS((CtxS, TmS, TmS, CtxMorphS)), tuple5__CtxS_TmS_TmS_CtxMorphS_TyS((CtxS, TmS, TmS, CtxMorphS, TyS)), tuple5__CtxS_TmS_TmS_TmS_CtxMorphS((CtxS, TmS, TmS, TmS, CtxMorphS)), tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS((CtxS, TmS, TmS, TmS, CtxMorphS, CtxMorphS, TyS)), tuple4__CtxS_TmS_TmS_TyS((CtxS, TmS, TmS, TyS)), tuple5__CtxS_TmS_TmS_TyS_TyS((CtxS, TmS, TmS, TyS, TyS)), tuple3__CtxS_TmS_TyS((CtxS, TmS, TyS)), tuple2__CtxS_TyS((CtxS, TyS)), tuple3__CtxS_TyS_TyS((CtxS, TyS, TyS)), tuple2__TmS_CtxMorphS((TmS, CtxMorphS)), tuple3__TmS_CtxMorphS_CtxMorphS((TmS, CtxMorphS, CtxMorphS)), tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((TmS, CtxMorphS, CtxMorphS, CtxMorphS)), tuple4__TmS_CtxMorphS_CtxMorphS_TyS((TmS, CtxMorphS, CtxMorphS, TyS)), tuple3__TmS_CtxMorphS_TyS((TmS, CtxMorphS, TyS)), tuple2__TmS_TmS((TmS, TmS)), tuple3__TmS_TmS_CtxMorphS((TmS, TmS, CtxMorphS)), tuple4__TmS_TmS_CtxMorphS_CtxMorphS((TmS, TmS, CtxMorphS, CtxMorphS)), tuple4__TmS_TmS_CtxMorphS_TyS((TmS, TmS, CtxMorphS, TyS)), tuple5__TmS_TmS_CtxMorphS_TyS_TyS((TmS, TmS, CtxMorphS, TyS, TyS)), tuple3__TmS_TmS_TmS((TmS, TmS, TmS)), tuple4__TmS_TmS_TmS_CtxMorphS((TmS, TmS, TmS, CtxMorphS)), tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS((TmS, TmS, TmS, CtxMorphS, CtxMorphS)), tuple5__TmS_TmS_TmS_TmS_CtxMorphS((TmS, TmS, TmS, TmS, CtxMorphS)), tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS((TmS, TmS, TmS, TmS, CtxMorphS, CtxMorphS)), tuple3__TmS_TmS_TyS((TmS, TmS, TyS)), tuple4__TmS_TmS_TyS_TyS((TmS, TmS, TyS, TyS)), tuple2__TmS_TyS((TmS, TyS)), tuple2__TyS_CtxMorphS((TyS, CtxMorphS)), tuple3__TyS_CtxMorphS_TyS((TyS, CtxMorphS, TyS)), tuple2__TyS_CtxS((TyS, CtxS)), tuple2__TyS_TyS((TyS, TyS)), Bool(Bool), BoolElim(BoolElim), BoolElimInput(BoolElimInput), BoolInput(BoolInput), Comp(Comp), CompInput(CompInput), Comprehension(Comprehension), ComprehensionInput(ComprehensionInput), Ctx(Ctx), CtxEmpty(CtxEmpty), CtxEmptyInput(CtxEmptyInput), CtxEq(CtxEq), CtxEqInput(CtxEqInput), CtxInput(CtxInput), CtxMorph(CtxMorph), CtxMorphEq(CtxMorphEq), CtxMorphEqInput(CtxMorphEqInput), CtxMorphInput(CtxMorphInput), CtxMorphS(CtxMorphS), CtxS(CtxS), Extension(Extension), ExtensionInput(ExtensionInput), False(False), FalseInput(FalseInput), Id(Id), IdInput(IdInput), IdMorph(IdMorph), IdMorphInput(IdMorphInput), ProjCtx(ProjCtx), ProjCtxInput(ProjCtxInput), ProjTm(ProjTm), ProjTmInput(ProjTmInput), Refl(Refl), ReflInput(ReflInput), Tm(Tm), TmBar(TmBar), TmEq(TmEq), TmEqInput(TmEqInput), TmInput(TmInput), TmS(TmS), TmSubst(TmSubst), TmSubstInput(TmSubstInput), True(True), TrueInput(TrueInput), Ty(Ty), TyEq(TyEq), TyEqInput(TyEqInput), TyInput(TyInput), TyS(TyS), TySubst(TySubst), TySubstInput(TySubstInput), Weakening(Weakening));
/* fn log_log(module: & log_module_t, level: & log_log_level_t, msg: & String) -> bool */
/* fn std___builtin_2string<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_deref<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Ref<A>) -> A */
/* fn std_group2map<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(K, V)>) -> std_Map<K, V> */
/* fn std_group2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Set<A> */
/* fn std_group2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Vec<A> */
/* fn std_group_count<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> u64 */
/* fn std_group_first<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_nth<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>, n: & u64) -> std_Option<A> */
/* fn std_group_set_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Set<A>>) -> std_Set<A> */
/* fn std_group_setref_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Ref<std_Set<A>>>) -> std_Ref<std_Set<A>> */
/* fn std_group_sum<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_hash128<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u128 */
/* fn std_hash64<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u64 */
/* fn std_hex<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_htonl(x: & u32) -> u32 */
/* fn std_htons(x: & u16) -> u16 */
/* fn std_map_contains_key<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> bool */
/* fn std_map_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Map<K, V> */
/* fn std_map_get<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> std_Option<V> */
/* fn std_map_insert<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K, v: & V) -> () */
/* fn std_map_insert_imm<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_is_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>) -> bool */
/* fn std_map_remove<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K) -> () */
/* fn std_map_singleton<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_union<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m1: & std_Map<K, V>, m2: & std_Map<K, V>) -> std_Map<K, V> */
/* fn std_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A */
/* fn std_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A */
/* fn std_ntohl(x: & u32) -> u32 */
/* fn std_ntohs(x: & u16) -> u16 */
/* fn std_parse_dec_i64(s: & String) -> std_Option<i64> */
/* fn std_parse_dec_u64(s: & String) -> std_Option<u64> */
/* fn std_pow32<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(base: & A, exp: & u32) -> A */
/* fn std_range<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(from: & A, to: & A, step: & A) -> std_Vec<A> */
/* fn std_ref_new<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A) -> std_Ref<A> */
/* fn std_set2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<A>) -> std_Vec<A> */
/* fn std_set_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> bool */
/* fn std_set_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Set<X> */
/* fn std_set_insert<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: &mut std_Set<X>, v: & X) -> () */
/* fn std_set_insert_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> std_Set<X> */
/* fn std_set_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> bool */
/* fn std_set_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, n: & u64) -> std_Option<X> */
/* fn std_set_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Set<X> */
/* fn std_set_size<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> u64 */
/* fn std_set_union<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_unions<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(sets: & std_Vec<std_Set<X>>) -> std_Set<X> */
/* fn std_str_to_lower(s: & String) -> String */
/* fn std_string_contains(s1: & String, s2: & String) -> bool */
/* fn std_string_join(strings: & std_Vec<String>, sep: & String) -> String */
/* fn std_string_len(s: & String) -> u64 */
/* fn std_string_split(s: & String, sep: & String) -> std_Vec<String> */
/* fn std_string_substr(s: & String, start: & u64, end: & u64) -> String */
/* fn std_vec2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Vec<A>) -> std_Set<A> */
/* fn std_vec_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> bool */
/* fn std_vec_empty<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Vec<A> */
/* fn std_vec_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> bool */
/* fn std_vec_len<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> u64 */
/* fn std_vec_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, n: & u64) -> std_Option<X> */
/* fn std_vec_push<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: &mut std_Vec<X>, x: & X) -> () */
/* fn std_vec_push_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> std_Vec<X> */
/* fn std_vec_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Vec<X> */
fn std_group_unzip<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,Y: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(X, Y)>) -> (std_Vec<X>, std_Vec<Y>)
{   let ref mut xs : std_Vec<X> = std_vec_empty();
    let ref mut ys : std_Vec<Y> = std_vec_empty();
    for ref v in g.iter() {
        {
            let (ref mut x, ref mut y) = v.clone();
            std_vec_push(xs, x);
            std_vec_push(ys, y)
        }
    };
    (xs.clone(), ys.clone())
}
fn std_is_none<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_None{} => true,
        _ => false
    }
}
fn std_is_some<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_Some{x: _} => true,
        _ => false
    }
}
pub fn prog(__update_cb: Box<dyn CBFn<Value>>) -> Program<Value> {
    let BoolElimInput = Relation {
                            name:         "BoolElimInput".to_string(),
                            input:        true,
                            distinct:     false,
                            key_func:     None,
                            id:           Relations::BoolElimInput as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                ],
                            change_cb:    None
                        };
    let BoolInput = Relation {
                        name:         "BoolInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::BoolInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let CompInput = Relation {
                        name:         "CompInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::CompInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let ComprehensionInput = Relation {
                                 name:         "ComprehensionInput".to_string(),
                                 input:        true,
                                 distinct:     false,
                                 key_func:     None,
                                 id:           Relations::ComprehensionInput as RelId,
                                 rules:        vec![
                                     ],
                                 arrangements: vec![
                                     ],
                                 change_cb:    None
                             };
    let CtxEmptyInput = Relation {
                            name:         "CtxEmptyInput".to_string(),
                            input:        true,
                            distinct:     false,
                            key_func:     None,
                            id:           Relations::CtxEmptyInput as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                ],
                            change_cb:    None
                        };
    let CtxEqInput = Relation {
                         name:         "CtxEqInput".to_string(),
                         input:        true,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::CtxEqInput as RelId,
                         rules:        vec![
                             ],
                         arrangements: vec![
                             ],
                         change_cb:    None
                     };
    let CtxInput = Relation {
                       name:         "CtxInput".to_string(),
                       input:        true,
                       distinct:     false,
                       key_func:     None,
                       id:           Relations::CtxInput as RelId,
                       rules:        vec![
                           ],
                       arrangements: vec![
                           ],
                       change_cb:    None
                   };
    let CtxMorphEqInput = Relation {
                              name:         "CtxMorphEqInput".to_string(),
                              input:        true,
                              distinct:     false,
                              key_func:     None,
                              id:           Relations::CtxMorphEqInput as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  ],
                              change_cb:    None
                          };
    let CtxMorphInput = Relation {
                            name:         "CtxMorphInput".to_string(),
                            input:        true,
                            distinct:     false,
                            key_func:     None,
                            id:           Relations::CtxMorphInput as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                ],
                            change_cb:    None
                        };
    let ExtensionInput = Relation {
                             name:         "ExtensionInput".to_string(),
                             input:        true,
                             distinct:     false,
                             key_func:     None,
                             id:           Relations::ExtensionInput as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 ],
                             change_cb:    None
                         };
    let FalseInput = Relation {
                         name:         "FalseInput".to_string(),
                         input:        true,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::FalseInput as RelId,
                         rules:        vec![
                             ],
                         arrangements: vec![
                             ],
                         change_cb:    None
                     };
    let IdInput = Relation {
                      name:         "IdInput".to_string(),
                      input:        true,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::IdInput as RelId,
                      rules:        vec![
                          ],
                      arrangements: vec![
                          ],
                      change_cb:    None
                  };
    let IdMorphInput = Relation {
                           name:         "IdMorphInput".to_string(),
                           input:        true,
                           distinct:     false,
                           key_func:     None,
                           id:           Relations::IdMorphInput as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let ProjCtxInput = Relation {
                           name:         "ProjCtxInput".to_string(),
                           input:        true,
                           distinct:     false,
                           key_func:     None,
                           id:           Relations::ProjCtxInput as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let ProjTmInput = Relation {
                          name:         "ProjTmInput".to_string(),
                          input:        true,
                          distinct:     false,
                          key_func:     None,
                          id:           Relations::ProjTmInput as RelId,
                          rules:        vec![
                              ],
                          arrangements: vec![
                              ],
                          change_cb:    None
                      };
    let ReflInput = Relation {
                        name:         "ReflInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::ReflInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let TmEqInput = Relation {
                        name:         "TmEqInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::TmEqInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let TmInput = Relation {
                      name:         "TmInput".to_string(),
                      input:        true,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::TmInput as RelId,
                      rules:        vec![
                          ],
                      arrangements: vec![
                          ],
                      change_cb:    None
                  };
    let TmSubstInput = Relation {
                           name:         "TmSubstInput".to_string(),
                           input:        true,
                           distinct:     false,
                           key_func:     None,
                           id:           Relations::TmSubstInput as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let TrueInput = Relation {
                        name:         "TrueInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::TrueInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let TyEqInput = Relation {
                        name:         "TyEqInput".to_string(),
                        input:        true,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::TyEqInput as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let TyInput = Relation {
                      name:         "TyInput".to_string(),
                      input:        true,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::TyInput as RelId,
                      rules:        vec![
                          ],
                      arrangements: vec![
                          ],
                      change_cb:    None
                  };
    let TySubstInput = Relation {
                           name:         "TySubstInput".to_string(),
                           input:        true,
                           distinct:     false,
                           key_func:     None,
                           id:           Relations::TySubstInput as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let Bool = Relation {
                   name:         "Bool".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::Bool as RelId,
                   rules:        vec![
                       /* Bool(.ty=ty) :- BoolInput(.ty=ty). */
                       Rule::CollectionRule {
                           description: "Bool(.ty=ty) :- BoolInput(.ty=ty).".to_string(),
                           rel: Relations::BoolInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of Bool(.ty=ty) :- BoolInput(.ty=ty)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let ty = match __v{
                                                   Value::BoolInput(ref __box) => {
                                                       match *__box {
                                                       BoolInput{ty: ref ty} => ty,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::Bool(Bool{ty: ty.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* Bool(.ty=t) :- Bool(.ty=s), TyEq(.l=s, .r=t). */
                       Rule::ArrangementRule {
                           description: "Bool(.ty=t) :- Bool(.ty=s), TyEq(.l=s, .r=t).".to_string(),
                           arr: ( Relations::Bool as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Bool(.ty=s), TyEq(.l=s, .r=t)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TyEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let s = match *__v1{
                                              Value::Bool(ref __box) => {
                                                  match *__box {
                                                  Bool{ty: ref s} => s,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let t = match *__v2{
                                              Value::TyEq(ref __box) => {
                                                  match *__box {
                                                  TyEq{l: _, r: ref t} => t,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::Bool(Bool{ty: t.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* Bool(.ty=t) :- Bool(.ty=s), Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t). */
                       Rule::ArrangementRule {
                           description: "Bool(.ty=t) :- Bool(.ty=s), Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t).".to_string(),
                           arr: ( Relations::Bool as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Bool(.ty=s), Ty(.ty=s, .ctx=_D)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Ty as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let s = match *__v1{
                                              Value::Bool(ref __box) => {
                                                  match *__box {
                                                  Bool{ty: ref s} => s,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _D = match *__v2{
                                              Value::Ty(ref __box) => {
                                                  match *__box {
                                                  Ty{ty: _, ctx: ref _D} => _D,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple2__CtxS_TyS((_D.clone(), s.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange Bool(.ty=s), Ty(.ty=s, .ctx=_D) by (_D)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_D, s) = match __v {
                                                                      Value::tuple2__CtxS_TyS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _D, ref s) => (_D, s),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::CtxS(_D.clone()), Value::TyS(s.clone())))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "Bool(.ty=s), Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::CtxMorph as RelId,0),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let s = match *__v1 {
                                                                                         Value::TyS(ref __box) => {
                                                                                             match *__box {
                                                                                                 ref s => s,
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let (f, _G) = match *__v2{
                                                                                         Value::CtxMorph(ref __box) => {
                                                                                             match *__box {
                                                                                             CtxMorph{f: ref f, from: ref _G, to: _} => (f, _G),
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple2__CtxMorphS_TyS((f.clone(), s.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange Bool(.ty=s), Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D) by (s, f)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (f, s) = match __v {
                                                                                                                 Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref f, ref s) => (f, s),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::tuple2__TyS_CtxMorphS((s.clone(), f.clone())), Value::tuple0__(())))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "Bool(.ty=s), Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::TySubst as RelId,0),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let () = match *__v1 {
                                                                                                                                    Value::tuple0__(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            () => (),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let t = match *__v2{
                                                                                                                                    Value::TySubst(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        TySubst{ty: _, f: _, sub: ref t} => t,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::Bool(Bool{ty: t.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"Bool{.ty=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Bool(__box) = __v {
                                       match __box {
                                       Bool{ty: ref _0} => Some(Value::TyS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"_"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Bool(__box) = __v {
                                       match __box {
                                       _ => Some(Value::tuple0__(())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let CtxMorph = Relation {
                       name:         "CtxMorph".to_string(),
                       input:        false,
                       distinct:     false,
                       key_func:     None,
                       id:           Relations::CtxMorph as RelId,
                       rules:        vec![
                           /* CtxMorph(.f=f, .from=from, .to=to) :- CtxMorphInput(.f=f, .from=from, .to=to). */
                           Rule::CollectionRule {
                               description: "CtxMorph(.f=f, .from=from, .to=to) :- CtxMorphInput(.f=f, .from=from, .to=to).".to_string(),
                               rel: Relations::CtxMorphInput as RelId,
                               xform: Some(XFormCollection::FilterMap{
                                               description: "head of CtxMorph(.f=f, .from=from, .to=to) :- CtxMorphInput(.f=f, .from=from, .to=to)." .to_string(),
                                               fmfun: &{fn __f(__v: Value) -> Option<Value>
                                               {
                                                   let (f, from, to) = match __v{
                                                       Value::CtxMorphInput(ref __box) => {
                                                           match *__box {
                                                           CtxMorphInput{f: ref f, from: ref from, to: ref to} => (f, from, to),
                                                           _ => return None
                                                           }
                                                       },
                                                       _ => return None
                                                   };
                                                   Some(Value::CtxMorph(CtxMorph{f: f.clone(), from: from.clone(), to: to.clone()}))
                                               }
                                               __f},
                                               next: Box::new(None)
                                           })
                           },
                           /* CtxMorph(.f=g, .from=_A, .to=_B) :- CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g), CtxEq(.l=_G, .r=_A), CtxEq(.l=_D, .r=_B). */
                           Rule::ArrangementRule {
                               description: "CtxMorph(.f=g, .from=_A, .to=_B) :- CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g), CtxEq(.l=_G, .r=_A), CtxEq(.l=_D, .r=_B).".to_string(),
                               arr: ( Relations::CtxMorph as RelId, 3),
                               xform: XFormArrangement::Join{
                                          description: "CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::CtxMorphEq as RelId,0),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let (f, _G, _D) = match *__v1{
                                                  Value::CtxMorph(ref __box) => {
                                                      match *__box {
                                                      CtxMorph{f: ref f, from: ref _G, to: ref _D} => (f, _G, _D),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let g = match *__v2{
                                                  Value::CtxMorphEq(ref __box) => {
                                                      match *__box {
                                                      CtxMorphEq{l: _, r: ref g} => g,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::tuple3__CtxS_CtxS_CtxMorphS((_D.clone(), _G.clone(), g.clone())))
                                          }
                                          __f},
                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                  description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g) by (_G)" .to_string(),
                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                  {
                                                                      let (_D, _G, g) = match __v {
                                                                          Value::tuple3__CtxS_CtxS_CtxMorphS(ref __box) => {
                                                                              match *__box {
                                                                                  (ref _D, ref _G, ref g) => (_D, _G, g),
                                                                                  _ => unreachable!(),
                                                                              }
                                                                          },
                                                                          _ => unreachable!()
                                                                      };
                                                                      Some((Value::CtxS(_G.clone()), Value::tuple2__CtxS_CtxMorphS((_D.clone(), g.clone()))))
                                                                  }
                                                                  __f},
                                                                  next: Box::new(XFormArrangement::Join{
                                                                                     description: "CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g), CtxEq(.l=_G, .r=_A)".to_string(),
                                                                                     ffun: None,
                                                                                     arrangement: (Relations::CtxEq as RelId,0),
                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                     {
                                                                                         let (_D, g) = match *__v1 {
                                                                                             Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                                 match *__box {
                                                                                                     (ref _D, ref g) => (_D, g),
                                                                                                     _ => unreachable!(),
                                                                                                 }
                                                                                             },
                                                                                             _ => unreachable!()
                                                                                         };
                                                                                         let _A = match *__v2{
                                                                                             Value::CtxEq(ref __box) => {
                                                                                                 match *__box {
                                                                                                 CtxEq{l: _, r: ref _A} => _A,
                                                                                                 _ => return None
                                                                                                 }
                                                                                             },
                                                                                             _ => return None
                                                                                         };
                                                                                         Some(Value::tuple3__CtxS_CtxS_CtxMorphS((_A.clone(), _D.clone(), g.clone())))
                                                                                     }
                                                                                     __f},
                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                             description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g), CtxEq(.l=_G, .r=_A) by (_D)" .to_string(),
                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                             {
                                                                                                                 let (_A, _D, g) = match __v {
                                                                                                                     Value::tuple3__CtxS_CtxS_CtxMorphS(ref __box) => {
                                                                                                                         match *__box {
                                                                                                                             (ref _A, ref _D, ref g) => (_A, _D, g),
                                                                                                                             _ => unreachable!(),
                                                                                                                         }
                                                                                                                     },
                                                                                                                     _ => unreachable!()
                                                                                                                 };
                                                                                                                 Some((Value::CtxS(_D.clone()), Value::tuple2__CtxS_CtxMorphS((_A.clone(), g.clone()))))
                                                                                                             }
                                                                                                             __f},
                                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                                description: "CtxMorph(.f=f, .from=_G, .to=_D), CtxMorphEq(.l=f, .r=g), CtxEq(.l=_G, .r=_A), CtxEq(.l=_D, .r=_B)".to_string(),
                                                                                                                                ffun: None,
                                                                                                                                arrangement: (Relations::CtxEq as RelId,0),
                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                {
                                                                                                                                    let (_A, g) = match *__v1 {
                                                                                                                                        Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                                (ref _A, ref g) => (_A, g),
                                                                                                                                                _ => unreachable!(),
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => unreachable!()
                                                                                                                                    };
                                                                                                                                    let _B = match *__v2{
                                                                                                                                        Value::CtxEq(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                            CtxEq{l: _, r: ref _B} => _B,
                                                                                                                                            _ => return None
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => return None
                                                                                                                                    };
                                                                                                                                    Some(Value::CtxMorph(CtxMorph{f: g.clone(), from: _A.clone(), to: _B.clone()}))
                                                                                                                                }
                                                                                                                                __f},
                                                                                                                                next: Box::new(None)
                                                                                                                            })
                                                                                                         }))
                                                                                 })
                                                              }))
                                      }
                           }],
                       arrangements: vec![
                           Arrangement::Map{
                              name: r###"CtxMorph{.f=_, .from=_, .to=_0}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: _, from: _, to: ref _0} => Some(Value::CtxS(_0.clone())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"_"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           _ => Some(Value::tuple0__(())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"CtxMorph{.f=_, .from=_0, .to=_}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: _, from: ref _0, to: _} => Some(Value::CtxS(_0.clone())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"CtxMorph{.f=_0, .from=_, .to=_}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: ref _0, from: _, to: _} => Some(Value::CtxMorphS(_0.clone())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"CtxMorph{.f=_0, .from=_, .to=_1}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: ref _0, from: _, to: ref _1} => Some(Value::tuple2__CtxMorphS_CtxS((_0.clone(), _1.clone()))),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Set{
                               name: r###"CtxMorph{.f=_0, .from=_1, .to=_}"###.to_string(),
                               fmfun: &{fn __f(__v: Value) -> Option<Value>
                               {
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: ref _0, from: ref _1, to: _} => Some(Value::tuple2__CtxMorphS_CtxS((_0.clone(), _1.clone()))),
                                           _ => None
                                           }
                                       } else { None }
                                   }
                               }
                               __f},
                               distinct: false
                           },
                           Arrangement::Map{
                              name: r###"CtxMorph{.f=_, .from=_0, .to=_1}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: _, from: ref _0, to: ref _1} => Some(Value::tuple2__CtxS_CtxS((_0.clone(), _1.clone()))),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Set{
                               name: r###"CtxMorph{.f=_0, .from=_1, .to=_2}"###.to_string(),
                               fmfun: &{fn __f(__v: Value) -> Option<Value>
                               {
                                   {
                                       if let Value::CtxMorph(__box) = __v {
                                           match __box {
                                           CtxMorph{f: ref _0, from: ref _1, to: ref _2} => Some(Value::tuple3__CtxMorphS_CtxS_CtxS((_0.clone(), _1.clone(), _2.clone()))),
                                           _ => None
                                           }
                                       } else { None }
                                   }
                               }
                               __f},
                               distinct: false
                           }],
                       change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                   };
    let CtxEq = Relation {
                    name:         "CtxEq".to_string(),
                    input:        false,
                    distinct:     false,
                    key_func:     None,
                    id:           Relations::CtxEq as RelId,
                    rules:        vec![
                        /* CtxEq(.l=l, .r=r) :- CtxEqInput(.l=l, .r=r). */
                        Rule::CollectionRule {
                            description: "CtxEq(.l=l, .r=r) :- CtxEqInput(.l=l, .r=r).".to_string(),
                            rel: Relations::CtxEqInput as RelId,
                            xform: Some(XFormCollection::FilterMap{
                                            description: "head of CtxEq(.l=l, .r=r) :- CtxEqInput(.l=l, .r=r)." .to_string(),
                                            fmfun: &{fn __f(__v: Value) -> Option<Value>
                                            {
                                                let (l, r) = match __v{
                                                    Value::CtxEqInput(ref __box) => {
                                                        match *__box {
                                                        CtxEqInput{l: ref l, r: ref r} => (l, r),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxEq(CtxEq{l: l.clone(), r: r.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        })
                        },
                        /* CtxEq(.l=ctx, .r=ctx) :- Ctx(.ctx=ctx). */
                        Rule::CollectionRule {
                            description: "CtxEq(.l=ctx, .r=ctx) :- Ctx(.ctx=ctx).".to_string(),
                            rel: Relations::Ctx as RelId,
                            xform: Some(XFormCollection::FilterMap{
                                            description: "head of CtxEq(.l=ctx, .r=ctx) :- Ctx(.ctx=ctx)." .to_string(),
                                            fmfun: &{fn __f(__v: Value) -> Option<Value>
                                            {
                                                let ctx = match __v{
                                                    Value::Ctx(ref __box) => {
                                                        match *__box {
                                                        Ctx{ctx: ref ctx} => ctx,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxEq(CtxEq{l: ctx.clone(), r: ctx.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        })
                        },
                        /* CtxEq(.l=l, .r=r) :- CtxEq(.l=r, .r=l). */
                        Rule::CollectionRule {
                            description: "CtxEq(.l=l, .r=r) :- CtxEq(.l=r, .r=l).".to_string(),
                            rel: Relations::CtxEq as RelId,
                            xform: Some(XFormCollection::FilterMap{
                                            description: "head of CtxEq(.l=l, .r=r) :- CtxEq(.l=r, .r=l)." .to_string(),
                                            fmfun: &{fn __f(__v: Value) -> Option<Value>
                                            {
                                                let (r, l) = match __v{
                                                    Value::CtxEq(ref __box) => {
                                                        match *__box {
                                                        CtxEq{l: ref r, r: ref l} => (r, l),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxEq(CtxEq{l: l.clone(), r: r.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        })
                        },
                        /* CtxEq(.l=a, .r=c) :- CtxEq(.l=a, .r=b), CtxEq(.l=b, .r=c). */
                        Rule::ArrangementRule {
                            description: "CtxEq(.l=a, .r=c) :- CtxEq(.l=a, .r=b), CtxEq(.l=b, .r=c).".to_string(),
                            arr: ( Relations::CtxEq as RelId, 1),
                            xform: XFormArrangement::Join{
                                       description: "CtxEq(.l=a, .r=b), CtxEq(.l=b, .r=c)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::CtxEq as RelId,0),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let (a, b) = match *__v1{
                                               Value::CtxEq(ref __box) => {
                                                   match *__box {
                                                   CtxEq{l: ref a, r: ref b} => (a, b),
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let c = match *__v2{
                                               Value::CtxEq(ref __box) => {
                                                   match *__box {
                                                   CtxEq{l: _, r: ref c} => c,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::CtxEq(CtxEq{l: a.clone(), r: c.clone()}))
                                       }
                                       __f},
                                       next: Box::new(None)
                                   }
                        },
                        /* CtxEq(.l=_G, .r=_D) :- CtxEmpty(.ctx=_G), CtxEmpty(.ctx=_D). */
                        Rule::ArrangementRule {
                            description: "CtxEq(.l=_G, .r=_D) :- CtxEmpty(.ctx=_G), CtxEmpty(.ctx=_D).".to_string(),
                            arr: ( Relations::CtxEmpty as RelId, 1),
                            xform: XFormArrangement::Join{
                                       description: "CtxEmpty(.ctx=_G), CtxEmpty(.ctx=_D)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::CtxEmpty as RelId,1),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let _G = match *__v1{
                                               Value::CtxEmpty(ref __box) => {
                                                   match *__box {
                                                   CtxEmpty{ctx: ref _G} => _G,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let _D = match *__v2{
                                               Value::CtxEmpty(ref __box) => {
                                                   match *__box {
                                                   CtxEmpty{ctx: ref _D} => _D,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::CtxEq(CtxEq{l: _G.clone(), r: _D.clone()}))
                                       }
                                       __f},
                                       next: Box::new(None)
                                   }
                        },
                        /* CtxEq(.l=_D, .r=_A) :- Comprehension(.without=_G, .ty=s, .with=_D), Comprehension(.without=_G, .ty=s, .with=_A). */
                        Rule::ArrangementRule {
                            description: "CtxEq(.l=_D, .r=_A) :- Comprehension(.without=_G, .ty=s, .with=_D), Comprehension(.without=_G, .ty=s, .with=_A).".to_string(),
                            arr: ( Relations::Comprehension as RelId, 1),
                            xform: XFormArrangement::Join{
                                       description: "Comprehension(.without=_G, .ty=s, .with=_D), Comprehension(.without=_G, .ty=s, .with=_A)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::Comprehension as RelId,1),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let (_G, s, _D) = match *__v1{
                                               Value::Comprehension(ref __box) => {
                                                   match *__box {
                                                   Comprehension{without: ref _G, ty: ref s, with: ref _D} => (_G, s, _D),
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let _A = match *__v2{
                                               Value::Comprehension(ref __box) => {
                                                   match *__box {
                                                   Comprehension{without: _, ty: _, with: ref _A} => _A,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::CtxEq(CtxEq{l: _D.clone(), r: _A.clone()}))
                                       }
                                       __f},
                                       next: Box::new(None)
                                   }
                        }],
                    arrangements: vec![
                        Arrangement::Map{
                           name: r###"CtxEq{.l=_0, .r=_}"###.to_string(),
                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                            {
                                let __cloned = __v.clone();
                                {
                                    if let Value::CtxEq(__box) = __v {
                                        match __box {
                                        CtxEq{l: ref _0, r: _} => Some(Value::CtxS(_0.clone())),
                                        _ => None
                                        }
                                    } else { None }
                                }.map(|x|(x,__cloned))
                            }
                            __f},
                            queryable: false
                        },
                        Arrangement::Map{
                           name: r###"CtxEq{.l=_, .r=_0}"###.to_string(),
                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                            {
                                let __cloned = __v.clone();
                                {
                                    if let Value::CtxEq(__box) = __v {
                                        match __box {
                                        CtxEq{l: _, r: ref _0} => Some(Value::CtxS(_0.clone())),
                                        _ => None
                                        }
                                    } else { None }
                                }.map(|x|(x,__cloned))
                            }
                            __f},
                            queryable: false
                        }],
                    change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                };
    let Comprehension = Relation {
                            name:         "Comprehension".to_string(),
                            input:        false,
                            distinct:     false,
                            key_func:     None,
                            id:           Relations::Comprehension as RelId,
                            rules:        vec![
                                /* Comprehension(.without=without, .ty=ty, .with=with) :- ComprehensionInput(.without=without, .ty=ty, .with=with). */
                                Rule::CollectionRule {
                                    description: "Comprehension(.without=without, .ty=ty, .with=with) :- ComprehensionInput(.without=without, .ty=ty, .with=with).".to_string(),
                                    rel: Relations::ComprehensionInput as RelId,
                                    xform: Some(XFormCollection::FilterMap{
                                                    description: "head of Comprehension(.without=without, .ty=ty, .with=with) :- ComprehensionInput(.without=without, .ty=ty, .with=with)." .to_string(),
                                                    fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                    {
                                                        let (without, ty, with) = match __v{
                                                            Value::ComprehensionInput(ref __box) => {
                                                                match *__box {
                                                                ComprehensionInput{without: ref without, ty: ref ty, with: ref with} => (without, ty, with),
                                                                _ => return None
                                                                }
                                                            },
                                                            _ => return None
                                                        };
                                                        Some(Value::Comprehension(Comprehension{without: without.clone(), ty: ty.clone(), with: with.clone()}))
                                                    }
                                                    __f},
                                                    next: Box::new(None)
                                                })
                                },
                                /* Comprehension(.without=_D, .ty=t, .with=_B) :- Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxEq(.l=_A, .r=_B). */
                                Rule::ArrangementRule {
                                    description: "Comprehension(.without=_D, .ty=t, .with=_B) :- Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxEq(.l=_A, .r=_B).".to_string(),
                                    arr: ( Relations::Comprehension as RelId, 0),
                                    xform: XFormArrangement::Join{
                                               description: "Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D)".to_string(),
                                               ffun: None,
                                               arrangement: (Relations::CtxEq as RelId,0),
                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                               {
                                                   let (_G, s, _A) = match *__v1{
                                                       Value::Comprehension(ref __box) => {
                                                           match *__box {
                                                           Comprehension{without: ref _G, ty: ref s, with: ref _A} => (_G, s, _A),
                                                           _ => return None
                                                           }
                                                       },
                                                       _ => return None
                                                   };
                                                   let _D = match *__v2{
                                                       Value::CtxEq(ref __box) => {
                                                           match *__box {
                                                           CtxEq{l: _, r: ref _D} => _D,
                                                           _ => return None
                                                           }
                                                       },
                                                       _ => return None
                                                   };
                                                   Some(Value::tuple3__CtxS_CtxS_TyS((_A.clone(), _D.clone(), s.clone())))
                                               }
                                               __f},
                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                       description: "arrange Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D) by (s)" .to_string(),
                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                       {
                                                                           let (_A, _D, s) = match __v {
                                                                               Value::tuple3__CtxS_CtxS_TyS(ref __box) => {
                                                                                   match *__box {
                                                                                       (ref _A, ref _D, ref s) => (_A, _D, s),
                                                                                       _ => unreachable!(),
                                                                                   }
                                                                               },
                                                                               _ => unreachable!()
                                                                           };
                                                                           Some((Value::TyS(s.clone()), Value::tuple2__CtxS_CtxS((_A.clone(), _D.clone()))))
                                                                       }
                                                                       __f},
                                                                       next: Box::new(XFormArrangement::Join{
                                                                                          description: "Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t)".to_string(),
                                                                                          ffun: None,
                                                                                          arrangement: (Relations::TyEq as RelId,0),
                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                          {
                                                                                              let (_A, _D) = match *__v1 {
                                                                                                  Value::tuple2__CtxS_CtxS(ref __box) => {
                                                                                                      match *__box {
                                                                                                          (ref _A, ref _D) => (_A, _D),
                                                                                                          _ => unreachable!(),
                                                                                                      }
                                                                                                  },
                                                                                                  _ => unreachable!()
                                                                                              };
                                                                                              let t = match *__v2{
                                                                                                  Value::TyEq(ref __box) => {
                                                                                                      match *__box {
                                                                                                      TyEq{l: _, r: ref t} => t,
                                                                                                      _ => return None
                                                                                                      }
                                                                                                  },
                                                                                                  _ => return None
                                                                                              };
                                                                                              Some(Value::tuple3__CtxS_CtxS_TyS((_A.clone(), _D.clone(), t.clone())))
                                                                                          }
                                                                                          __f},
                                                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                  description: "arrange Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t) by (_A)" .to_string(),
                                                                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                  {
                                                                                                                      let (_A, _D, t) = match __v {
                                                                                                                          Value::tuple3__CtxS_CtxS_TyS(ref __box) => {
                                                                                                                              match *__box {
                                                                                                                                  (ref _A, ref _D, ref t) => (_A, _D, t),
                                                                                                                                  _ => unreachable!(),
                                                                                                                              }
                                                                                                                          },
                                                                                                                          _ => unreachable!()
                                                                                                                      };
                                                                                                                      Some((Value::CtxS(_A.clone()), Value::tuple2__CtxS_TyS((_D.clone(), t.clone()))))
                                                                                                                  }
                                                                                                                  __f},
                                                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                                                     description: "Comprehension(.without=_G, .ty=s, .with=_A), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxEq(.l=_A, .r=_B)".to_string(),
                                                                                                                                     ffun: None,
                                                                                                                                     arrangement: (Relations::CtxEq as RelId,0),
                                                                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                     {
                                                                                                                                         let (_D, t) = match *__v1 {
                                                                                                                                             Value::tuple2__CtxS_TyS(ref __box) => {
                                                                                                                                                 match *__box {
                                                                                                                                                     (ref _D, ref t) => (_D, t),
                                                                                                                                                     _ => unreachable!(),
                                                                                                                                                 }
                                                                                                                                             },
                                                                                                                                             _ => unreachable!()
                                                                                                                                         };
                                                                                                                                         let _B = match *__v2{
                                                                                                                                             Value::CtxEq(ref __box) => {
                                                                                                                                                 match *__box {
                                                                                                                                                 CtxEq{l: _, r: ref _B} => _B,
                                                                                                                                                 _ => return None
                                                                                                                                                 }
                                                                                                                                             },
                                                                                                                                             _ => return None
                                                                                                                                         };
                                                                                                                                         Some(Value::Comprehension(Comprehension{without: _D.clone(), ty: t.clone(), with: _B.clone()}))
                                                                                                                                     }
                                                                                                                                     __f},
                                                                                                                                     next: Box::new(None)
                                                                                                                                 })
                                                                                                              }))
                                                                                      })
                                                                   }))
                                           }
                                }],
                            arrangements: vec![
                                Arrangement::Map{
                                   name: r###"Comprehension{.without=_0, .ty=_, .with=_}"###.to_string(),
                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                    {
                                        let __cloned = __v.clone();
                                        {
                                            if let Value::Comprehension(__box) = __v {
                                                match __box {
                                                Comprehension{without: ref _0, ty: _, with: _} => Some(Value::CtxS(_0.clone())),
                                                _ => None
                                                }
                                            } else { None }
                                        }.map(|x|(x,__cloned))
                                    }
                                    __f},
                                    queryable: false
                                },
                                Arrangement::Map{
                                   name: r###"Comprehension{.without=_0, .ty=_1, .with=_}"###.to_string(),
                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                    {
                                        let __cloned = __v.clone();
                                        {
                                            if let Value::Comprehension(__box) = __v {
                                                match __box {
                                                Comprehension{without: ref _0, ty: ref _1, with: _} => Some(Value::tuple2__CtxS_TyS((_0.clone(), _1.clone()))),
                                                _ => None
                                                }
                                            } else { None }
                                        }.map(|x|(x,__cloned))
                                    }
                                    __f},
                                    queryable: false
                                }],
                            change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                        };
    let TyEq = Relation {
                   name:         "TyEq".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::TyEq as RelId,
                   rules:        vec![
                       /* TyEq(.l=l, .r=r) :- TyEqInput(.l=l, .r=r). */
                       Rule::CollectionRule {
                           description: "TyEq(.l=l, .r=r) :- TyEqInput(.l=l, .r=r).".to_string(),
                           rel: Relations::TyEqInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TyEq(.l=l, .r=r) :- TyEqInput(.l=l, .r=r)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let (l, r) = match __v{
                                                   Value::TyEqInput(ref __box) => {
                                                       match *__box {
                                                       TyEqInput{l: ref l, r: ref r} => (l, r),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TyEq(TyEq{l: l.clone(), r: r.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TyEq(.l=ty, .r=ty) :- Ty(.ty=ty, .ctx=_). */
                       Rule::CollectionRule {
                           description: "TyEq(.l=ty, .r=ty) :- Ty(.ty=ty, .ctx=_).".to_string(),
                           rel: Relations::Ty as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TyEq(.l=ty, .r=ty) :- Ty(.ty=ty, .ctx=_)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let ty = match __v{
                                                   Value::Ty(ref __box) => {
                                                       match *__box {
                                                       Ty{ty: ref ty, ctx: _} => ty,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TyEq(TyEq{l: ty.clone(), r: ty.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TyEq(.l=l, .r=r) :- TyEq(.l=r, .r=l). */
                       Rule::CollectionRule {
                           description: "TyEq(.l=l, .r=r) :- TyEq(.l=r, .r=l).".to_string(),
                           rel: Relations::TyEq as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TyEq(.l=l, .r=r) :- TyEq(.l=r, .r=l)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let (r, l) = match __v{
                                                   Value::TyEq(ref __box) => {
                                                       match *__box {
                                                       TyEq{l: ref r, r: ref l} => (r, l),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TyEq(TyEq{l: l.clone(), r: r.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TyEq(.l=a, .r=c) :- TyEq(.l=a, .r=b), TyEq(.l=b, .r=c). */
                       Rule::ArrangementRule {
                           description: "TyEq(.l=a, .r=c) :- TyEq(.l=a, .r=b), TyEq(.l=b, .r=c).".to_string(),
                           arr: ( Relations::TyEq as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "TyEq(.l=a, .r=b), TyEq(.l=b, .r=c)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TyEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (a, b) = match *__v1{
                                              Value::TyEq(ref __box) => {
                                                  match *__box {
                                                  TyEq{l: ref a, r: ref b} => (a, b),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let c = match *__v2{
                                              Value::TyEq(ref __box) => {
                                                  match *__box {
                                                  TyEq{l: _, r: ref c} => c,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TyEq(TyEq{l: a.clone(), r: c.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TyEq(.l=t, .r=u) :- TySubst(.ty=s, .f=f, .sub=t), TySubst(.ty=s, .f=f, .sub=u). */
                       Rule::ArrangementRule {
                           description: "TyEq(.l=t, .r=u) :- TySubst(.ty=s, .f=f, .sub=t), TySubst(.ty=s, .f=f, .sub=u).".to_string(),
                           arr: ( Relations::TySubst as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "TySubst(.ty=s, .f=f, .sub=t), TySubst(.ty=s, .f=f, .sub=u)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TySubst as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (s, f, t) = match *__v1{
                                              Value::TySubst(ref __box) => {
                                                  match *__box {
                                                  TySubst{ty: ref s, f: ref f, sub: ref t} => (s, f, t),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let u = match *__v2{
                                              Value::TySubst(ref __box) => {
                                                  match *__box {
                                                  TySubst{ty: _, f: _, sub: ref u} => u,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TyEq(TyEq{l: t.clone(), r: u.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TyEq(.l=s, .r=t) :- Id(.left=_M, .right=_N, .ty=s), Id(.left=_M, .right=_N, .ty=t). */
                       Rule::ArrangementRule {
                           description: "TyEq(.l=s, .r=t) :- Id(.left=_M, .right=_N, .ty=s), Id(.left=_M, .right=_N, .ty=t).".to_string(),
                           arr: ( Relations::Id as RelId, 2),
                           xform: XFormArrangement::Join{
                                      description: "Id(.left=_M, .right=_N, .ty=s), Id(.left=_M, .right=_N, .ty=t)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Id as RelId,2),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, _N, s) = match *__v1{
                                              Value::Id(ref __box) => {
                                                  match *__box {
                                                  Id{left: ref _M, right: ref _N, ty: ref s} => (_M, _N, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let t = match *__v2{
                                              Value::Id(ref __box) => {
                                                  match *__box {
                                                  Id{left: _, right: _, ty: ref t} => t,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TyEq(TyEq{l: s.clone(), r: t.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TyEq(.l=s, .r=t) :- __Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_G). */
                       Rule::ArrangementRule {
                           description: "TyEq(.l=s, .r=t) :- __Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_G).".to_string(),
                           arr: ( Relations::__Prefix_2 as RelId, 0),
                           xform: XFormArrangement::Semijoin{
                                      description: "__Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_G)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Ty as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                      {
                                          let (_G, s, t) = match *__v1{
                                              Value::tuple3__CtxS_TyS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _G, ref s, ref t) => (_G, s, t),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TyEq(TyEq{l: s.clone(), r: t.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"TyEq{.l=_0, .r=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::TyEq(__box) = __v {
                                       match __box {
                                       TyEq{l: ref _0, r: _} => Some(Value::TyS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"TyEq{.l=_, .r=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::TyEq(__box) = __v {
                                       match __box {
                                       TyEq{l: _, r: ref _0} => Some(Value::TyS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let Id = Relation {
                 name:         "Id".to_string(),
                 input:        false,
                 distinct:     false,
                 key_func:     None,
                 id:           Relations::Id as RelId,
                 rules:        vec![
                     /* Id(.left=left, .right=right, .ty=ty) :- IdInput(.left=left, .right=right, .ty=ty). */
                     Rule::CollectionRule {
                         description: "Id(.left=left, .right=right, .ty=ty) :- IdInput(.left=left, .right=right, .ty=ty).".to_string(),
                         rel: Relations::IdInput as RelId,
                         xform: Some(XFormCollection::FilterMap{
                                         description: "head of Id(.left=left, .right=right, .ty=ty) :- IdInput(.left=left, .right=right, .ty=ty)." .to_string(),
                                         fmfun: &{fn __f(__v: Value) -> Option<Value>
                                         {
                                             let (left, right, ty) = match __v{
                                                 Value::IdInput(ref __box) => {
                                                     match *__box {
                                                     IdInput{left: ref left, right: ref right, ty: ref ty} => (left, right, ty),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::Id(Id{left: left.clone(), right: right.clone(), ty: ty.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     })
                     },
                     /* Id(.left=_O, .right=_P, .ty=t) :- Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O), TmEq(.l=_N, .r=_P), TyEq(.l=s, .r=t). */
                     Rule::ArrangementRule {
                         description: "Id(.left=_O, .right=_P, .ty=t) :- Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O), TmEq(.l=_N, .r=_P), TyEq(.l=s, .r=t).".to_string(),
                         arr: ( Relations::Id as RelId, 0),
                         xform: XFormArrangement::Join{
                                    description: "Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O)".to_string(),
                                    ffun: None,
                                    arrangement: (Relations::TmEq as RelId,0),
                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                    {
                                        let (_M, _N, s) = match *__v1{
                                            Value::Id(ref __box) => {
                                                match *__box {
                                                Id{left: ref _M, right: ref _N, ty: ref s} => (_M, _N, s),
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        let _O = match *__v2{
                                            Value::TmEq(ref __box) => {
                                                match *__box {
                                                TmEq{l: _, r: ref _O} => _O,
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        Some(Value::tuple3__TmS_TmS_TyS((_N.clone(), _O.clone(), s.clone())))
                                    }
                                    __f},
                                    next: Box::new(Some(XFormCollection::Arrange {
                                                            description: "arrange Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O) by (_N)" .to_string(),
                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                            {
                                                                let (_N, _O, s) = match __v {
                                                                    Value::tuple3__TmS_TmS_TyS(ref __box) => {
                                                                        match *__box {
                                                                            (ref _N, ref _O, ref s) => (_N, _O, s),
                                                                            _ => unreachable!(),
                                                                        }
                                                                    },
                                                                    _ => unreachable!()
                                                                };
                                                                Some((Value::TmS(_N.clone()), Value::tuple2__TmS_TyS((_O.clone(), s.clone()))))
                                                            }
                                                            __f},
                                                            next: Box::new(XFormArrangement::Join{
                                                                               description: "Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O), TmEq(.l=_N, .r=_P)".to_string(),
                                                                               ffun: None,
                                                                               arrangement: (Relations::TmEq as RelId,0),
                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                               {
                                                                                   let (_O, s) = match *__v1 {
                                                                                       Value::tuple2__TmS_TyS(ref __box) => {
                                                                                           match *__box {
                                                                                               (ref _O, ref s) => (_O, s),
                                                                                               _ => unreachable!(),
                                                                                           }
                                                                                       },
                                                                                       _ => unreachable!()
                                                                                   };
                                                                                   let _P = match *__v2{
                                                                                       Value::TmEq(ref __box) => {
                                                                                           match *__box {
                                                                                           TmEq{l: _, r: ref _P} => _P,
                                                                                           _ => return None
                                                                                           }
                                                                                       },
                                                                                       _ => return None
                                                                                   };
                                                                                   Some(Value::tuple3__TmS_TmS_TyS((_O.clone(), _P.clone(), s.clone())))
                                                                               }
                                                                               __f},
                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                       description: "arrange Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O), TmEq(.l=_N, .r=_P) by (s)" .to_string(),
                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                       {
                                                                                                           let (_O, _P, s) = match __v {
                                                                                                               Value::tuple3__TmS_TmS_TyS(ref __box) => {
                                                                                                                   match *__box {
                                                                                                                       (ref _O, ref _P, ref s) => (_O, _P, s),
                                                                                                                       _ => unreachable!(),
                                                                                                                   }
                                                                                                               },
                                                                                                               _ => unreachable!()
                                                                                                           };
                                                                                                           Some((Value::TyS(s.clone()), Value::tuple2__TmS_TmS((_O.clone(), _P.clone()))))
                                                                                                       }
                                                                                                       __f},
                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                          description: "Id(.left=_M, .right=_N, .ty=s), TmEq(.l=_M, .r=_O), TmEq(.l=_N, .r=_P), TyEq(.l=s, .r=t)".to_string(),
                                                                                                                          ffun: None,
                                                                                                                          arrangement: (Relations::TyEq as RelId,0),
                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                          {
                                                                                                                              let (_O, _P) = match *__v1 {
                                                                                                                                  Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                      match *__box {
                                                                                                                                          (ref _O, ref _P) => (_O, _P),
                                                                                                                                          _ => unreachable!(),
                                                                                                                                      }
                                                                                                                                  },
                                                                                                                                  _ => unreachable!()
                                                                                                                              };
                                                                                                                              let t = match *__v2{
                                                                                                                                  Value::TyEq(ref __box) => {
                                                                                                                                      match *__box {
                                                                                                                                      TyEq{l: _, r: ref t} => t,
                                                                                                                                      _ => return None
                                                                                                                                      }
                                                                                                                                  },
                                                                                                                                  _ => return None
                                                                                                                              };
                                                                                                                              Some(Value::Id(Id{left: _O.clone(), right: _P.clone(), ty: t.clone()}))
                                                                                                                          }
                                                                                                                          __f},
                                                                                                                          next: Box::new(None)
                                                                                                                      })
                                                                                                   }))
                                                                           })
                                                        }))
                                }
                     },
                     /* Id(.left=_Q, .right=_R, .ty=t) :- Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R). */
                     Rule::ArrangementRule {
                         description: "Id(.left=_Q, .right=_R, .ty=t) :- Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R).".to_string(),
                         arr: ( Relations::Id as RelId, 1),
                         xform: XFormArrangement::Join{
                                    description: "Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t)".to_string(),
                                    ffun: None,
                                    arrangement: (Relations::TySubst as RelId,1),
                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                    {
                                        let (_M, _N, s) = match *__v1{
                                            Value::Id(ref __box) => {
                                                match *__box {
                                                Id{left: ref _M, right: ref _N, ty: ref s} => (_M, _N, s),
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        let (f, t) = match *__v2{
                                            Value::TySubst(ref __box) => {
                                                match *__box {
                                                TySubst{ty: _, f: ref f, sub: ref t} => (f, t),
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        Some(Value::tuple4__TmS_TmS_CtxMorphS_TyS((_M.clone(), _N.clone(), f.clone(), t.clone())))
                                    }
                                    __f},
                                    next: Box::new(Some(XFormCollection::Arrange {
                                                            description: "arrange Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t) by (_M, f)" .to_string(),
                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                            {
                                                                let (_M, _N, f, t) = match __v {
                                                                    Value::tuple4__TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                        match *__box {
                                                                            (ref _M, ref _N, ref f, ref t) => (_M, _N, f, t),
                                                                            _ => unreachable!(),
                                                                        }
                                                                    },
                                                                    _ => unreachable!()
                                                                };
                                                                Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple3__TmS_CtxMorphS_TyS((_N.clone(), f.clone(), t.clone()))))
                                                            }
                                                            __f},
                                                            next: Box::new(XFormArrangement::Join{
                                                                               description: "Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t), TmSubst(.tm=_M, .f=f, .sub=_Q)".to_string(),
                                                                               ffun: None,
                                                                               arrangement: (Relations::TmSubst as RelId,2),
                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                               {
                                                                                   let (_N, f, t) = match *__v1 {
                                                                                       Value::tuple3__TmS_CtxMorphS_TyS(ref __box) => {
                                                                                           match *__box {
                                                                                               (ref _N, ref f, ref t) => (_N, f, t),
                                                                                               _ => unreachable!(),
                                                                                           }
                                                                                       },
                                                                                       _ => unreachable!()
                                                                                   };
                                                                                   let _Q = match *__v2{
                                                                                       Value::TmSubst(ref __box) => {
                                                                                           match *__box {
                                                                                           TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                                                           _ => return None
                                                                                           }
                                                                                       },
                                                                                       _ => return None
                                                                                   };
                                                                                   Some(Value::tuple4__TmS_TmS_CtxMorphS_TyS((_N.clone(), _Q.clone(), f.clone(), t.clone())))
                                                                               }
                                                                               __f},
                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                       description: "arrange Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t), TmSubst(.tm=_M, .f=f, .sub=_Q) by (_N, f)" .to_string(),
                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                       {
                                                                                                           let (_N, _Q, f, t) = match __v {
                                                                                                               Value::tuple4__TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                   match *__box {
                                                                                                                       (ref _N, ref _Q, ref f, ref t) => (_N, _Q, f, t),
                                                                                                                       _ => unreachable!(),
                                                                                                                   }
                                                                                                               },
                                                                                                               _ => unreachable!()
                                                                                                           };
                                                                                                           Some((Value::tuple2__TmS_CtxMorphS((_N.clone(), f.clone())), Value::tuple2__TmS_TyS((_Q.clone(), t.clone()))))
                                                                                                       }
                                                                                                       __f},
                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                          description: "Id(.left=_M, .right=_N, .ty=s), TySubst(.ty=s, .f=f, .sub=t), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R)".to_string(),
                                                                                                                          ffun: None,
                                                                                                                          arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                          {
                                                                                                                              let (_Q, t) = match *__v1 {
                                                                                                                                  Value::tuple2__TmS_TyS(ref __box) => {
                                                                                                                                      match *__box {
                                                                                                                                          (ref _Q, ref t) => (_Q, t),
                                                                                                                                          _ => unreachable!(),
                                                                                                                                      }
                                                                                                                                  },
                                                                                                                                  _ => unreachable!()
                                                                                                                              };
                                                                                                                              let _R = match *__v2{
                                                                                                                                  Value::TmSubst(ref __box) => {
                                                                                                                                      match *__box {
                                                                                                                                      TmSubst{tm: _, f: _, sub: ref _R} => _R,
                                                                                                                                      _ => return None
                                                                                                                                      }
                                                                                                                                  },
                                                                                                                                  _ => return None
                                                                                                                              };
                                                                                                                              Some(Value::Id(Id{left: _Q.clone(), right: _R.clone(), ty: t.clone()}))
                                                                                                                          }
                                                                                                                          __f},
                                                                                                                          next: Box::new(None)
                                                                                                                      })
                                                                                                   }))
                                                                           })
                                                        }))
                                }
                     }],
                 arrangements: vec![
                     Arrangement::Map{
                        name: r###"Id{.left=_0, .right=_, .ty=_}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Id(__box) = __v {
                                     match __box {
                                     Id{left: ref _0, right: _, ty: _} => Some(Value::TmS(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     },
                     Arrangement::Map{
                        name: r###"Id{.left=_, .right=_, .ty=_0}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Id(__box) = __v {
                                     match __box {
                                     Id{left: _, right: _, ty: ref _0} => Some(Value::TyS(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     },
                     Arrangement::Map{
                        name: r###"Id{.left=_0, .right=_1, .ty=_}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Id(__box) = __v {
                                     match __box {
                                     Id{left: ref _0, right: ref _1, ty: _} => Some(Value::tuple2__TmS_TmS((_0.clone(), _1.clone()))),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     }],
                 change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
             };
    let TmEq = Relation {
                   name:         "TmEq".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::TmEq as RelId,
                   rules:        vec![
                       /* TmEq(.l=l, .r=r) :- TmEqInput(.l=l, .r=r). */
                       Rule::CollectionRule {
                           description: "TmEq(.l=l, .r=r) :- TmEqInput(.l=l, .r=r).".to_string(),
                           rel: Relations::TmEqInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TmEq(.l=l, .r=r) :- TmEqInput(.l=l, .r=r)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let (l, r) = match __v{
                                                   Value::TmEqInput(ref __box) => {
                                                       match *__box {
                                                       TmEqInput{l: ref l, r: ref r} => (l, r),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TmEq(TmEq{l: l.clone(), r: r.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TmEq(.l=tm, .r=tm) :- Tm(.tm=tm, .ty=_). */
                       Rule::CollectionRule {
                           description: "TmEq(.l=tm, .r=tm) :- Tm(.tm=tm, .ty=_).".to_string(),
                           rel: Relations::Tm as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TmEq(.l=tm, .r=tm) :- Tm(.tm=tm, .ty=_)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let tm = match __v{
                                                   Value::Tm(ref __box) => {
                                                       match *__box {
                                                       Tm{tm: ref tm, ty: _} => tm,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TmEq(TmEq{l: tm.clone(), r: tm.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TmEq(.l=l, .r=r) :- TmEq(.l=r, .r=l). */
                       Rule::CollectionRule {
                           description: "TmEq(.l=l, .r=r) :- TmEq(.l=r, .r=l).".to_string(),
                           rel: Relations::TmEq as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of TmEq(.l=l, .r=r) :- TmEq(.l=r, .r=l)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let (r, l) = match __v{
                                                   Value::TmEq(ref __box) => {
                                                       match *__box {
                                                       TmEq{l: ref r, r: ref l} => (r, l),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::TmEq(TmEq{l: l.clone(), r: r.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* TmEq(.l=a, .r=c) :- TmEq(.l=a, .r=b), TmEq(.l=b, .r=c). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=a, .r=c) :- TmEq(.l=a, .r=b), TmEq(.l=b, .r=c).".to_string(),
                           arr: ( Relations::TmEq as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "TmEq(.l=a, .r=b), TmEq(.l=b, .r=c)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TmEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (a, b) = match *__v1{
                                              Value::TmEq(ref __box) => {
                                                  match *__box {
                                                  TmEq{l: ref a, r: ref b} => (a, b),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let c = match *__v2{
                                              Value::TmEq(ref __box) => {
                                                  match *__box {
                                                  TmEq{l: _, r: ref c} => c,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TmEq(TmEq{l: a.clone(), r: c.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TmEq(.l=_N, .r=_O) :- TmSubst(.tm=_M, .f=f, .sub=_N), TmSubst(.tm=_M, .f=f, .sub=_O). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_N, .r=_O) :- TmSubst(.tm=_M, .f=f, .sub=_N), TmSubst(.tm=_M, .f=f, .sub=_O).".to_string(),
                           arr: ( Relations::TmSubst as RelId, 2),
                           xform: XFormArrangement::Join{
                                      description: "TmSubst(.tm=_M, .f=f, .sub=_N), TmSubst(.tm=_M, .f=f, .sub=_O)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TmSubst as RelId,2),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, f, _N) = match *__v1{
                                              Value::TmSubst(ref __box) => {
                                                  match *__box {
                                                  TmSubst{tm: ref _M, f: ref f, sub: ref _N} => (_M, f, _N),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _O = match *__v2{
                                              Value::TmSubst(ref __box) => {
                                                  match *__box {
                                                  TmSubst{tm: _, f: _, sub: ref _O} => _O,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TmEq(TmEq{l: _N.clone(), r: _O.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TmEq(.l=_M, .r=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), ProjTm(.ctx=_G, .ty=s, .tm=_N). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_M, .r=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), ProjTm(.ctx=_G, .ty=s, .tm=_N).".to_string(),
                           arr: ( Relations::ProjTm as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), ProjTm(.ctx=_G, .ty=s, .tm=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::ProjTm as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_G, s, _M) = match *__v1{
                                              Value::ProjTm(ref __box) => {
                                                  match *__box {
                                                  ProjTm{ctx: ref _G, ty: ref s, tm: ref _M} => (_G, s, _M),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::ProjTm(ref __box) => {
                                                  match *__box {
                                                  ProjTm{ctx: _, ty: _, tm: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TmEq(TmEq{l: _M.clone(), r: _N.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TmEq(.l=_M, .r=_N) :- __Prefix_7[(_M, s)], Refl(.tm=_N), Tm(.tm=_N, .ty=s). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_M, .r=_N) :- __Prefix_7[(_M, s)], Refl(.tm=_N), Tm(.tm=_N, .ty=s).".to_string(),
                           arr: ( Relations::__Prefix_7 as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_7[(_M, s)], Refl(.tm=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Refl as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::tuple2__TmS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _M, ref s) => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::Refl(ref __box) => {
                                                  match *__box {
                                                  Refl{tm: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple3__TmS_TmS_TyS((_M.clone(), _N.clone(), s.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange __Prefix_7[(_M, s)], Refl(.tm=_N) by (_N, s)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_M, _N, s) = match __v {
                                                                      Value::tuple3__TmS_TmS_TyS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _M, ref _N, ref s) => (_M, _N, s),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__TmS_TyS((_N.clone(), s.clone())), Value::tuple2__TmS_TmS((_M.clone(), _N.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Semijoin{
                                                                                 description: "__Prefix_7[(_M, s)], Refl(.tm=_N), Tm(.tm=_N, .ty=s)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Tm as RelId,2),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                 {
                                                                                     let (_M, _N) = match *__v1 {
                                                                                         Value::tuple2__TmS_TmS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref _M, ref _N) => (_M, _N),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     Some(Value::TmEq(TmEq{l: _M.clone(), r: _N.clone()}))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(None)
                                                                             })
                                                          }))
                                  }
                       },
                       /* TmEq(.l=_M, .r=_N) :- __Prefix_6[(_M, s)], True(.tm=_N), Tm(.tm=_N, .ty=s). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_M, .r=_N) :- __Prefix_6[(_M, s)], True(.tm=_N), Tm(.tm=_N, .ty=s).".to_string(),
                           arr: ( Relations::__Prefix_6 as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_6[(_M, s)], True(.tm=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::True as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::tuple2__TmS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _M, ref s) => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::True(ref __box) => {
                                                  match *__box {
                                                  True{tm: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple3__TmS_TmS_TyS((_M.clone(), _N.clone(), s.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange __Prefix_6[(_M, s)], True(.tm=_N) by (_N, s)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_M, _N, s) = match __v {
                                                                      Value::tuple3__TmS_TmS_TyS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _M, ref _N, ref s) => (_M, _N, s),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__TmS_TyS((_N.clone(), s.clone())), Value::tuple2__TmS_TmS((_M.clone(), _N.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Semijoin{
                                                                                 description: "__Prefix_6[(_M, s)], True(.tm=_N), Tm(.tm=_N, .ty=s)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Tm as RelId,2),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                 {
                                                                                     let (_M, _N) = match *__v1 {
                                                                                         Value::tuple2__TmS_TmS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref _M, ref _N) => (_M, _N),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     Some(Value::TmEq(TmEq{l: _M.clone(), r: _N.clone()}))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(None)
                                                                             })
                                                          }))
                                  }
                       },
                       /* TmEq(.l=_M, .r=_N) :- __Prefix_5[(_M, s)], False(.tm=_N), Tm(.tm=_N, .ty=s). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_M, .r=_N) :- __Prefix_5[(_M, s)], False(.tm=_N), Tm(.tm=_N, .ty=s).".to_string(),
                           arr: ( Relations::__Prefix_5 as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_5[(_M, s)], False(.tm=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::False as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::tuple2__TmS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _M, ref s) => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::False(ref __box) => {
                                                  match *__box {
                                                  False{tm: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple3__TmS_TmS_TyS((_M.clone(), _N.clone(), s.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange __Prefix_5[(_M, s)], False(.tm=_N) by (_N, s)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_M, _N, s) = match __v {
                                                                      Value::tuple3__TmS_TmS_TyS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _M, ref _N, ref s) => (_M, _N, s),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__TmS_TyS((_N.clone(), s.clone())), Value::tuple2__TmS_TmS((_M.clone(), _N.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Semijoin{
                                                                                 description: "__Prefix_5[(_M, s)], False(.tm=_N), Tm(.tm=_N, .ty=s)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Tm as RelId,2),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                 {
                                                                                     let (_M, _N) = match *__v1 {
                                                                                         Value::tuple2__TmS_TmS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref _M, ref _N) => (_M, _N),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     Some(Value::TmEq(TmEq{l: _M.clone(), r: _N.clone()}))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(None)
                                                                             })
                                                          }))
                                  }
                       },
                       /* TmEq(.l=_O, .r=_P) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_P). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_O, .r=_P) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_P).".to_string(),
                           arr: ( Relations::BoolElim as RelId, 2),
                           xform: XFormArrangement::Join{
                                      description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_P)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::BoolElim as RelId,2),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, _N, _O) = match *__v1{
                                              Value::BoolElim(ref __box) => {
                                                  match *__box {
                                                  BoolElim{trueCase: ref _M, falseCase: ref _N, tm: ref _O} => (_M, _N, _O),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _P = match *__v2{
                                              Value::BoolElim(ref __box) => {
                                                  match *__box {
                                                  BoolElim{trueCase: _, falseCase: _, tm: ref _P} => _P,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TmEq(TmEq{l: _O.clone(), r: _P.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* TmEq(.l=_N, .r=_O) :- Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s). */
                       Rule::ArrangementRule {
                           description: "TmEq(.l=_N, .r=_O) :- Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s).".to_string(),
                           arr: ( Relations::Tm as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Id as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::Tm(ref __box) => {
                                                  match *__box {
                                                  Tm{tm: ref _M, ty: ref s} => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (_N, _O) = match *__v2{
                                              Value::Id(ref __box) => {
                                                  match *__box {
                                                  Id{left: ref _N, right: ref _O, ty: _} => (_N, _O),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::TmEq(TmEq{l: _N.clone(), r: _O.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"TmEq{.l=_0, .r=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::TmEq(__box) = __v {
                                       match __box {
                                       TmEq{l: ref _0, r: _} => Some(Value::TmS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"TmEq{.l=_, .r=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::TmEq(__box) = __v {
                                       match __box {
                                       TmEq{l: _, r: ref _0} => Some(Value::TmS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let BoolElim = Relation {
                       name:         "BoolElim".to_string(),
                       input:        false,
                       distinct:     false,
                       key_func:     None,
                       id:           Relations::BoolElim as RelId,
                       rules:        vec![
                           /* BoolElim(.trueCase=trueCase, .falseCase=falseCase, .tm=tm) :- BoolElimInput(.trueCase=trueCase, .falseCase=falseCase, .tm=tm). */
                           Rule::CollectionRule {
                               description: "BoolElim(.trueCase=trueCase, .falseCase=falseCase, .tm=tm) :- BoolElimInput(.trueCase=trueCase, .falseCase=falseCase, .tm=tm).".to_string(),
                               rel: Relations::BoolElimInput as RelId,
                               xform: Some(XFormCollection::FilterMap{
                                               description: "head of BoolElim(.trueCase=trueCase, .falseCase=falseCase, .tm=tm) :- BoolElimInput(.trueCase=trueCase, .falseCase=falseCase, .tm=tm)." .to_string(),
                                               fmfun: &{fn __f(__v: Value) -> Option<Value>
                                               {
                                                   let (trueCase, falseCase, tm) = match __v{
                                                       Value::BoolElimInput(ref __box) => {
                                                           match *__box {
                                                           BoolElimInput{trueCase: ref trueCase, falseCase: ref falseCase, tm: ref tm} => (trueCase, falseCase, tm),
                                                           _ => return None
                                                           }
                                                       },
                                                       _ => return None
                                                   };
                                                   Some(Value::BoolElim(BoolElim{trueCase: trueCase.clone(), falseCase: falseCase.clone(), tm: tm.clone()}))
                                               }
                                               __f},
                                               next: Box::new(None)
                                           })
                           },
                           /* BoolElim(.trueCase=_P, .falseCase=_Q, .tm=_R) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P), TmEq(.l=_N, .r=_Q), TmEq(.l=_O, .r=_R). */
                           Rule::ArrangementRule {
                               description: "BoolElim(.trueCase=_P, .falseCase=_Q, .tm=_R) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P), TmEq(.l=_N, .r=_Q), TmEq(.l=_O, .r=_R).".to_string(),
                               arr: ( Relations::BoolElim as RelId, 0),
                               xform: XFormArrangement::Join{
                                          description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::TmEq as RelId,0),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let (_M, _N, _O) = match *__v1{
                                                  Value::BoolElim(ref __box) => {
                                                      match *__box {
                                                      BoolElim{trueCase: ref _M, falseCase: ref _N, tm: ref _O} => (_M, _N, _O),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let _P = match *__v2{
                                                  Value::TmEq(ref __box) => {
                                                      match *__box {
                                                      TmEq{l: _, r: ref _P} => _P,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::tuple3__TmS_TmS_TmS((_N.clone(), _O.clone(), _P.clone())))
                                          }
                                          __f},
                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                  description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P) by (_N)" .to_string(),
                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                  {
                                                                      let (_N, _O, _P) = match __v {
                                                                          Value::tuple3__TmS_TmS_TmS(ref __box) => {
                                                                              match *__box {
                                                                                  (ref _N, ref _O, ref _P) => (_N, _O, _P),
                                                                                  _ => unreachable!(),
                                                                              }
                                                                          },
                                                                          _ => unreachable!()
                                                                      };
                                                                      Some((Value::TmS(_N.clone()), Value::tuple2__TmS_TmS((_O.clone(), _P.clone()))))
                                                                  }
                                                                  __f},
                                                                  next: Box::new(XFormArrangement::Join{
                                                                                     description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P), TmEq(.l=_N, .r=_Q)".to_string(),
                                                                                     ffun: None,
                                                                                     arrangement: (Relations::TmEq as RelId,0),
                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                     {
                                                                                         let (_O, _P) = match *__v1 {
                                                                                             Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                 match *__box {
                                                                                                     (ref _O, ref _P) => (_O, _P),
                                                                                                     _ => unreachable!(),
                                                                                                 }
                                                                                             },
                                                                                             _ => unreachable!()
                                                                                         };
                                                                                         let _Q = match *__v2{
                                                                                             Value::TmEq(ref __box) => {
                                                                                                 match *__box {
                                                                                                 TmEq{l: _, r: ref _Q} => _Q,
                                                                                                 _ => return None
                                                                                                 }
                                                                                             },
                                                                                             _ => return None
                                                                                         };
                                                                                         Some(Value::tuple3__TmS_TmS_TmS((_O.clone(), _P.clone(), _Q.clone())))
                                                                                     }
                                                                                     __f},
                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                             description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P), TmEq(.l=_N, .r=_Q) by (_O)" .to_string(),
                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                             {
                                                                                                                 let (_O, _P, _Q) = match __v {
                                                                                                                     Value::tuple3__TmS_TmS_TmS(ref __box) => {
                                                                                                                         match *__box {
                                                                                                                             (ref _O, ref _P, ref _Q) => (_O, _P, _Q),
                                                                                                                             _ => unreachable!(),
                                                                                                                         }
                                                                                                                     },
                                                                                                                     _ => unreachable!()
                                                                                                                 };
                                                                                                                 Some((Value::TmS(_O.clone()), Value::tuple2__TmS_TmS((_P.clone(), _Q.clone()))))
                                                                                                             }
                                                                                                             __f},
                                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                                description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), TmEq(.l=_M, .r=_P), TmEq(.l=_N, .r=_Q), TmEq(.l=_O, .r=_R)".to_string(),
                                                                                                                                ffun: None,
                                                                                                                                arrangement: (Relations::TmEq as RelId,0),
                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                {
                                                                                                                                    let (_P, _Q) = match *__v1 {
                                                                                                                                        Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                                (ref _P, ref _Q) => (_P, _Q),
                                                                                                                                                _ => unreachable!(),
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => unreachable!()
                                                                                                                                    };
                                                                                                                                    let _R = match *__v2{
                                                                                                                                        Value::TmEq(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                            TmEq{l: _, r: ref _R} => _R,
                                                                                                                                            _ => return None
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => return None
                                                                                                                                    };
                                                                                                                                    Some(Value::BoolElim(BoolElim{trueCase: _P.clone(), falseCase: _Q.clone(), tm: _R.clone()}))
                                                                                                                                }
                                                                                                                                __f},
                                                                                                                                next: Box::new(None)
                                                                                                                            })
                                                                                                         }))
                                                                                 })
                                                              }))
                                      }
                           },
                           /* BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O) :- Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q), TmSubst(.tm=_O, .f=h, .sub=_T), TmSubst(.tm=_N, .f=f, .sub=_T). */
                           Rule::ArrangementRule {
                               description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O) :- Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q), TmSubst(.tm=_O, .f=h, .sub=_T), TmSubst(.tm=_N, .f=f, .sub=_T).".to_string(),
                               arr: ( Relations::Extension as RelId, 0),
                               xform: XFormArrangement::Join{
                                          description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::True as RelId,0),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let (f, _P, g) = match *__v1{
                                                  Value::Extension(ref __box) => {
                                                      match *__box {
                                                      Extension{f: ref f, tm: ref _P, e: ref g} => (f, _P, g),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let () = match *__v2{
                                                  Value::True(ref __box) => {
                                                      match *__box {
                                                      True{tm: _} => (),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::tuple2__CtxMorphS_CtxMorphS((f.clone(), g.clone())))
                                          }
                                          __f},
                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                  description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P) by (g)" .to_string(),
                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                  {
                                                                      let (f, g) = match __v {
                                                                          Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                              match *__box {
                                                                                  (ref f, ref g) => (f, g),
                                                                                  _ => unreachable!(),
                                                                              }
                                                                          },
                                                                          _ => unreachable!()
                                                                      };
                                                                      Some((Value::CtxMorphS(g.clone()), Value::CtxMorphS(f.clone())))
                                                                  }
                                                                  __f},
                                                                  next: Box::new(XFormArrangement::Join{
                                                                                     description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S)".to_string(),
                                                                                     ffun: None,
                                                                                     arrangement: (Relations::TmSubst as RelId,0),
                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                     {
                                                                                         let f = match *__v1 {
                                                                                             Value::CtxMorphS(ref __box) => {
                                                                                                 match *__box {
                                                                                                     ref f => f,
                                                                                                     _ => unreachable!(),
                                                                                                 }
                                                                                             },
                                                                                             _ => unreachable!()
                                                                                         };
                                                                                         let (_O, _S) = match *__v2{
                                                                                             Value::TmSubst(ref __box) => {
                                                                                                 match *__box {
                                                                                                 TmSubst{tm: ref _O, f: _, sub: ref _S} => (_O, _S),
                                                                                                 _ => return None
                                                                                                 }
                                                                                             },
                                                                                             _ => return None
                                                                                         };
                                                                                         Some(Value::tuple3__TmS_TmS_CtxMorphS((_O.clone(), _S.clone(), f.clone())))
                                                                                     }
                                                                                     __f},
                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                             description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S) by (f, _S)" .to_string(),
                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                             {
                                                                                                                 let (_O, _S, f) = match __v {
                                                                                                                     Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                         match *__box {
                                                                                                                             (ref _O, ref _S, ref f) => (_O, _S, f),
                                                                                                                             _ => unreachable!(),
                                                                                                                         }
                                                                                                                     },
                                                                                                                     _ => unreachable!()
                                                                                                                 };
                                                                                                                 Some((Value::tuple2__CtxMorphS_TmS((f.clone(), _S.clone())), Value::tuple2__TmS_CtxMorphS((_O.clone(), f.clone()))))
                                                                                                             }
                                                                                                             __f},
                                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                                description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S)".to_string(),
                                                                                                                                ffun: None,
                                                                                                                                arrangement: (Relations::TmSubst as RelId,1),
                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                {
                                                                                                                                    let (_O, f) = match *__v1 {
                                                                                                                                        Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                                (ref _O, ref f) => (_O, f),
                                                                                                                                                _ => unreachable!(),
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => unreachable!()
                                                                                                                                    };
                                                                                                                                    let _M = match *__v2{
                                                                                                                                        Value::TmSubst(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                            TmSubst{tm: ref _M, f: _, sub: _} => _M,
                                                                                                                                            _ => return None
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => return None
                                                                                                                                    };
                                                                                                                                    Some(Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _O.clone(), f.clone())))
                                                                                                                                }
                                                                                                                                __f},
                                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                        description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S) by (f)" .to_string(),
                                                                                                                                                        afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                        {
                                                                                                                                                            let (_M, _O, f) = match __v {
                                                                                                                                                                Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                    match *__box {
                                                                                                                                                                        (ref _M, ref _O, ref f) => (_M, _O, f),
                                                                                                                                                                        _ => unreachable!(),
                                                                                                                                                                    }
                                                                                                                                                                },
                                                                                                                                                                _ => unreachable!()
                                                                                                                                                            };
                                                                                                                                                            Some((Value::CtxMorphS(f.clone()), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _O.clone(), f.clone()))))
                                                                                                                                                        }
                                                                                                                                                        __f},
                                                                                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                                                                                           description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h)".to_string(),
                                                                                                                                                                           ffun: None,
                                                                                                                                                                           arrangement: (Relations::Extension as RelId,1),
                                                                                                                                                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                           {
                                                                                                                                                                               let (_M, _O, f) = match *__v1 {
                                                                                                                                                                                   Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                       match *__box {
                                                                                                                                                                                           (ref _M, ref _O, ref f) => (_M, _O, f),
                                                                                                                                                                                           _ => unreachable!(),
                                                                                                                                                                                       }
                                                                                                                                                                                   },
                                                                                                                                                                                   _ => unreachable!()
                                                                                                                                                                               };
                                                                                                                                                                               let (_Q, h) = match *__v2{
                                                                                                                                                                                   Value::Extension(ref __box) => {
                                                                                                                                                                                       match *__box {
                                                                                                                                                                                       Extension{f: _, tm: ref _Q, e: ref h} => (_Q, h),
                                                                                                                                                                                       _ => return None
                                                                                                                                                                                       }
                                                                                                                                                                                   },
                                                                                                                                                                                   _ => return None
                                                                                                                                                                               };
                                                                                                                                                                               Some(Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _O.clone(), _Q.clone(), f.clone(), h.clone()))))
                                                                                                                                                                           }
                                                                                                                                                                           __f},
                                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                   description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h) by (_Q)" .to_string(),
                                                                                                                                                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                   {
                                                                                                                                                                                                       let (_M, _O, _Q, f, h) = match __v {
                                                                                                                                                                                                           Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                               match **__box {
                                                                                                                                                                                                                   (ref _M, ref _O, ref _Q, ref f, ref h) => (_M, _O, _Q, f, h),
                                                                                                                                                                                                                   _ => unreachable!(),
                                                                                                                                                                                                               }
                                                                                                                                                                                                           },
                                                                                                                                                                                                           _ => unreachable!()
                                                                                                                                                                                                       };
                                                                                                                                                                                                       Some((Value::TmS(_Q.clone()), Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS((_M.clone(), _O.clone(), f.clone(), h.clone()))))
                                                                                                                                                                                                   }
                                                                                                                                                                                                   __f},
                                                                                                                                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                      description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q)".to_string(),
                                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                                      arrangement: (Relations::False as RelId,0),
                                                                                                                                                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                      {
                                                                                                                                                                                                                          let (_M, _O, f, h) = match *__v1 {
                                                                                                                                                                                                                              Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                  match *__box {
                                                                                                                                                                                                                                      (ref _M, ref _O, ref f, ref h) => (_M, _O, f, h),
                                                                                                                                                                                                                                      _ => unreachable!(),
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                              },
                                                                                                                                                                                                                              _ => unreachable!()
                                                                                                                                                                                                                          };
                                                                                                                                                                                                                          let () = match *__v2{
                                                                                                                                                                                                                              Value::False(ref __box) => {
                                                                                                                                                                                                                                  match *__box {
                                                                                                                                                                                                                                  False{tm: _} => (),
                                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                              },
                                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                                          };
                                                                                                                                                                                                                          Some(Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS((_M.clone(), _O.clone(), f.clone(), h.clone())))
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                      __f},
                                                                                                                                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                              description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q) by (_O, h)" .to_string(),
                                                                                                                                                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                  let (_M, _O, f, h) = match __v {
                                                                                                                                                                                                                                                      Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                          match *__box {
                                                                                                                                                                                                                                                              (ref _M, ref _O, ref f, ref h) => (_M, _O, f, h),
                                                                                                                                                                                                                                                              _ => unreachable!(),
                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                      },
                                                                                                                                                                                                                                                      _ => unreachable!()
                                                                                                                                                                                                                                                  };
                                                                                                                                                                                                                                                  Some((Value::tuple2__TmS_CtxMorphS((_O.clone(), h.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _O.clone(), f.clone()))))
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                              __f},
                                                                                                                                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                 description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q), TmSubst(.tm=_O, .f=h, .sub=_T)".to_string(),
                                                                                                                                                                                                                                                                 ffun: None,
                                                                                                                                                                                                                                                                 arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                                                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                     let (_M, _O, f) = match *__v1 {
                                                                                                                                                                                                                                                                         Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                             match *__box {
                                                                                                                                                                                                                                                                                 (ref _M, ref _O, ref f) => (_M, _O, f),
                                                                                                                                                                                                                                                                                 _ => unreachable!(),
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                                                                                         _ => unreachable!()
                                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                                     let _T = match *__v2{
                                                                                                                                                                                                                                                                         Value::TmSubst(ref __box) => {
                                                                                                                                                                                                                                                                             match *__box {
                                                                                                                                                                                                                                                                             TmSubst{tm: _, f: _, sub: ref _T} => _T,
                                                                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                                                                                         _ => return None
                                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                                     Some(Value::tuple4__TmS_TmS_TmS_CtxMorphS((_M.clone(), _O.clone(), _T.clone(), f.clone())))
                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                 __f},
                                                                                                                                                                                                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                         description: "arrange Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q), TmSubst(.tm=_O, .f=h, .sub=_T) by (f, _T)" .to_string(),
                                                                                                                                                                                                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                             let (_M, _O, _T, f) = match __v {
                                                                                                                                                                                                                                                                                                 Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                                                     match *__box {
                                                                                                                                                                                                                                                                                                         (ref _M, ref _O, ref _T, ref f) => (_M, _O, _T, f),
                                                                                                                                                                                                                                                                                                         _ => unreachable!(),
                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                 },
                                                                                                                                                                                                                                                                                                 _ => unreachable!()
                                                                                                                                                                                                                                                                                             };
                                                                                                                                                                                                                                                                                             Some((Value::tuple2__CtxMorphS_TmS((f.clone(), _T.clone())), Value::tuple2__TmS_TmS((_M.clone(), _O.clone()))))
                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                         __f},
                                                                                                                                                                                                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                                            description: "Extension(.f=f, .tm=_P, .e=g), True(.tm=_P), TmSubst(.tm=_O, .f=g, .sub=_S), TmSubst(.tm=_M, .f=f, .sub=_S), Extension(.f=f, .tm=_Q, .e=h), False(.tm=_Q), TmSubst(.tm=_O, .f=h, .sub=_T), TmSubst(.tm=_N, .f=f, .sub=_T)".to_string(),
                                                                                                                                                                                                                                                                                                            ffun: None,
                                                                                                                                                                                                                                                                                                            arrangement: (Relations::TmSubst as RelId,1),
                                                                                                                                                                                                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                let (_M, _O) = match *__v1 {
                                                                                                                                                                                                                                                                                                                    Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                                                                                                                                                                                                        match *__box {
                                                                                                                                                                                                                                                                                                                            (ref _M, ref _O) => (_M, _O),
                                                                                                                                                                                                                                                                                                                            _ => unreachable!(),
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    },
                                                                                                                                                                                                                                                                                                                    _ => unreachable!()
                                                                                                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                                                                                let _N = match *__v2{
                                                                                                                                                                                                                                                                                                                    Value::TmSubst(ref __box) => {
                                                                                                                                                                                                                                                                                                                        match *__box {
                                                                                                                                                                                                                                                                                                                        TmSubst{tm: ref _N, f: _, sub: _} => _N,
                                                                                                                                                                                                                                                                                                                        _ => return None
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    },
                                                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                                                                                Some(Value::BoolElim(BoolElim{trueCase: _M.clone(), falseCase: _N.clone(), tm: _O.clone()}))
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                            __f},
                                                                                                                                                                                                                                                                                                            next: Box::new(None)
                                                                                                                                                                                                                                                                                                        })
                                                                                                                                                                                                                                                                                     }))
                                                                                                                                                                                                                                                             })
                                                                                                                                                                                                                                          }))
                                                                                                                                                                                                                  })
                                                                                                                                                                                               }))
                                                                                                                                                                       })
                                                                                                                                                    }))
                                                                                                                            })
                                                                                                         }))
                                                                                 })
                                                              }))
                                      }
                           },
                           /* BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R). */
                           Rule::ArrangementRule {
                               description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P) :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R).".to_string(),
                               arr: ( Relations::BoolElim as RelId, 1),
                               xform: XFormArrangement::Join{
                                          description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::CtxMorph as RelId,1),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let (_M, _N, _O) = match *__v1{
                                                  Value::BoolElim(ref __box) => {
                                                      match *__box {
                                                      BoolElim{trueCase: ref _M, falseCase: ref _N, tm: ref _O} => (_M, _N, _O),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let (f, _G, _D) = match *__v2{
                                                  Value::CtxMorph(ref __box) => {
                                                      match *__box {
                                                      CtxMorph{f: ref f, from: ref _G, to: ref _D} => (f, _G, _D),
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _O.clone(), f.clone()))))
                                          }
                                          __f},
                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                  description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D) by (f)" .to_string(),
                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                  {
                                                                      let (_D, _M, _N, _O, f) = match __v {
                                                                          Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                              match **__box {
                                                                                  (ref _D, ref _M, ref _N, ref _O, ref f) => (_D, _M, _N, _O, f),
                                                                                  _ => unreachable!(),
                                                                              }
                                                                          },
                                                                          _ => unreachable!()
                                                                      };
                                                                      Some((Value::CtxMorphS(f.clone()), Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _O.clone(), f.clone())))))
                                                                  }
                                                                  __f},
                                                                  next: Box::new(XFormArrangement::Join{
                                                                                     description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q)".to_string(),
                                                                                     ffun: None,
                                                                                     arrangement: (Relations::Weakening as RelId,0),
                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                     {
                                                                                         let (_D, _M, _N, _O, f) = match *__v1 {
                                                                                             Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                 match **__box {
                                                                                                     (ref _D, ref _M, ref _N, ref _O, ref f) => (_D, _M, _N, _O, f),
                                                                                                     _ => unreachable!(),
                                                                                                 }
                                                                                             },
                                                                                             _ => unreachable!()
                                                                                         };
                                                                                         let (s, q) = match *__v2{
                                                                                             Value::Weakening(ref __box) => {
                                                                                                 match *__box {
                                                                                                 Weakening{f: _, ty: ref s, q: ref q} => (s, q),
                                                                                                 _ => return None
                                                                                                 }
                                                                                             },
                                                                                             _ => return None
                                                                                         };
                                                                                         Some(Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _O.clone(), f.clone(), q.clone(), s.clone()))))
                                                                                     }
                                                                                     __f},
                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                             description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q) by (s)" .to_string(),
                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                             {
                                                                                                                 let (_D, _M, _N, _O, f, q, s) = match __v {
                                                                                                                     Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                         match **__box {
                                                                                                                             (ref _D, ref _M, ref _N, ref _O, ref f, ref q, ref s) => (_D, _M, _N, _O, f, q, s),
                                                                                                                             _ => unreachable!(),
                                                                                                                         }
                                                                                                                     },
                                                                                                                     _ => unreachable!()
                                                                                                                 };
                                                                                                                 Some((Value::TyS(s.clone()), Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _O.clone(), f.clone(), q.clone(), s.clone())))))
                                                                                                             }
                                                                                                             __f},
                                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                                description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s)".to_string(),
                                                                                                                                ffun: None,
                                                                                                                                arrangement: (Relations::Bool as RelId,0),
                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                {
                                                                                                                                    let (_D, _M, _N, _O, f, q, s) = match *__v1 {
                                                                                                                                        Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                            match **__box {
                                                                                                                                                (ref _D, ref _M, ref _N, ref _O, ref f, ref q, ref s) => (_D, _M, _N, _O, f, q, s),
                                                                                                                                                _ => unreachable!(),
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => unreachable!()
                                                                                                                                    };
                                                                                                                                    let () = match *__v2{
                                                                                                                                        Value::Bool(ref __box) => {
                                                                                                                                            match *__box {
                                                                                                                                            Bool{ty: _} => (),
                                                                                                                                            _ => return None
                                                                                                                                            }
                                                                                                                                        },
                                                                                                                                        _ => return None
                                                                                                                                    };
                                                                                                                                    Some(Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _O.clone(), f.clone(), q.clone(), s.clone()))))
                                                                                                                                }
                                                                                                                                __f},
                                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                        description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s) by (s, _D)" .to_string(),
                                                                                                                                                        afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                        {
                                                                                                                                                            let (_D, _M, _N, _O, f, q, s) = match __v {
                                                                                                                                                                Value::tuple7__CtxS_TmS_TmS_TmS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                    match **__box {
                                                                                                                                                                        (ref _D, ref _M, ref _N, ref _O, ref f, ref q, ref s) => (_D, _M, _N, _O, f, q, s),
                                                                                                                                                                        _ => unreachable!(),
                                                                                                                                                                    }
                                                                                                                                                                },
                                                                                                                                                                _ => unreachable!()
                                                                                                                                                            };
                                                                                                                                                            Some((Value::tuple2__TyS_CtxS((s.clone(), _D.clone())), Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), f.clone(), q.clone())))))
                                                                                                                                                        }
                                                                                                                                                        __f},
                                                                                                                                                        next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                                                           description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D)".to_string(),
                                                                                                                                                                           ffun: None,
                                                                                                                                                                           arrangement: (Relations::Ty as RelId,1),
                                                                                                                                                                           jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                                                                           {
                                                                                                                                                                               let (_M, _N, _O, f, q) = match *__v1 {
                                                                                                                                                                                   Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                       match **__box {
                                                                                                                                                                                           (ref _M, ref _N, ref _O, ref f, ref q) => (_M, _N, _O, f, q),
                                                                                                                                                                                           _ => unreachable!(),
                                                                                                                                                                                       }
                                                                                                                                                                                   },
                                                                                                                                                                                   _ => unreachable!()
                                                                                                                                                                               };
                                                                                                                                                                               Some(Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), f.clone(), q.clone()))))
                                                                                                                                                                           }
                                                                                                                                                                           __f},
                                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                   description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D) by (_O, q)" .to_string(),
                                                                                                                                                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                   {
                                                                                                                                                                                                       let (_M, _N, _O, f, q) = match __v {
                                                                                                                                                                                                           Value::tuple5__TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                               match **__box {
                                                                                                                                                                                                                   (ref _M, ref _N, ref _O, ref f, ref q) => (_M, _N, _O, f, q),
                                                                                                                                                                                                                   _ => unreachable!(),
                                                                                                                                                                                                               }
                                                                                                                                                                                                           },
                                                                                                                                                                                                           _ => unreachable!()
                                                                                                                                                                                                       };
                                                                                                                                                                                                       Some((Value::tuple2__TmS_CtxMorphS((_O.clone(), q.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), f.clone()))))
                                                                                                                                                                                                   }
                                                                                                                                                                                                   __f},
                                                                                                                                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                      description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P)".to_string(),
                                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                                      arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                                                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                      {
                                                                                                                                                                                                                          let (_M, _N, f) = match *__v1 {
                                                                                                                                                                                                                              Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                  match *__box {
                                                                                                                                                                                                                                      (ref _M, ref _N, ref f) => (_M, _N, f),
                                                                                                                                                                                                                                      _ => unreachable!(),
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                              },
                                                                                                                                                                                                                              _ => unreachable!()
                                                                                                                                                                                                                          };
                                                                                                                                                                                                                          let _P = match *__v2{
                                                                                                                                                                                                                              Value::TmSubst(ref __box) => {
                                                                                                                                                                                                                                  match *__box {
                                                                                                                                                                                                                                  TmSubst{tm: _, f: _, sub: ref _P} => _P,
                                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                              },
                                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                                          };
                                                                                                                                                                                                                          Some(Value::tuple4__TmS_TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), _P.clone(), f.clone())))
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                      __f},
                                                                                                                                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                              description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P) by (_M, f)" .to_string(),
                                                                                                                                                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                  let (_M, _N, _P, f) = match __v {
                                                                                                                                                                                                                                                      Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                          match *__box {
                                                                                                                                                                                                                                                              (ref _M, ref _N, ref _P, ref f) => (_M, _N, _P, f),
                                                                                                                                                                                                                                                              _ => unreachable!(),
                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                      },
                                                                                                                                                                                                                                                      _ => unreachable!()
                                                                                                                                                                                                                                                  };
                                                                                                                                                                                                                                                  Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_N.clone(), _P.clone(), f.clone()))))
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                              __f},
                                                                                                                                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                 description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P), TmSubst(.tm=_M, .f=f, .sub=_Q)".to_string(),
                                                                                                                                                                                                                                                                 ffun: None,
                                                                                                                                                                                                                                                                 arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                                                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                     let (_N, _P, f) = match *__v1 {
                                                                                                                                                                                                                                                                         Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                             match *__box {
                                                                                                                                                                                                                                                                                 (ref _N, ref _P, ref f) => (_N, _P, f),
                                                                                                                                                                                                                                                                                 _ => unreachable!(),
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                                                                                         _ => unreachable!()
                                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                                     let _Q = match *__v2{
                                                                                                                                                                                                                                                                         Value::TmSubst(ref __box) => {
                                                                                                                                                                                                                                                                             match *__box {
                                                                                                                                                                                                                                                                             TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                                                                                         _ => return None
                                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                                     Some(Value::tuple4__TmS_TmS_TmS_CtxMorphS((_N.clone(), _P.clone(), _Q.clone(), f.clone())))
                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                 __f},
                                                                                                                                                                                                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                         description: "arrange BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P), TmSubst(.tm=_M, .f=f, .sub=_Q) by (_N, f)" .to_string(),
                                                                                                                                                                                                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                             let (_N, _P, _Q, f) = match __v {
                                                                                                                                                                                                                                                                                                 Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                                                     match *__box {
                                                                                                                                                                                                                                                                                                         (ref _N, ref _P, ref _Q, ref f) => (_N, _P, _Q, f),
                                                                                                                                                                                                                                                                                                         _ => unreachable!(),
                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                 },
                                                                                                                                                                                                                                                                                                 _ => unreachable!()
                                                                                                                                                                                                                                                                                             };
                                                                                                                                                                                                                                                                                             Some((Value::tuple2__TmS_CtxMorphS((_N.clone(), f.clone())), Value::tuple2__TmS_TmS((_P.clone(), _Q.clone()))))
                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                         __f},
                                                                                                                                                                                                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                                                            description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), CtxMorph(.f=f, .from=_G, .to=_D), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D), TmSubst(.tm=_O, .f=q, .sub=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R)".to_string(),
                                                                                                                                                                                                                                                                                                            ffun: None,
                                                                                                                                                                                                                                                                                                            arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                                                                                                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                let (_P, _Q) = match *__v1 {
                                                                                                                                                                                                                                                                                                                    Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                                                                                                                                                                                                        match *__box {
                                                                                                                                                                                                                                                                                                                            (ref _P, ref _Q) => (_P, _Q),
                                                                                                                                                                                                                                                                                                                            _ => unreachable!(),
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    },
                                                                                                                                                                                                                                                                                                                    _ => unreachable!()
                                                                                                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                                                                                let _R = match *__v2{
                                                                                                                                                                                                                                                                                                                    Value::TmSubst(ref __box) => {
                                                                                                                                                                                                                                                                                                                        match *__box {
                                                                                                                                                                                                                                                                                                                        TmSubst{tm: _, f: _, sub: ref _R} => _R,
                                                                                                                                                                                                                                                                                                                        _ => return None
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    },
                                                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                                                };
                                                                                                                                                                                                                                                                                                                Some(Value::BoolElim(BoolElim{trueCase: _Q.clone(), falseCase: _R.clone(), tm: _P.clone()}))
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                            __f},
                                                                                                                                                                                                                                                                                                            next: Box::new(None)
                                                                                                                                                                                                                                                                                                        })
                                                                                                                                                                                                                                                                                     }))
                                                                                                                                                                                                                                                             })
                                                                                                                                                                                                                                          }))
                                                                                                                                                                                                                  })
                                                                                                                                                                                               }))
                                                                                                                                                                       })
                                                                                                                                                    }))
                                                                                                                            })
                                                                                                         }))
                                                                                 })
                                                              }))
                                      }
                           }],
                       arrangements: vec![
                           Arrangement::Map{
                              name: r###"BoolElim{.trueCase=_0, .falseCase=_, .tm=_}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::BoolElim(__box) = __v {
                                           match __box {
                                           BoolElim{trueCase: ref _0, falseCase: _, tm: _} => Some(Value::TmS(_0.clone())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"_"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::BoolElim(__box) = __v {
                                           match __box {
                                           _ => Some(Value::tuple0__(())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"BoolElim{.trueCase=_0, .falseCase=_1, .tm=_}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::BoolElim(__box) = __v {
                                           match __box {
                                           BoolElim{trueCase: ref _0, falseCase: ref _1, tm: _} => Some(Value::tuple2__TmS_TmS((_0.clone(), _1.clone()))),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           }],
                       change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                   };
    let Extension = Relation {
                        name:         "Extension".to_string(),
                        input:        false,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::Extension as RelId,
                        rules:        vec![
                            /* Extension(.f=f, .tm=tm, .e=e) :- ExtensionInput(.f=f, .tm=tm, .e=e). */
                            Rule::CollectionRule {
                                description: "Extension(.f=f, .tm=tm, .e=e) :- ExtensionInput(.f=f, .tm=tm, .e=e).".to_string(),
                                rel: Relations::ExtensionInput as RelId,
                                xform: Some(XFormCollection::FilterMap{
                                                description: "head of Extension(.f=f, .tm=tm, .e=e) :- ExtensionInput(.f=f, .tm=tm, .e=e)." .to_string(),
                                                fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                {
                                                    let (f, tm, e) = match __v{
                                                        Value::ExtensionInput(ref __box) => {
                                                            match *__box {
                                                            ExtensionInput{f: ref f, tm: ref tm, e: ref e} => (f, tm, e),
                                                            _ => return None
                                                            }
                                                        },
                                                        _ => return None
                                                    };
                                                    Some(Value::Extension(Extension{f: f.clone(), tm: tm.clone(), e: e.clone()}))
                                                }
                                                __f},
                                                next: Box::new(None)
                                            })
                            },
                            /* Extension(.f=h, .tm=_N, .e=i) :- Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h), TmEq(.l=_M, .r=_N), CtxMorphEq(.l=g, .r=i). */
                            Rule::ArrangementRule {
                                description: "Extension(.f=h, .tm=_N, .e=i) :- Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h), TmEq(.l=_M, .r=_N), CtxMorphEq(.l=g, .r=i).".to_string(),
                                arr: ( Relations::Extension as RelId, 1),
                                xform: XFormArrangement::Join{
                                           description: "Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h)".to_string(),
                                           ffun: None,
                                           arrangement: (Relations::CtxMorphEq as RelId,0),
                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                           {
                                               let (f, _M, g) = match *__v1{
                                                   Value::Extension(ref __box) => {
                                                       match *__box {
                                                       Extension{f: ref f, tm: ref _M, e: ref g} => (f, _M, g),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               let h = match *__v2{
                                                   Value::CtxMorphEq(ref __box) => {
                                                       match *__box {
                                                       CtxMorphEq{l: _, r: ref h} => h,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::tuple3__TmS_CtxMorphS_CtxMorphS((_M.clone(), g.clone(), h.clone())))
                                           }
                                           __f},
                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                   description: "arrange Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h) by (_M)" .to_string(),
                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                   {
                                                                       let (_M, g, h) = match __v {
                                                                           Value::tuple3__TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                               match *__box {
                                                                                   (ref _M, ref g, ref h) => (_M, g, h),
                                                                                   _ => unreachable!(),
                                                                               }
                                                                           },
                                                                           _ => unreachable!()
                                                                       };
                                                                       Some((Value::TmS(_M.clone()), Value::tuple2__CtxMorphS_CtxMorphS((g.clone(), h.clone()))))
                                                                   }
                                                                   __f},
                                                                   next: Box::new(XFormArrangement::Join{
                                                                                      description: "Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h), TmEq(.l=_M, .r=_N)".to_string(),
                                                                                      ffun: None,
                                                                                      arrangement: (Relations::TmEq as RelId,0),
                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                      {
                                                                                          let (g, h) = match *__v1 {
                                                                                              Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                  match *__box {
                                                                                                      (ref g, ref h) => (g, h),
                                                                                                      _ => unreachable!(),
                                                                                                  }
                                                                                              },
                                                                                              _ => unreachable!()
                                                                                          };
                                                                                          let _N = match *__v2{
                                                                                              Value::TmEq(ref __box) => {
                                                                                                  match *__box {
                                                                                                  TmEq{l: _, r: ref _N} => _N,
                                                                                                  _ => return None
                                                                                                  }
                                                                                              },
                                                                                              _ => return None
                                                                                          };
                                                                                          Some(Value::tuple3__TmS_CtxMorphS_CtxMorphS((_N.clone(), g.clone(), h.clone())))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                              description: "arrange Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h), TmEq(.l=_M, .r=_N) by (g)" .to_string(),
                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                              {
                                                                                                                  let (_N, g, h) = match __v {
                                                                                                                      Value::tuple3__TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                          match *__box {
                                                                                                                              (ref _N, ref g, ref h) => (_N, g, h),
                                                                                                                              _ => unreachable!(),
                                                                                                                          }
                                                                                                                      },
                                                                                                                      _ => unreachable!()
                                                                                                                  };
                                                                                                                  Some((Value::CtxMorphS(g.clone()), Value::tuple2__TmS_CtxMorphS((_N.clone(), h.clone()))))
                                                                                                              }
                                                                                                              __f},
                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                 description: "Extension(.f=f, .tm=_M, .e=g), CtxMorphEq(.l=f, .r=h), TmEq(.l=_M, .r=_N), CtxMorphEq(.l=g, .r=i)".to_string(),
                                                                                                                                 ffun: None,
                                                                                                                                 arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                 {
                                                                                                                                     let (_N, h) = match *__v1 {
                                                                                                                                         Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                                 (ref _N, ref h) => (_N, h),
                                                                                                                                                 _ => unreachable!(),
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => unreachable!()
                                                                                                                                     };
                                                                                                                                     let i = match *__v2{
                                                                                                                                         Value::CtxMorphEq(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                             CtxMorphEq{l: _, r: ref i} => i,
                                                                                                                                             _ => return None
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => return None
                                                                                                                                     };
                                                                                                                                     Some(Value::Extension(Extension{f: h.clone(), tm: _N.clone(), e: i.clone()}))
                                                                                                                                 }
                                                                                                                                 __f},
                                                                                                                                 next: Box::new(None)
                                                                                                                             })
                                                                                                          }))
                                                                                  })
                                                               }))
                                       }
                            },
                            /* Extension(.f=gf, .tm=_N, .e=ef) :- Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N). */
                            Rule::ArrangementRule {
                                description: "Extension(.f=gf, .tm=_N, .e=ef) :- Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N).".to_string(),
                                arr: ( Relations::Extension as RelId, 4),
                                xform: XFormArrangement::Join{
                                           description: "Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef)".to_string(),
                                           ffun: None,
                                           arrangement: (Relations::Comp as RelId,0),
                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                           {
                                               let (g, _M, e) = match *__v1{
                                                   Value::Extension(ref __box) => {
                                                       match *__box {
                                                       Extension{f: ref g, tm: ref _M, e: ref e} => (g, _M, e),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               let (f, ef) = match *__v2{
                                                   Value::Comp(ref __box) => {
                                                       match *__box {
                                                       Comp{g: _, f: ref f, gf: ref ef} => (f, ef),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((_M.clone(), ef.clone(), f.clone(), g.clone())))
                                           }
                                           __f},
                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                   description: "arrange Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef) by (g, f)" .to_string(),
                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                   {
                                                                       let (_M, ef, f, g) = match __v {
                                                                           Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                               match *__box {
                                                                                   (ref _M, ref ef, ref f, ref g) => (_M, ef, f, g),
                                                                                   _ => unreachable!(),
                                                                               }
                                                                           },
                                                                           _ => unreachable!()
                                                                       };
                                                                       Some((Value::tuple2__CtxMorphS_CtxMorphS((g.clone(), f.clone())), Value::tuple3__TmS_CtxMorphS_CtxMorphS((_M.clone(), ef.clone(), f.clone()))))
                                                                   }
                                                                   __f},
                                                                   next: Box::new(XFormArrangement::Join{
                                                                                      description: "Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef), Comp(.g=g, .f=f, .gf=gf)".to_string(),
                                                                                      ffun: None,
                                                                                      arrangement: (Relations::Comp as RelId,3),
                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                      {
                                                                                          let (_M, ef, f) = match *__v1 {
                                                                                              Value::tuple3__TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                  match *__box {
                                                                                                      (ref _M, ref ef, ref f) => (_M, ef, f),
                                                                                                      _ => unreachable!(),
                                                                                                  }
                                                                                              },
                                                                                              _ => unreachable!()
                                                                                          };
                                                                                          let gf = match *__v2{
                                                                                              Value::Comp(ref __box) => {
                                                                                                  match *__box {
                                                                                                  Comp{g: _, f: _, gf: ref gf} => gf,
                                                                                                  _ => return None
                                                                                                  }
                                                                                              },
                                                                                              _ => return None
                                                                                          };
                                                                                          Some(Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((_M.clone(), ef.clone(), f.clone(), gf.clone())))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                              description: "arrange Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef), Comp(.g=g, .f=f, .gf=gf) by (_M, f)" .to_string(),
                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                              {
                                                                                                                  let (_M, ef, f, gf) = match __v {
                                                                                                                      Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                          match *__box {
                                                                                                                              (ref _M, ref ef, ref f, ref gf) => (_M, ef, f, gf),
                                                                                                                              _ => unreachable!(),
                                                                                                                          }
                                                                                                                      },
                                                                                                                      _ => unreachable!()
                                                                                                                  };
                                                                                                                  Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple2__CtxMorphS_CtxMorphS((ef.clone(), gf.clone()))))
                                                                                                              }
                                                                                                              __f},
                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                 description: "Extension(.f=g, .tm=_M, .e=e), Comp(.g=e, .f=f, .gf=ef), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N)".to_string(),
                                                                                                                                 ffun: None,
                                                                                                                                 arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                 {
                                                                                                                                     let (ef, gf) = match *__v1 {
                                                                                                                                         Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                                 (ref ef, ref gf) => (ef, gf),
                                                                                                                                                 _ => unreachable!(),
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => unreachable!()
                                                                                                                                     };
                                                                                                                                     let _N = match *__v2{
                                                                                                                                         Value::TmSubst(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                             TmSubst{tm: _, f: _, sub: ref _N} => _N,
                                                                                                                                             _ => return None
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => return None
                                                                                                                                     };
                                                                                                                                     Some(Value::Extension(Extension{f: gf.clone(), tm: _N.clone(), e: ef.clone()}))
                                                                                                                                 }
                                                                                                                                 __f},
                                                                                                                                 next: Box::new(None)
                                                                                                                             })
                                                                                                          }))
                                                                                  })
                                                               }))
                                       }
                            },
                            /* Extension(.f=p, .tm=_M, .e=f) :- IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_D, .to=_G), ProjTm(.ctx=_G, .ty=s, .tm=_M). */
                            Rule::ArrangementRule {
                                description: "Extension(.f=p, .tm=_M, .e=f) :- IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_D, .to=_G), ProjTm(.ctx=_G, .ty=s, .tm=_M).".to_string(),
                                arr: ( Relations::IdMorph as RelId, 0),
                                xform: XFormArrangement::Join{
                                           description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_)".to_string(),
                                           ffun: None,
                                           arrangement: (Relations::CtxMorph as RelId,3),
                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                           {
                                               let f = match *__v1{
                                                   Value::IdMorph(ref __box) => {
                                                       match *__box {
                                                       IdMorph{f: ref f} => f,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               let _D = match *__v2{
                                                   Value::CtxMorph(ref __box) => {
                                                       match *__box {
                                                       CtxMorph{f: _, from: ref _D, to: _} => _D,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::tuple2__CtxS_CtxMorphS((_D.clone(), f.clone())))
                                           }
                                           __f},
                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                   description: "arrange IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_) by ()" .to_string(),
                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                   {
                                                                       let (_D, f) = match __v {
                                                                           Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                               match *__box {
                                                                                   (ref _D, ref f) => (_D, f),
                                                                                   _ => unreachable!(),
                                                                               }
                                                                           },
                                                                           _ => unreachable!()
                                                                       };
                                                                       Some((Value::tuple0__(()), Value::tuple2__CtxS_CtxMorphS((_D.clone(), f.clone()))))
                                                                   }
                                                                   __f},
                                                                   next: Box::new(XFormArrangement::Join{
                                                                                      description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p)".to_string(),
                                                                                      ffun: None,
                                                                                      arrangement: (Relations::ProjCtx as RelId,2),
                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                      {
                                                                                          let (_D, f) = match *__v1 {
                                                                                              Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                                  match *__box {
                                                                                                      (ref _D, ref f) => (_D, f),
                                                                                                      _ => unreachable!(),
                                                                                                  }
                                                                                              },
                                                                                              _ => unreachable!()
                                                                                          };
                                                                                          let (_G, s, p) = match *__v2{
                                                                                              Value::ProjCtx(ref __box) => {
                                                                                                  match *__box {
                                                                                                  ProjCtx{ctx: ref _G, ty: ref s, f: ref p} => (_G, s, p),
                                                                                                  _ => return None
                                                                                                  }
                                                                                              },
                                                                                              _ => return None
                                                                                          };
                                                                                          Some(Value::tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _G.clone(), f.clone(), p.clone(), s.clone()))))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                              description: "arrange IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p) by (p, _D, _G)" .to_string(),
                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                              {
                                                                                                                  let (_D, _G, f, p, s) = match __v {
                                                                                                                      Value::tuple5__CtxS_CtxS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                          match **__box {
                                                                                                                              (ref _D, ref _G, ref f, ref p, ref s) => (_D, _G, f, p, s),
                                                                                                                              _ => unreachable!(),
                                                                                                                          }
                                                                                                                      },
                                                                                                                      _ => unreachable!()
                                                                                                                  };
                                                                                                                  Some((Value::tuple3__CtxMorphS_CtxS_CtxS((p.clone(), _D.clone(), _G.clone())), Value::tuple4__CtxS_CtxMorphS_CtxMorphS_TyS((_G.clone(), f.clone(), p.clone(), s.clone()))))
                                                                                                              }
                                                                                                              __f},
                                                                                                              next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                 description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_D, .to=_G)".to_string(),
                                                                                                                                 ffun: None,
                                                                                                                                 arrangement: (Relations::CtxMorph as RelId,7),
                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                                 {
                                                                                                                                     let (_G, f, p, s) = match *__v1 {
                                                                                                                                         Value::tuple4__CtxS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                                 (ref _G, ref f, ref p, ref s) => (_G, f, p, s),
                                                                                                                                                 _ => unreachable!(),
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => unreachable!()
                                                                                                                                     };
                                                                                                                                     Some(Value::tuple4__CtxS_CtxMorphS_CtxMorphS_TyS((_G.clone(), f.clone(), p.clone(), s.clone())))
                                                                                                                                 }
                                                                                                                                 __f},
                                                                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                         description: "arrange IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_D, .to=_G) by (_G, s)" .to_string(),
                                                                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                         {
                                                                                                                                                             let (_G, f, p, s) = match __v {
                                                                                                                                                                 Value::tuple4__CtxS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                     match *__box {
                                                                                                                                                                         (ref _G, ref f, ref p, ref s) => (_G, f, p, s),
                                                                                                                                                                         _ => unreachable!(),
                                                                                                                                                                     }
                                                                                                                                                                 },
                                                                                                                                                                 _ => unreachable!()
                                                                                                                                                             };
                                                                                                                                                             Some((Value::tuple2__CtxS_TyS((_G.clone(), s.clone())), Value::tuple2__CtxMorphS_CtxMorphS((f.clone(), p.clone()))))
                                                                                                                                                         }
                                                                                                                                                         __f},
                                                                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                                                                            description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_D, .to=_), ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_D, .to=_G), ProjTm(.ctx=_G, .ty=s, .tm=_M)".to_string(),
                                                                                                                                                                            ffun: None,
                                                                                                                                                                            arrangement: (Relations::ProjTm as RelId,0),
                                                                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                            {
                                                                                                                                                                                let (f, p) = match *__v1 {
                                                                                                                                                                                    Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                                                                        match *__box {
                                                                                                                                                                                            (ref f, ref p) => (f, p),
                                                                                                                                                                                            _ => unreachable!(),
                                                                                                                                                                                        }
                                                                                                                                                                                    },
                                                                                                                                                                                    _ => unreachable!()
                                                                                                                                                                                };
                                                                                                                                                                                let _M = match *__v2{
                                                                                                                                                                                    Value::ProjTm(ref __box) => {
                                                                                                                                                                                        match *__box {
                                                                                                                                                                                        ProjTm{ctx: _, ty: _, tm: ref _M} => _M,
                                                                                                                                                                                        _ => return None
                                                                                                                                                                                        }
                                                                                                                                                                                    },
                                                                                                                                                                                    _ => return None
                                                                                                                                                                                };
                                                                                                                                                                                Some(Value::Extension(Extension{f: p.clone(), tm: _M.clone(), e: f.clone()}))
                                                                                                                                                                            }
                                                                                                                                                                            __f},
                                                                                                                                                                            next: Box::new(None)
                                                                                                                                                                        })
                                                                                                                                                     }))
                                                                                                                             })
                                                                                                          }))
                                                                                  })
                                                               }))
                                       }
                            },
                            /* Extension(.f=f, .tm=_N, .e=e) :- __Prefix_3[(_G, _M, p, s)], Comp(.g=p, .f=e, .gf=f), TmSubst(.tm=_M, .f=e, .sub=_N). */
                            Rule::ArrangementRule {
                                description: "Extension(.f=f, .tm=_N, .e=e) :- __Prefix_3[(_G, _M, p, s)], Comp(.g=p, .f=e, .gf=f), TmSubst(.tm=_M, .f=e, .sub=_N).".to_string(),
                                arr: ( Relations::__Prefix_3 as RelId, 0),
                                xform: XFormArrangement::Join{
                                           description: "__Prefix_3[(_G, _M, p, s)], Comp(.g=p, .f=e, .gf=f)".to_string(),
                                           ffun: None,
                                           arrangement: (Relations::Comp as RelId,0),
                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                           {
                                               let (_G, _M, p, s) = match *__v1{
                                                   Value::tuple4__CtxS_TmS_CtxMorphS_TyS(ref __box) => {
                                                       match *__box {
                                                       (ref _G, ref _M, ref p, ref s) => (_G, _M, p, s),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               let (e, f) = match *__v2{
                                                   Value::Comp(ref __box) => {
                                                       match *__box {
                                                       Comp{g: _, f: ref e, gf: ref f} => (e, f),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::tuple3__TmS_CtxMorphS_CtxMorphS((_M.clone(), e.clone(), f.clone())))
                                           }
                                           __f},
                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                   description: "arrange __Prefix_3[(_G, _M, p, s)], Comp(.g=p, .f=e, .gf=f) by (_M, e)" .to_string(),
                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                   {
                                                                       let (_M, e, f) = match __v {
                                                                           Value::tuple3__TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                               match *__box {
                                                                                   (ref _M, ref e, ref f) => (_M, e, f),
                                                                                   _ => unreachable!(),
                                                                               }
                                                                           },
                                                                           _ => unreachable!()
                                                                       };
                                                                       Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), e.clone())), Value::tuple2__CtxMorphS_CtxMorphS((e.clone(), f.clone()))))
                                                                   }
                                                                   __f},
                                                                   next: Box::new(XFormArrangement::Join{
                                                                                      description: "__Prefix_3[(_G, _M, p, s)], Comp(.g=p, .f=e, .gf=f), TmSubst(.tm=_M, .f=e, .sub=_N)".to_string(),
                                                                                      ffun: None,
                                                                                      arrangement: (Relations::TmSubst as RelId,2),
                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                      {
                                                                                          let (e, f) = match *__v1 {
                                                                                              Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                  match *__box {
                                                                                                      (ref e, ref f) => (e, f),
                                                                                                      _ => unreachable!(),
                                                                                                  }
                                                                                              },
                                                                                              _ => unreachable!()
                                                                                          };
                                                                                          let _N = match *__v2{
                                                                                              Value::TmSubst(ref __box) => {
                                                                                                  match *__box {
                                                                                                  TmSubst{tm: _, f: _, sub: ref _N} => _N,
                                                                                                  _ => return None
                                                                                                  }
                                                                                              },
                                                                                              _ => return None
                                                                                          };
                                                                                          Some(Value::Extension(Extension{f: f.clone(), tm: _N.clone(), e: e.clone()}))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(None)
                                                                                  })
                                                               }))
                                       }
                            }],
                        arrangements: vec![
                            Arrangement::Map{
                               name: r###"Extension{.f=_, .tm=_0, .e=_}"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Extension(__box) = __v {
                                            match __box {
                                            Extension{f: _, tm: ref _0, e: _} => Some(Value::TmS(_0.clone())),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            },
                            Arrangement::Map{
                               name: r###"Extension{.f=_0, .tm=_, .e=_}"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Extension(__box) = __v {
                                            match __box {
                                            Extension{f: ref _0, tm: _, e: _} => Some(Value::CtxMorphS(_0.clone())),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            },
                            Arrangement::Map{
                               name: r###"_"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Extension(__box) = __v {
                                            match __box {
                                            _ => Some(Value::tuple0__(())),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            },
                            Arrangement::Map{
                               name: r###"Extension{.f=_0, .tm=_1, .e=_}"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Extension(__box) = __v {
                                            match __box {
                                            Extension{f: ref _0, tm: ref _1, e: _} => Some(Value::tuple2__CtxMorphS_TmS((_0.clone(), _1.clone()))),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            },
                            Arrangement::Map{
                               name: r###"Extension{.f=_, .tm=_, .e=_0}"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Extension(__box) = __v {
                                            match __box {
                                            Extension{f: _, tm: _, e: ref _0} => Some(Value::CtxMorphS(_0.clone())),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            }],
                        change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                    };
    let Comp = Relation {
                   name:         "Comp".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::Comp as RelId,
                   rules:        vec![
                       /* Comp(.g=g, .f=f, .gf=gf) :- CompInput(.g=g, .f=f, .gf=gf). */
                       Rule::CollectionRule {
                           description: "Comp(.g=g, .f=f, .gf=gf) :- CompInput(.g=g, .f=f, .gf=gf).".to_string(),
                           rel: Relations::CompInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of Comp(.g=g, .f=f, .gf=gf) :- CompInput(.g=g, .f=f, .gf=gf)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let (g, f, gf) = match __v{
                                                   Value::CompInput(ref __box) => {
                                                       match *__box {
                                                       CompInput{g: ref g, f: ref f, gf: ref gf} => (g, f, gf),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::Comp(Comp{g: g.clone(), f: f.clone(), gf: gf.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* Comp(.g=j, .f=i, .gf=ji) :- Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j), CtxMorphEq(.l=f, .r=i), CtxMorphEq(.l=gf, .r=ji). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=j, .f=i, .gf=ji) :- Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j), CtxMorphEq(.l=f, .r=i), CtxMorphEq(.l=gf, .r=ji).".to_string(),
                           arr: ( Relations::Comp as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::CtxMorphEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (g, f, gf) = match *__v1{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: ref g, f: ref f, gf: ref gf} => (g, f, gf),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let j = match *__v2{
                                              Value::CtxMorphEq(ref __box) => {
                                                  match *__box {
                                                  CtxMorphEq{l: _, r: ref j} => j,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS((f.clone(), gf.clone(), j.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j) by (f)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (f, gf, j) = match __v {
                                                                      Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                          match *__box {
                                                                              (ref f, ref gf, ref j) => (f, gf, j),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::CtxMorphS(f.clone()), Value::tuple2__CtxMorphS_CtxMorphS((gf.clone(), j.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j), CtxMorphEq(.l=f, .r=i)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let (gf, j) = match *__v1 {
                                                                                         Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref gf, ref j) => (gf, j),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let i = match *__v2{
                                                                                         Value::CtxMorphEq(ref __box) => {
                                                                                             match *__box {
                                                                                             CtxMorphEq{l: _, r: ref i} => i,
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS((gf.clone(), i.clone(), j.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j), CtxMorphEq(.l=f, .r=i) by (gf)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (gf, i, j) = match __v {
                                                                                                                 Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref gf, ref i, ref j) => (gf, i, j),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::CtxMorphS(gf.clone()), Value::tuple2__CtxMorphS_CtxMorphS((i.clone(), j.clone()))))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "Comp(.g=g, .f=f, .gf=gf), CtxMorphEq(.l=g, .r=j), CtxMorphEq(.l=f, .r=i), CtxMorphEq(.l=gf, .r=ji)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let (i, j) = match *__v1 {
                                                                                                                                    Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            (ref i, ref j) => (i, j),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let ji = match *__v2{
                                                                                                                                    Value::CtxMorphEq(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        CtxMorphEq{l: _, r: ref ji} => ji,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::Comp(Comp{g: j.clone(), f: i.clone(), gf: ji.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       },
                       /* Comp(.g=g, .f=id, .gf=g) :- __Prefix_4[(ctx, id)], CtxMorph(.f=g, .from=ctx, .to=_). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=g, .f=id, .gf=g) :- __Prefix_4[(ctx, id)], CtxMorph(.f=g, .from=ctx, .to=_).".to_string(),
                           arr: ( Relations::__Prefix_4 as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_4[(ctx, id)], CtxMorph(.f=g, .from=ctx, .to=_)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::CtxMorph as RelId,2),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (ctx, id) = match *__v1{
                                              Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                  match *__box {
                                                  (ref ctx, ref id) => (ctx, id),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let g = match *__v2{
                                              Value::CtxMorph(ref __box) => {
                                                  match *__box {
                                                  CtxMorph{f: ref g, from: _, to: _} => g,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::Comp(Comp{g: g.clone(), f: id.clone(), gf: g.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* Comp(.g=id, .f=f, .gf=f) :- __Prefix_4[(ctx, id)], CtxMorph(.f=f, .from=_, .to=ctx). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=id, .f=f, .gf=f) :- __Prefix_4[(ctx, id)], CtxMorph(.f=f, .from=_, .to=ctx).".to_string(),
                           arr: ( Relations::__Prefix_4 as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_4[(ctx, id)], CtxMorph(.f=f, .from=_, .to=ctx)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::CtxMorph as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (ctx, id) = match *__v1{
                                              Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                  match *__box {
                                                  (ref ctx, ref id) => (ctx, id),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let f = match *__v2{
                                              Value::CtxMorph(ref __box) => {
                                                  match *__box {
                                                  CtxMorph{f: ref f, from: _, to: _} => f,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::Comp(Comp{g: id.clone(), f: f.clone(), gf: f.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* Comp(.g=hg, .f=f, .gf=hgf) :- Comp(.g=g, .f=f, .gf=gf), Comp(.g=h, .f=gf, .gf=hgf), Comp(.g=h, .f=g, .gf=hg). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=hg, .f=f, .gf=hgf) :- Comp(.g=g, .f=f, .gf=gf), Comp(.g=h, .f=gf, .gf=hgf), Comp(.g=h, .f=g, .gf=hg).".to_string(),
                           arr: ( Relations::Comp as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "Comp(.g=g, .f=f, .gf=gf), Comp(.g=h, .f=gf, .gf=hgf)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Comp as RelId,2),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (g, f, gf) = match *__v1{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: ref g, f: ref f, gf: ref gf} => (g, f, gf),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (h, hgf) = match *__v2{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: ref h, f: _, gf: ref hgf} => (h, hgf),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS((f.clone(), g.clone(), h.clone(), hgf.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange Comp(.g=g, .f=f, .gf=gf), Comp(.g=h, .f=gf, .gf=hgf) by (h, g)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (f, g, h, hgf) = match __v {
                                                                      Value::tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                          match *__box {
                                                                              (ref f, ref g, ref h, ref hgf) => (f, g, h, hgf),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__CtxMorphS_CtxMorphS((h.clone(), g.clone())), Value::tuple2__CtxMorphS_CtxMorphS((f.clone(), hgf.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "Comp(.g=g, .f=f, .gf=gf), Comp(.g=h, .f=gf, .gf=hgf), Comp(.g=h, .f=g, .gf=hg)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Comp as RelId,3),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let (f, hgf) = match *__v1 {
                                                                                         Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref f, ref hgf) => (f, hgf),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let hg = match *__v2{
                                                                                         Value::Comp(ref __box) => {
                                                                                             match *__box {
                                                                                             Comp{g: _, f: _, gf: ref hg} => hg,
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::Comp(Comp{g: hg.clone(), f: f.clone(), gf: hgf.clone()}))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(None)
                                                                             })
                                                          }))
                                  }
                       },
                       /* Comp(.g=h, .f=gf, .gf=hgf) :- Comp(.g=h, .f=g, .gf=hg), Comp(.g=hg, .f=f, .gf=hgf), Comp(.g=g, .f=f, .gf=gf). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=h, .f=gf, .gf=hgf) :- Comp(.g=h, .f=g, .gf=hg), Comp(.g=hg, .f=f, .gf=hgf), Comp(.g=g, .f=f, .gf=gf).".to_string(),
                           arr: ( Relations::Comp as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "Comp(.g=h, .f=g, .gf=hg), Comp(.g=hg, .f=f, .gf=hgf)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Comp as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (h, g, hg) = match *__v1{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: ref h, f: ref g, gf: ref hg} => (h, g, hg),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (f, hgf) = match *__v2{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: _, f: ref f, gf: ref hgf} => (f, hgf),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS((f.clone(), g.clone(), h.clone(), hgf.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange Comp(.g=h, .f=g, .gf=hg), Comp(.g=hg, .f=f, .gf=hgf) by (g, f)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (f, g, h, hgf) = match __v {
                                                                      Value::tuple4__CtxMorphS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                          match *__box {
                                                                              (ref f, ref g, ref h, ref hgf) => (f, g, h, hgf),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__CtxMorphS_CtxMorphS((g.clone(), f.clone())), Value::tuple2__CtxMorphS_CtxMorphS((h.clone(), hgf.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "Comp(.g=h, .f=g, .gf=hg), Comp(.g=hg, .f=f, .gf=hgf), Comp(.g=g, .f=f, .gf=gf)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Comp as RelId,3),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let (h, hgf) = match *__v1 {
                                                                                         Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref h, ref hgf) => (h, hgf),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let gf = match *__v2{
                                                                                         Value::Comp(ref __box) => {
                                                                                             match *__box {
                                                                                             Comp{g: _, f: _, gf: ref gf} => gf,
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::Comp(Comp{g: h.clone(), f: gf.clone(), gf: hgf.clone()}))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(None)
                                                                             })
                                                          }))
                                  }
                       },
                       /* Comp(.g=p, .f=e, .gf=f) :- ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C), Extension(.f=f, .tm=_M, .e=e), CtxMorph(.f=e, .from=_A, .to=_B). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=p, .f=e, .gf=f) :- ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C), Extension(.f=f, .tm=_M, .e=e), CtxMorph(.f=e, .from=_A, .to=_B).".to_string(),
                           arr: ( Relations::ProjCtx as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::CtxMorph as RelId,3),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_G, s, p) = match *__v1{
                                              Value::ProjCtx(ref __box) => {
                                                  match *__box {
                                                  ProjCtx{ctx: ref _G, ty: ref s, f: ref p} => (_G, s, p),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (_B, _C) = match *__v2{
                                              Value::CtxMorph(ref __box) => {
                                                  match *__box {
                                                  CtxMorph{f: _, from: ref _B, to: ref _C} => (_B, _C),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple2__CtxS_CtxMorphS((_B.clone(), p.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C) by ()" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_B, p) = match __v {
                                                                      Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _B, ref p) => (_B, p),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple0__(()), Value::tuple2__CtxS_CtxMorphS((_B.clone(), p.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C), Extension(.f=f, .tm=_M, .e=e)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::Extension as RelId,2),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let (_B, p) = match *__v1 {
                                                                                         Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref _B, ref p) => (_B, p),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let (f, _M, e) = match *__v2{
                                                                                         Value::Extension(ref __box) => {
                                                                                             match *__box {
                                                                                             Extension{f: ref f, tm: ref _M, e: ref e} => (f, _M, e),
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS((_B.clone(), e.clone(), f.clone(), p.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C), Extension(.f=f, .tm=_M, .e=e) by (e, _B)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (_B, e, f, p) = match __v {
                                                                                                                 Value::tuple4__CtxS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref _B, ref e, ref f, ref p) => (_B, e, f, p),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::tuple2__CtxMorphS_CtxS((e.clone(), _B.clone())), Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS((e.clone(), f.clone(), p.clone()))))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "ProjCtx(.ctx=_G, .ty=s, .f=p), CtxMorph(.f=p, .from=_B, .to=_C), Extension(.f=f, .tm=_M, .e=e), CtxMorph(.f=e, .from=_A, .to=_B)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::CtxMorph as RelId,4),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let (e, f, p) = match *__v1 {
                                                                                                                                    Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            (ref e, ref f, ref p) => (e, f, p),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let _A = match *__v2{
                                                                                                                                    Value::CtxMorph(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        CtxMorph{f: _, from: ref _A, to: _} => _A,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::Comp(Comp{g: p.clone(), f: e.clone(), gf: f.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       },
                       /* Comp(.g=es, .f=f, .gf=el) :- Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N), Extension(.f=gf, .tm=_N, .e=el). */
                       Rule::ArrangementRule {
                           description: "Comp(.g=es, .f=f, .gf=el) :- Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N), Extension(.f=gf, .tm=_N, .e=el).".to_string(),
                           arr: ( Relations::Extension as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Comp as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (g, _M, es) = match *__v1{
                                              Value::Extension(ref __box) => {
                                                  match *__box {
                                                  Extension{f: ref g, tm: ref _M, e: ref es} => (g, _M, es),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (f, gf) = match *__v2{
                                              Value::Comp(ref __box) => {
                                                  match *__box {
                                                  Comp{g: _, f: ref f, gf: ref gf} => (f, gf),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((_M.clone(), es.clone(), f.clone(), gf.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf) by (_M, f)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_M, es, f, gf) = match __v {
                                                                      Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _M, ref es, ref f, ref gf) => (_M, es, f, gf),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS((es.clone(), f.clone(), gf.clone()))))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::TmSubst as RelId,2),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let (es, f, gf) = match *__v1 {
                                                                                         Value::tuple3__CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                             match *__box {
                                                                                                 (ref es, ref f, ref gf) => (es, f, gf),
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let _N = match *__v2{
                                                                                         Value::TmSubst(ref __box) => {
                                                                                             match *__box {
                                                                                             TmSubst{tm: _, f: _, sub: ref _N} => _N,
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS((_N.clone(), es.clone(), f.clone(), gf.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N) by (gf, _N)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (_N, es, f, gf) = match __v {
                                                                                                                 Value::tuple4__TmS_CtxMorphS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref _N, ref es, ref f, ref gf) => (_N, es, f, gf),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::tuple2__CtxMorphS_TmS((gf.clone(), _N.clone())), Value::tuple2__CtxMorphS_CtxMorphS((es.clone(), f.clone()))))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "Extension(.f=g, .tm=_M, .e=es), Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=f, .sub=_N), Extension(.f=gf, .tm=_N, .e=el)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::Extension as RelId,3),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let (es, f) = match *__v1 {
                                                                                                                                    Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            (ref es, ref f) => (es, f),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let el = match *__v2{
                                                                                                                                    Value::Extension(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        Extension{f: _, tm: _, e: ref el} => el,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::Comp(Comp{g: es.clone(), f: f.clone(), gf: el.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"Comp{.g=_0, .f=_, .gf=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Comp(__box) = __v {
                                       match __box {
                                       Comp{g: ref _0, f: _, gf: _} => Some(Value::CtxMorphS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"Comp{.g=_, .f=_, .gf=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Comp(__box) = __v {
                                       match __box {
                                       Comp{g: _, f: _, gf: ref _0} => Some(Value::CtxMorphS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"Comp{.g=_, .f=_0, .gf=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Comp(__box) = __v {
                                       match __box {
                                       Comp{g: _, f: ref _0, gf: _} => Some(Value::CtxMorphS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"Comp{.g=_0, .f=_1, .gf=_}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Comp(__box) = __v {
                                       match __box {
                                       Comp{g: ref _0, f: ref _1, gf: _} => Some(Value::tuple2__CtxMorphS_CtxMorphS((_0.clone(), _1.clone()))),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let CtxMorphEq = Relation {
                         name:         "CtxMorphEq".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::CtxMorphEq as RelId,
                         rules:        vec![
                             /* CtxMorphEq(.l=l, .r=r) :- CtxMorphEqInput(.l=l, .r=r). */
                             Rule::CollectionRule {
                                 description: "CtxMorphEq(.l=l, .r=r) :- CtxMorphEqInput(.l=l, .r=r).".to_string(),
                                 rel: Relations::CtxMorphEqInput as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of CtxMorphEq(.l=l, .r=r) :- CtxMorphEqInput(.l=l, .r=r)." .to_string(),
                                                 fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                 {
                                                     let (l, r) = match __v{
                                                         Value::CtxMorphEqInput(ref __box) => {
                                                             match *__box {
                                                             CtxMorphEqInput{l: ref l, r: ref r} => (l, r),
                                                             _ => return None
                                                             }
                                                         },
                                                         _ => return None
                                                     };
                                                     Some(Value::CtxMorphEq(CtxMorphEq{l: l.clone(), r: r.clone()}))
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             },
                             /* CtxMorphEq(.l=f, .r=f) :- CtxMorph(.f=f, .from=_, .to=_). */
                             Rule::CollectionRule {
                                 description: "CtxMorphEq(.l=f, .r=f) :- CtxMorph(.f=f, .from=_, .to=_).".to_string(),
                                 rel: Relations::CtxMorph as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of CtxMorphEq(.l=f, .r=f) :- CtxMorph(.f=f, .from=_, .to=_)." .to_string(),
                                                 fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                 {
                                                     let f = match __v{
                                                         Value::CtxMorph(ref __box) => {
                                                             match *__box {
                                                             CtxMorph{f: ref f, from: _, to: _} => f,
                                                             _ => return None
                                                             }
                                                         },
                                                         _ => return None
                                                     };
                                                     Some(Value::CtxMorphEq(CtxMorphEq{l: f.clone(), r: f.clone()}))
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             },
                             /* CtxMorphEq(.l=l, .r=r) :- CtxMorphEq(.l=r, .r=l). */
                             Rule::CollectionRule {
                                 description: "CtxMorphEq(.l=l, .r=r) :- CtxMorphEq(.l=r, .r=l).".to_string(),
                                 rel: Relations::CtxMorphEq as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of CtxMorphEq(.l=l, .r=r) :- CtxMorphEq(.l=r, .r=l)." .to_string(),
                                                 fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                 {
                                                     let (r, l) = match __v{
                                                         Value::CtxMorphEq(ref __box) => {
                                                             match *__box {
                                                             CtxMorphEq{l: ref r, r: ref l} => (r, l),
                                                             _ => return None
                                                             }
                                                         },
                                                         _ => return None
                                                     };
                                                     Some(Value::CtxMorphEq(CtxMorphEq{l: l.clone(), r: r.clone()}))
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             },
                             /* CtxMorphEq(.l=a, .r=c) :- CtxMorphEq(.l=a, .r=b), CtxMorphEq(.l=b, .r=c). */
                             Rule::ArrangementRule {
                                 description: "CtxMorphEq(.l=a, .r=c) :- CtxMorphEq(.l=a, .r=b), CtxMorphEq(.l=b, .r=c).".to_string(),
                                 arr: ( Relations::CtxMorphEq as RelId, 1),
                                 xform: XFormArrangement::Join{
                                            description: "CtxMorphEq(.l=a, .r=b), CtxMorphEq(.l=b, .r=c)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::CtxMorphEq as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (a, b) = match *__v1{
                                                    Value::CtxMorphEq(ref __box) => {
                                                        match *__box {
                                                        CtxMorphEq{l: ref a, r: ref b} => (a, b),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let c = match *__v2{
                                                    Value::CtxMorphEq(ref __box) => {
                                                        match *__box {
                                                        CtxMorphEq{l: _, r: ref c} => c,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxMorphEq(CtxMorphEq{l: a.clone(), r: c.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             },
                             /* CtxMorphEq(.l=f, .r=g) :- IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_), IdMorph(.f=g), CtxMorph(.f=g, .from=_G, .to=_). */
                             Rule::ArrangementRule {
                                 description: "CtxMorphEq(.l=f, .r=g) :- IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_), IdMorph(.f=g), CtxMorph(.f=g, .from=_G, .to=_).".to_string(),
                                 arr: ( Relations::IdMorph as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::CtxMorph as RelId,3),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let f = match *__v1{
                                                    Value::IdMorph(ref __box) => {
                                                        match *__box {
                                                        IdMorph{f: ref f} => f,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let _G = match *__v2{
                                                    Value::CtxMorph(ref __box) => {
                                                        match *__box {
                                                        CtxMorph{f: _, from: ref _G, to: _} => _G,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__CtxS_CtxMorphS((_G.clone(), f.clone())))
                                            }
                                            __f},
                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                    description: "arrange IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_) by ()" .to_string(),
                                                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                    {
                                                                        let (_G, f) = match __v {
                                                                            Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                match *__box {
                                                                                    (ref _G, ref f) => (_G, f),
                                                                                    _ => unreachable!(),
                                                                                }
                                                                            },
                                                                            _ => unreachable!()
                                                                        };
                                                                        Some((Value::tuple0__(()), Value::tuple2__CtxS_CtxMorphS((_G.clone(), f.clone()))))
                                                                    }
                                                                    __f},
                                                                    next: Box::new(XFormArrangement::Join{
                                                                                       description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_), IdMorph(.f=g)".to_string(),
                                                                                       ffun: None,
                                                                                       arrangement: (Relations::IdMorph as RelId,1),
                                                                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                       {
                                                                                           let (_G, f) = match *__v1 {
                                                                                               Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                                   match *__box {
                                                                                                       (ref _G, ref f) => (_G, f),
                                                                                                       _ => unreachable!(),
                                                                                                   }
                                                                                               },
                                                                                               _ => unreachable!()
                                                                                           };
                                                                                           let g = match *__v2{
                                                                                               Value::IdMorph(ref __box) => {
                                                                                                   match *__box {
                                                                                                   IdMorph{f: ref g} => g,
                                                                                                   _ => return None
                                                                                                   }
                                                                                               },
                                                                                               _ => return None
                                                                                           };
                                                                                           Some(Value::tuple3__CtxS_CtxMorphS_CtxMorphS((_G.clone(), f.clone(), g.clone())))
                                                                                       }
                                                                                       __f},
                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                               description: "arrange IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_), IdMorph(.f=g) by (g, _G)" .to_string(),
                                                                                                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                               {
                                                                                                                   let (_G, f, g) = match __v {
                                                                                                                       Value::tuple3__CtxS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                           match *__box {
                                                                                                                               (ref _G, ref f, ref g) => (_G, f, g),
                                                                                                                               _ => unreachable!(),
                                                                                                                           }
                                                                                                                       },
                                                                                                                       _ => unreachable!()
                                                                                                                   };
                                                                                                                   Some((Value::tuple2__CtxMorphS_CtxS((g.clone(), _G.clone())), Value::tuple2__CtxMorphS_CtxMorphS((f.clone(), g.clone()))))
                                                                                                               }
                                                                                                               __f},
                                                                                                               next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                  description: "IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_), IdMorph(.f=g), CtxMorph(.f=g, .from=_G, .to=_)".to_string(),
                                                                                                                                  ffun: None,
                                                                                                                                  arrangement: (Relations::CtxMorph as RelId,5),
                                                                                                                                  jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                                  {
                                                                                                                                      let (f, g) = match *__v1 {
                                                                                                                                          Value::tuple2__CtxMorphS_CtxMorphS(ref __box) => {
                                                                                                                                              match *__box {
                                                                                                                                                  (ref f, ref g) => (f, g),
                                                                                                                                                  _ => unreachable!(),
                                                                                                                                              }
                                                                                                                                          },
                                                                                                                                          _ => unreachable!()
                                                                                                                                      };
                                                                                                                                      Some(Value::CtxMorphEq(CtxMorphEq{l: f.clone(), r: g.clone()}))
                                                                                                                                  }
                                                                                                                                  __f},
                                                                                                                                  next: Box::new(None)
                                                                                                                              })
                                                                                                           }))
                                                                                   })
                                                                }))
                                        }
                             },
                             /* CtxMorphEq(.l=f, .r=g) :- ProjCtx(.ctx=_G, .ty=s, .f=f), ProjCtx(.ctx=_G, .ty=s, .f=g). */
                             Rule::ArrangementRule {
                                 description: "CtxMorphEq(.l=f, .r=g) :- ProjCtx(.ctx=_G, .ty=s, .f=f), ProjCtx(.ctx=_G, .ty=s, .f=g).".to_string(),
                                 arr: ( Relations::ProjCtx as RelId, 1),
                                 xform: XFormArrangement::Join{
                                            description: "ProjCtx(.ctx=_G, .ty=s, .f=f), ProjCtx(.ctx=_G, .ty=s, .f=g)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::ProjCtx as RelId,1),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (_G, s, f) = match *__v1{
                                                    Value::ProjCtx(ref __box) => {
                                                        match *__box {
                                                        ProjCtx{ctx: ref _G, ty: ref s, f: ref f} => (_G, s, f),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let g = match *__v2{
                                                    Value::ProjCtx(ref __box) => {
                                                        match *__box {
                                                        ProjCtx{ctx: _, ty: _, f: ref g} => g,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxMorphEq(CtxMorphEq{l: f.clone(), r: g.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             },
                             /* CtxMorphEq(.l=g, .r=h) :- Extension(.f=f, .tm=_M, .e=g), Extension(.f=f, .tm=_M, .e=h). */
                             Rule::ArrangementRule {
                                 description: "CtxMorphEq(.l=g, .r=h) :- Extension(.f=f, .tm=_M, .e=g), Extension(.f=f, .tm=_M, .e=h).".to_string(),
                                 arr: ( Relations::Extension as RelId, 3),
                                 xform: XFormArrangement::Join{
                                            description: "Extension(.f=f, .tm=_M, .e=g), Extension(.f=f, .tm=_M, .e=h)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Extension as RelId,3),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (f, _M, g) = match *__v1{
                                                    Value::Extension(ref __box) => {
                                                        match *__box {
                                                        Extension{f: ref f, tm: ref _M, e: ref g} => (f, _M, g),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let h = match *__v2{
                                                    Value::Extension(ref __box) => {
                                                        match *__box {
                                                        Extension{f: _, tm: _, e: ref h} => h,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::CtxMorphEq(CtxMorphEq{l: g.clone(), r: h.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             },
                             /* CtxMorphEq(.l=f, .r=g) :- CtxEmpty(.ctx=_G), CtxMorph(.f=f, .from=_D, .to=_G), CtxMorph(.f=g, .from=_D, .to=_G). */
                             Rule::ArrangementRule {
                                 description: "CtxMorphEq(.l=f, .r=g) :- CtxEmpty(.ctx=_G), CtxMorph(.f=f, .from=_D, .to=_G), CtxMorph(.f=g, .from=_D, .to=_G).".to_string(),
                                 arr: ( Relations::CtxEmpty as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "CtxEmpty(.ctx=_G), CtxMorph(.f=f, .from=_D, .to=_G)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::CtxMorph as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let _G = match *__v1{
                                                    Value::CtxEmpty(ref __box) => {
                                                        match *__box {
                                                        CtxEmpty{ctx: ref _G} => _G,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let (f, _D) = match *__v2{
                                                    Value::CtxMorph(ref __box) => {
                                                        match *__box {
                                                        CtxMorph{f: ref f, from: ref _D, to: _} => (f, _D),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple3__CtxS_CtxS_CtxMorphS((_D.clone(), _G.clone(), f.clone())))
                                            }
                                            __f},
                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                    description: "arrange CtxEmpty(.ctx=_G), CtxMorph(.f=f, .from=_D, .to=_G) by (_D, _G)" .to_string(),
                                                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                    {
                                                                        let (_D, _G, f) = match __v {
                                                                            Value::tuple3__CtxS_CtxS_CtxMorphS(ref __box) => {
                                                                                match *__box {
                                                                                    (ref _D, ref _G, ref f) => (_D, _G, f),
                                                                                    _ => unreachable!(),
                                                                                }
                                                                            },
                                                                            _ => unreachable!()
                                                                        };
                                                                        Some((Value::tuple2__CtxS_CtxS((_D.clone(), _G.clone())), Value::CtxMorphS(f.clone())))
                                                                    }
                                                                    __f},
                                                                    next: Box::new(XFormArrangement::Join{
                                                                                       description: "CtxEmpty(.ctx=_G), CtxMorph(.f=f, .from=_D, .to=_G), CtxMorph(.f=g, .from=_D, .to=_G)".to_string(),
                                                                                       ffun: None,
                                                                                       arrangement: (Relations::CtxMorph as RelId,6),
                                                                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                       {
                                                                                           let f = match *__v1 {
                                                                                               Value::CtxMorphS(ref __box) => {
                                                                                                   match *__box {
                                                                                                       ref f => f,
                                                                                                       _ => unreachable!(),
                                                                                                   }
                                                                                               },
                                                                                               _ => unreachable!()
                                                                                           };
                                                                                           let g = match *__v2{
                                                                                               Value::CtxMorph(ref __box) => {
                                                                                                   match *__box {
                                                                                                   CtxMorph{f: ref g, from: _, to: _} => g,
                                                                                                   _ => return None
                                                                                                   }
                                                                                               },
                                                                                               _ => return None
                                                                                           };
                                                                                           Some(Value::CtxMorphEq(CtxMorphEq{l: f.clone(), r: g.clone()}))
                                                                                       }
                                                                                       __f},
                                                                                       next: Box::new(None)
                                                                                   })
                                                                }))
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"CtxMorphEq{.l=_0, .r=_}"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::CtxMorphEq(__box) = __v {
                                             match __box {
                                             CtxMorphEq{l: ref _0, r: _} => Some(Value::CtxMorphS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"CtxMorphEq{.l=_, .r=_0}"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::CtxMorphEq(__box) = __v {
                                             match __box {
                                             CtxMorphEq{l: _, r: ref _0} => Some(Value::CtxMorphS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                     };
    let CtxEmpty = Relation {
                       name:         "CtxEmpty".to_string(),
                       input:        false,
                       distinct:     false,
                       key_func:     None,
                       id:           Relations::CtxEmpty as RelId,
                       rules:        vec![
                           /* CtxEmpty(.ctx=ctx) :- CtxEmptyInput(.ctx=ctx). */
                           Rule::CollectionRule {
                               description: "CtxEmpty(.ctx=ctx) :- CtxEmptyInput(.ctx=ctx).".to_string(),
                               rel: Relations::CtxEmptyInput as RelId,
                               xform: Some(XFormCollection::FilterMap{
                                               description: "head of CtxEmpty(.ctx=ctx) :- CtxEmptyInput(.ctx=ctx)." .to_string(),
                                               fmfun: &{fn __f(__v: Value) -> Option<Value>
                                               {
                                                   let ctx = match __v{
                                                       Value::CtxEmptyInput(ref __box) => {
                                                           match *__box {
                                                           CtxEmptyInput{ctx: ref ctx} => ctx,
                                                           _ => return None
                                                           }
                                                       },
                                                       _ => return None
                                                   };
                                                   Some(Value::CtxEmpty(CtxEmpty{ctx: ctx.clone()}))
                                               }
                                               __f},
                                               next: Box::new(None)
                                           })
                           },
                           /* CtxEmpty(.ctx=_D) :- CtxEmpty(.ctx=_G), CtxEq(.l=_G, .r=_D). */
                           Rule::ArrangementRule {
                               description: "CtxEmpty(.ctx=_D) :- CtxEmpty(.ctx=_G), CtxEq(.l=_G, .r=_D).".to_string(),
                               arr: ( Relations::CtxEmpty as RelId, 0),
                               xform: XFormArrangement::Join{
                                          description: "CtxEmpty(.ctx=_G), CtxEq(.l=_G, .r=_D)".to_string(),
                                          ffun: None,
                                          arrangement: (Relations::CtxEq as RelId,0),
                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                          {
                                              let _G = match *__v1{
                                                  Value::CtxEmpty(ref __box) => {
                                                      match *__box {
                                                      CtxEmpty{ctx: ref _G} => _G,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              let _D = match *__v2{
                                                  Value::CtxEq(ref __box) => {
                                                      match *__box {
                                                      CtxEq{l: _, r: ref _D} => _D,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::CtxEmpty(CtxEmpty{ctx: _D.clone()}))
                                          }
                                          __f},
                                          next: Box::new(None)
                                      }
                           }],
                       arrangements: vec![
                           Arrangement::Map{
                              name: r###"CtxEmpty{.ctx=_0}"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxEmpty(__box) = __v {
                                           match __box {
                                           CtxEmpty{ctx: ref _0} => Some(Value::CtxS(_0.clone())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           },
                           Arrangement::Map{
                              name: r###"_"###.to_string(),
                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                               {
                                   let __cloned = __v.clone();
                                   {
                                       if let Value::CtxEmpty(__box) = __v {
                                           match __box {
                                           _ => Some(Value::tuple0__(())),
                                           _ => None
                                           }
                                       } else { None }
                                   }.map(|x|(x,__cloned))
                               }
                               __f},
                               queryable: false
                           }],
                       change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                   };
    let IdMorph = Relation {
                      name:         "IdMorph".to_string(),
                      input:        false,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::IdMorph as RelId,
                      rules:        vec![
                          /* IdMorph(.f=f) :- IdMorphInput(.f=f). */
                          Rule::CollectionRule {
                              description: "IdMorph(.f=f) :- IdMorphInput(.f=f).".to_string(),
                              rel: Relations::IdMorphInput as RelId,
                              xform: Some(XFormCollection::FilterMap{
                                              description: "head of IdMorph(.f=f) :- IdMorphInput(.f=f)." .to_string(),
                                              fmfun: &{fn __f(__v: Value) -> Option<Value>
                                              {
                                                  let f = match __v{
                                                      Value::IdMorphInput(ref __box) => {
                                                          match *__box {
                                                          IdMorphInput{f: ref f} => f,
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  Some(Value::IdMorph(IdMorph{f: f.clone()}))
                                              }
                                              __f},
                                              next: Box::new(None)
                                          })
                          },
                          /* IdMorph(.f=g) :- IdMorph(.f=f), CtxMorphEq(.l=f, .r=g). */
                          Rule::ArrangementRule {
                              description: "IdMorph(.f=g) :- IdMorph(.f=f), CtxMorphEq(.l=f, .r=g).".to_string(),
                              arr: ( Relations::IdMorph as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "IdMorph(.f=f), CtxMorphEq(.l=f, .r=g)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::CtxMorphEq as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let f = match *__v1{
                                                 Value::IdMorph(ref __box) => {
                                                     match *__box {
                                                     IdMorph{f: ref f} => f,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let g = match *__v2{
                                                 Value::CtxMorphEq(ref __box) => {
                                                     match *__box {
                                                     CtxMorphEq{l: _, r: ref g} => g,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::IdMorph(IdMorph{f: g.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          },
                          /* IdMorph(.f=e) :- __Prefix_3[(_G, _M, p, s)], Extension(.f=p, .tm=_M, .e=e). */
                          Rule::ArrangementRule {
                              description: "IdMorph(.f=e) :- __Prefix_3[(_G, _M, p, s)], Extension(.f=p, .tm=_M, .e=e).".to_string(),
                              arr: ( Relations::__Prefix_3 as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_3[(_G, _M, p, s)], Extension(.f=p, .tm=_M, .e=e)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Extension as RelId,3),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_G, _M, p, s) = match *__v1{
                                                 Value::tuple4__CtxS_TmS_CtxMorphS_TyS(ref __box) => {
                                                     match *__box {
                                                     (ref _G, ref _M, ref p, ref s) => (_G, _M, p, s),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let e = match *__v2{
                                                 Value::Extension(ref __box) => {
                                                     match *__box {
                                                     Extension{f: _, tm: _, e: ref e} => e,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::IdMorph(IdMorph{f: e.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          }],
                      arrangements: vec![
                          Arrangement::Map{
                             name: r###"IdMorph{.f=_0}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::IdMorph(__box) = __v {
                                          match __box {
                                          IdMorph{f: ref _0} => Some(Value::CtxMorphS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"_"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::IdMorph(__box) = __v {
                                          match __box {
                                          _ => Some(Value::tuple0__(())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          }],
                      change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                  };
    let __Prefix_3 = Relation {
                         name:         "__Prefix_3".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_3 as RelId,
                         rules:        vec![
                             /* __Prefix_3[(_G, _M, p, s)] :- ProjCtx(.ctx=_G, .ty=s, .f=p), ProjTm(.ctx=_G, .ty=s, .tm=_M). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_3[(_G, _M, p, s)] :- ProjCtx(.ctx=_G, .ty=s, .f=p), ProjTm(.ctx=_G, .ty=s, .tm=_M).".to_string(),
                                 arr: ( Relations::ProjCtx as RelId, 1),
                                 xform: XFormArrangement::Join{
                                            description: "ProjCtx(.ctx=_G, .ty=s, .f=p), ProjTm(.ctx=_G, .ty=s, .tm=_M)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::ProjTm as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (_G, s, p) = match *__v1{
                                                    Value::ProjCtx(ref __box) => {
                                                        match *__box {
                                                        ProjCtx{ctx: ref _G, ty: ref s, f: ref p} => (_G, s, p),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let _M = match *__v2{
                                                    Value::ProjTm(ref __box) => {
                                                        match *__box {
                                                        ProjTm{ctx: _, ty: _, tm: ref _M} => _M,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple4__CtxS_TmS_CtxMorphS_TyS((_G.clone(), _M.clone(), p.clone(), s.clone())))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _, _0, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple4__CtxS_TmS_CtxMorphS_TyS(__box) = __v {
                                             match __box {
                                             (_, _, ref _0, _) => Some(Value::CtxMorphS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"(_, _1, _0, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple4__CtxS_TmS_CtxMorphS_TyS(__box) = __v {
                                             match __box {
                                             (_, ref _1, ref _0, _) => Some(Value::tuple2__CtxMorphS_TmS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let ProjCtx = Relation {
                      name:         "ProjCtx".to_string(),
                      input:        false,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::ProjCtx as RelId,
                      rules:        vec![
                          /* ProjCtx(.ctx=ctx, .ty=ty, .f=f) :- ProjCtxInput(.ctx=ctx, .ty=ty, .f=f). */
                          Rule::CollectionRule {
                              description: "ProjCtx(.ctx=ctx, .ty=ty, .f=f) :- ProjCtxInput(.ctx=ctx, .ty=ty, .f=f).".to_string(),
                              rel: Relations::ProjCtxInput as RelId,
                              xform: Some(XFormCollection::FilterMap{
                                              description: "head of ProjCtx(.ctx=ctx, .ty=ty, .f=f) :- ProjCtxInput(.ctx=ctx, .ty=ty, .f=f)." .to_string(),
                                              fmfun: &{fn __f(__v: Value) -> Option<Value>
                                              {
                                                  let (ctx, ty, f) = match __v{
                                                      Value::ProjCtxInput(ref __box) => {
                                                          match *__box {
                                                          ProjCtxInput{ctx: ref ctx, ty: ref ty, f: ref f} => (ctx, ty, f),
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  Some(Value::ProjCtx(ProjCtx{ctx: ctx.clone(), ty: ty.clone(), f: f.clone()}))
                                              }
                                              __f},
                                              next: Box::new(None)
                                          })
                          },
                          /* ProjCtx(.ctx=_D, .ty=t, .f=g) :- ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxMorphEq(.l=f, .r=g). */
                          Rule::ArrangementRule {
                              description: "ProjCtx(.ctx=_D, .ty=t, .f=g) :- ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxMorphEq(.l=f, .r=g).".to_string(),
                              arr: ( Relations::ProjCtx as RelId, 3),
                              xform: XFormArrangement::Join{
                                         description: "ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::CtxEq as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_G, s, f) = match *__v1{
                                                 Value::ProjCtx(ref __box) => {
                                                     match *__box {
                                                     ProjCtx{ctx: ref _G, ty: ref s, f: ref f} => (_G, s, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _D = match *__v2{
                                                 Value::CtxEq(ref __box) => {
                                                     match *__box {
                                                     CtxEq{l: _, r: ref _D} => _D,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple3__CtxS_CtxMorphS_TyS((_D.clone(), f.clone(), s.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D) by (s)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_D, f, s) = match __v {
                                                                         Value::tuple3__CtxS_CtxMorphS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _D, ref f, ref s) => (_D, f, s),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::TyS(s.clone()), Value::tuple2__CtxS_CtxMorphS((_D.clone(), f.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::TyEq as RelId,0),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_D, f) = match *__v1 {
                                                                                            Value::tuple2__CtxS_CtxMorphS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _D, ref f) => (_D, f),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let t = match *__v2{
                                                                                            Value::TyEq(ref __box) => {
                                                                                                match *__box {
                                                                                                TyEq{l: _, r: ref t} => t,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__CtxS_CtxMorphS_TyS((_D.clone(), f.clone(), t.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t) by (f)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_D, f, t) = match __v {
                                                                                                                    Value::tuple3__CtxS_CtxMorphS_TyS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _D, ref f, ref t) => (_D, f, t),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::CtxMorphS(f.clone()), Value::tuple2__CtxS_TyS((_D.clone(), t.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "ProjCtx(.ctx=_G, .ty=s, .f=f), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), CtxMorphEq(.l=f, .r=g)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_D, t) = match *__v1 {
                                                                                                                                       Value::tuple2__CtxS_TyS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _D, ref t) => (_D, t),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let g = match *__v2{
                                                                                                                                       Value::CtxMorphEq(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           CtxMorphEq{l: _, r: ref g} => g,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::ProjCtx(ProjCtx{ctx: _D.clone(), ty: t.clone(), f: g.clone()}))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(None)
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          }],
                      arrangements: vec![
                          Arrangement::Map{
                             name: r###"ProjCtx{.ctx=_, .ty=_, .f=_0}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::ProjCtx(__box) = __v {
                                          match __box {
                                          ProjCtx{ctx: _, ty: _, f: ref _0} => Some(Value::CtxMorphS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"ProjCtx{.ctx=_0, .ty=_1, .f=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::ProjCtx(__box) = __v {
                                          match __box {
                                          ProjCtx{ctx: ref _0, ty: ref _1, f: _} => Some(Value::tuple2__CtxS_TyS((_0.clone(), _1.clone()))),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"_"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::ProjCtx(__box) = __v {
                                          match __box {
                                          _ => Some(Value::tuple0__(())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"ProjCtx{.ctx=_0, .ty=_, .f=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::ProjCtx(__box) = __v {
                                          match __box {
                                          ProjCtx{ctx: ref _0, ty: _, f: _} => Some(Value::CtxS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          }],
                      change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                  };
    let ProjTm = Relation {
                     name:         "ProjTm".to_string(),
                     input:        false,
                     distinct:     false,
                     key_func:     None,
                     id:           Relations::ProjTm as RelId,
                     rules:        vec![
                         /* ProjTm(.ctx=ctx, .ty=ty, .tm=tm) :- ProjTmInput(.ctx=ctx, .ty=ty, .tm=tm). */
                         Rule::CollectionRule {
                             description: "ProjTm(.ctx=ctx, .ty=ty, .tm=tm) :- ProjTmInput(.ctx=ctx, .ty=ty, .tm=tm).".to_string(),
                             rel: Relations::ProjTmInput as RelId,
                             xform: Some(XFormCollection::FilterMap{
                                             description: "head of ProjTm(.ctx=ctx, .ty=ty, .tm=tm) :- ProjTmInput(.ctx=ctx, .ty=ty, .tm=tm)." .to_string(),
                                             fmfun: &{fn __f(__v: Value) -> Option<Value>
                                             {
                                                 let (ctx, ty, tm) = match __v{
                                                     Value::ProjTmInput(ref __box) => {
                                                         match *__box {
                                                         ProjTmInput{ctx: ref ctx, ty: ref ty, tm: ref tm} => (ctx, ty, tm),
                                                         _ => return None
                                                         }
                                                     },
                                                     _ => return None
                                                 };
                                                 Some(Value::ProjTm(ProjTm{ctx: ctx.clone(), ty: ty.clone(), tm: tm.clone()}))
                                             }
                                             __f},
                                             next: Box::new(None)
                                         })
                         },
                         /* ProjTm(.ctx=_D, .ty=t, .tm=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), TmEq(.l=_M, .r=_N). */
                         Rule::ArrangementRule {
                             description: "ProjTm(.ctx=_D, .ty=t, .tm=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), TmEq(.l=_M, .r=_N).".to_string(),
                             arr: ( Relations::ProjTm as RelId, 1),
                             xform: XFormArrangement::Join{
                                        description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D)".to_string(),
                                        ffun: None,
                                        arrangement: (Relations::CtxEq as RelId,0),
                                        jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                        {
                                            let (_G, s, _M) = match *__v1{
                                                Value::ProjTm(ref __box) => {
                                                    match *__box {
                                                    ProjTm{ctx: ref _G, ty: ref s, tm: ref _M} => (_G, s, _M),
                                                    _ => return None
                                                    }
                                                },
                                                _ => return None
                                            };
                                            let _D = match *__v2{
                                                Value::CtxEq(ref __box) => {
                                                    match *__box {
                                                    CtxEq{l: _, r: ref _D} => _D,
                                                    _ => return None
                                                    }
                                                },
                                                _ => return None
                                            };
                                            Some(Value::tuple3__CtxS_TmS_TyS((_D.clone(), _M.clone(), s.clone())))
                                        }
                                        __f},
                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                description: "arrange ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D) by (s)" .to_string(),
                                                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                {
                                                                    let (_D, _M, s) = match __v {
                                                                        Value::tuple3__CtxS_TmS_TyS(ref __box) => {
                                                                            match *__box {
                                                                                (ref _D, ref _M, ref s) => (_D, _M, s),
                                                                                _ => unreachable!(),
                                                                            }
                                                                        },
                                                                        _ => unreachable!()
                                                                    };
                                                                    Some((Value::TyS(s.clone()), Value::tuple2__CtxS_TmS((_D.clone(), _M.clone()))))
                                                                }
                                                                __f},
                                                                next: Box::new(XFormArrangement::Join{
                                                                                   description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t)".to_string(),
                                                                                   ffun: None,
                                                                                   arrangement: (Relations::TyEq as RelId,0),
                                                                                   jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                   {
                                                                                       let (_D, _M) = match *__v1 {
                                                                                           Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                               match *__box {
                                                                                                   (ref _D, ref _M) => (_D, _M),
                                                                                                   _ => unreachable!(),
                                                                                               }
                                                                                           },
                                                                                           _ => unreachable!()
                                                                                       };
                                                                                       let t = match *__v2{
                                                                                           Value::TyEq(ref __box) => {
                                                                                               match *__box {
                                                                                               TyEq{l: _, r: ref t} => t,
                                                                                               _ => return None
                                                                                               }
                                                                                           },
                                                                                           _ => return None
                                                                                       };
                                                                                       Some(Value::tuple3__CtxS_TmS_TyS((_D.clone(), _M.clone(), t.clone())))
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(Some(XFormCollection::Arrange {
                                                                                                           description: "arrange ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t) by (_M)" .to_string(),
                                                                                                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                           {
                                                                                                               let (_D, _M, t) = match __v {
                                                                                                                   Value::tuple3__CtxS_TmS_TyS(ref __box) => {
                                                                                                                       match *__box {
                                                                                                                           (ref _D, ref _M, ref t) => (_D, _M, t),
                                                                                                                           _ => unreachable!(),
                                                                                                                       }
                                                                                                                   },
                                                                                                                   _ => unreachable!()
                                                                                                               };
                                                                                                               Some((Value::TmS(_M.clone()), Value::tuple2__CtxS_TyS((_D.clone(), t.clone()))))
                                                                                                           }
                                                                                                           __f},
                                                                                                           next: Box::new(XFormArrangement::Join{
                                                                                                                              description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), CtxEq(.l=_G, .r=_D), TyEq(.l=s, .r=t), TmEq(.l=_M, .r=_N)".to_string(),
                                                                                                                              ffun: None,
                                                                                                                              arrangement: (Relations::TmEq as RelId,0),
                                                                                                                              jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                              {
                                                                                                                                  let (_D, t) = match *__v1 {
                                                                                                                                      Value::tuple2__CtxS_TyS(ref __box) => {
                                                                                                                                          match *__box {
                                                                                                                                              (ref _D, ref t) => (_D, t),
                                                                                                                                              _ => unreachable!(),
                                                                                                                                          }
                                                                                                                                      },
                                                                                                                                      _ => unreachable!()
                                                                                                                                  };
                                                                                                                                  let _N = match *__v2{
                                                                                                                                      Value::TmEq(ref __box) => {
                                                                                                                                          match *__box {
                                                                                                                                          TmEq{l: _, r: ref _N} => _N,
                                                                                                                                          _ => return None
                                                                                                                                          }
                                                                                                                                      },
                                                                                                                                      _ => return None
                                                                                                                                  };
                                                                                                                                  Some(Value::ProjTm(ProjTm{ctx: _D.clone(), ty: t.clone(), tm: _N.clone()}))
                                                                                                                              }
                                                                                                                              __f},
                                                                                                                              next: Box::new(None)
                                                                                                                          })
                                                                                                       }))
                                                                               })
                                                            }))
                                    }
                         }],
                     arrangements: vec![
                         Arrangement::Map{
                            name: r###"ProjTm{.ctx=_0, .ty=_1, .tm=_}"###.to_string(),
                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                             {
                                 let __cloned = __v.clone();
                                 {
                                     if let Value::ProjTm(__box) = __v {
                                         match __box {
                                         ProjTm{ctx: ref _0, ty: ref _1, tm: _} => Some(Value::tuple2__CtxS_TyS((_0.clone(), _1.clone()))),
                                         _ => None
                                         }
                                     } else { None }
                                 }.map(|x|(x,__cloned))
                             }
                             __f},
                             queryable: false
                         },
                         Arrangement::Map{
                            name: r###"ProjTm{.ctx=_0, .ty=_, .tm=_}"###.to_string(),
                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                             {
                                 let __cloned = __v.clone();
                                 {
                                     if let Value::ProjTm(__box) = __v {
                                         match __box {
                                         ProjTm{ctx: ref _0, ty: _, tm: _} => Some(Value::CtxS(_0.clone())),
                                         _ => None
                                         }
                                     } else { None }
                                 }.map(|x|(x,__cloned))
                             }
                             __f},
                             queryable: false
                         },
                         Arrangement::Map{
                            name: r###"ProjTm{.ctx=_, .ty=_, .tm=_0}"###.to_string(),
                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                             {
                                 let __cloned = __v.clone();
                                 {
                                     if let Value::ProjTm(__box) = __v {
                                         match __box {
                                         ProjTm{ctx: _, ty: _, tm: ref _0} => Some(Value::TmS(_0.clone())),
                                         _ => None
                                         }
                                     } else { None }
                                 }.map(|x|(x,__cloned))
                             }
                             __f},
                             queryable: false
                         }],
                     change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                 };
    let TmSubst = Relation {
                      name:         "TmSubst".to_string(),
                      input:        false,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::TmSubst as RelId,
                      rules:        vec![
                          /* TmSubst(.tm=tm, .f=f, .sub=sub) :- TmSubstInput(.tm=tm, .f=f, .sub=sub). */
                          Rule::CollectionRule {
                              description: "TmSubst(.tm=tm, .f=f, .sub=sub) :- TmSubstInput(.tm=tm, .f=f, .sub=sub).".to_string(),
                              rel: Relations::TmSubstInput as RelId,
                              xform: Some(XFormCollection::FilterMap{
                                              description: "head of TmSubst(.tm=tm, .f=f, .sub=sub) :- TmSubstInput(.tm=tm, .f=f, .sub=sub)." .to_string(),
                                              fmfun: &{fn __f(__v: Value) -> Option<Value>
                                              {
                                                  let (tm, f, sub) = match __v{
                                                      Value::TmSubstInput(ref __box) => {
                                                          match *__box {
                                                          TmSubstInput{tm: ref tm, f: ref f, sub: ref sub} => (tm, f, sub),
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  Some(Value::TmSubst(TmSubst{tm: tm.clone(), f: f.clone(), sub: sub.clone()}))
                                              }
                                              __f},
                                              next: Box::new(None)
                                          })
                          },
                          /* TmSubst(.tm=_O, .f=g, .sub=_P) :- TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O), CtxMorphEq(.l=f, .r=g), TmEq(.l=_N, .r=_P). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_O, .f=g, .sub=_P) :- TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O), CtxMorphEq(.l=f, .r=g), TmEq(.l=_N, .r=_P).".to_string(),
                              arr: ( Relations::TmSubst as RelId, 3),
                              xform: XFormArrangement::Join{
                                         description: "TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmEq as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, f, _N) = match *__v1{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _M, f: ref f, sub: ref _N} => (_M, f, _N),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _O = match *__v2{
                                                 Value::TmEq(ref __box) => {
                                                     match *__box {
                                                     TmEq{l: _, r: ref _O} => _O,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple3__TmS_TmS_CtxMorphS((_N.clone(), _O.clone(), f.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O) by (f)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_N, _O, f) = match __v {
                                                                         Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _N, ref _O, ref f) => (_N, _O, f),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::CtxMorphS(f.clone()), Value::tuple2__TmS_TmS((_N.clone(), _O.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O), CtxMorphEq(.l=f, .r=g)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_N, _O) = match *__v1 {
                                                                                            Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _N, ref _O) => (_N, _O),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let g = match *__v2{
                                                                                            Value::CtxMorphEq(ref __box) => {
                                                                                                match *__box {
                                                                                                CtxMorphEq{l: _, r: ref g} => g,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__TmS_TmS_CtxMorphS((_N.clone(), _O.clone(), g.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O), CtxMorphEq(.l=f, .r=g) by (_N)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_N, _O, g) = match __v {
                                                                                                                    Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _N, ref _O, ref g) => (_N, _O, g),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::TmS(_N.clone()), Value::tuple2__TmS_CtxMorphS((_O.clone(), g.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "TmSubst(.tm=_M, .f=f, .sub=_N), TmEq(.l=_M, .r=_O), CtxMorphEq(.l=f, .r=g), TmEq(.l=_N, .r=_P)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::TmEq as RelId,0),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_O, g) = match *__v1 {
                                                                                                                                       Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _O, ref g) => (_O, g),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let _P = match *__v2{
                                                                                                                                       Value::TmEq(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           TmEq{l: _, r: ref _P} => _P,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::TmSubst(TmSubst{tm: _O.clone(), f: g.clone(), sub: _P.clone()}))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(None)
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_M, .f=f, .sub=_M) :- Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_M, .f=f, .sub=_M) :- Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G).".to_string(),
                              arr: ( Relations::Tm as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Ty as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, s) = match *__v1{
                                                 Value::Tm(ref __box) => {
                                                     match *__box {
                                                     Tm{tm: ref _M, ty: ref s} => (_M, s),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _G = match *__v2{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: _, ctx: ref _G} => _G,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple2__CtxS_TmS((_G.clone(), _M.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G) by ()" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_G, _M) = match __v {
                                                                         Value::tuple2__CtxS_TmS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _G, ref _M) => (_G, _M),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple0__(()), Value::tuple2__CtxS_TmS((_G.clone(), _M.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G), IdMorph(.f=f)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::IdMorph as RelId,1),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_G, _M) = match *__v1 {
                                                                                            Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _G, ref _M) => (_G, _M),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let f = match *__v2{
                                                                                            Value::IdMorph(ref __box) => {
                                                                                                match *__box {
                                                                                                IdMorph{f: ref f} => f,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__CtxS_TmS_CtxMorphS((_G.clone(), _M.clone(), f.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G), IdMorph(.f=f) by (f, _G, _G)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_G, _M, f) = match __v {
                                                                                                                    Value::tuple3__CtxS_TmS_CtxMorphS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _G, ref _M, ref f) => (_G, _M, f),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::tuple3__CtxMorphS_CtxS_CtxS((f.clone(), _G.clone(), _G.clone())), Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Semijoin{
                                                                                                                               description: "Tm(.tm=_M, .ty=s), Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::CtxMorph as RelId,7),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_M, f) = match *__v1 {
                                                                                                                                       Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _M, ref f) => (_M, f),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   Some(Value::TmSubst(TmSubst{tm: _M.clone(), f: f.clone(), sub: _M.clone()}))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(None)
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_O, .f=f, .sub=_N) :- Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=gf, .sub=_N), TmSubst(.tm=_M, .f=g, .sub=_O). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_O, .f=f, .sub=_N) :- Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=gf, .sub=_N), TmSubst(.tm=_M, .f=g, .sub=_O).".to_string(),
                              arr: ( Relations::Comp as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=gf, .sub=_N)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (g, f, gf) = match *__v1{
                                                 Value::Comp(ref __box) => {
                                                     match *__box {
                                                     Comp{g: ref g, f: ref f, gf: ref gf} => (g, f, gf),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (_M, _N) = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _M, f: _, sub: ref _N} => (_M, _N),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS((_M.clone(), _N.clone(), f.clone(), g.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=gf, .sub=_N) by (_M, g)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_M, _N, f, g) = match __v {
                                                                         Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _M, ref _N, ref f, ref g) => (_M, _N, f, g),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), g.clone())), Value::tuple2__TmS_CtxMorphS((_N.clone(), f.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "Comp(.g=g, .f=f, .gf=gf), TmSubst(.tm=_M, .f=gf, .sub=_N), TmSubst(.tm=_M, .f=g, .sub=_O)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::TmSubst as RelId,2),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_N, f) = match *__v1 {
                                                                                            Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _N, ref f) => (_N, f),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _O = match *__v2{
                                                                                            Value::TmSubst(ref __box) => {
                                                                                                match *__box {
                                                                                                TmSubst{tm: _, f: _, sub: ref _O} => _O,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::TmSubst(TmSubst{tm: _O.clone(), f: f.clone(), sub: _N.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_M, .f=gf, .sub=_O) :- TmSubst(.tm=_M, .f=g, .sub=_N), TmSubst(.tm=_N, .f=f, .sub=_O), Comp(.g=g, .f=f, .gf=gf). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_M, .f=gf, .sub=_O) :- TmSubst(.tm=_M, .f=g, .sub=_N), TmSubst(.tm=_N, .f=f, .sub=_O), Comp(.g=g, .f=f, .gf=gf).".to_string(),
                              arr: ( Relations::TmSubst as RelId, 4),
                              xform: XFormArrangement::Join{
                                         description: "TmSubst(.tm=_M, .f=g, .sub=_N), TmSubst(.tm=_N, .f=f, .sub=_O)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,3),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, g, _N) = match *__v1{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _M, f: ref g, sub: ref _N} => (_M, g, _N),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (f, _O) = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: _, f: ref f, sub: ref _O} => (f, _O),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS((_M.clone(), _O.clone(), f.clone(), g.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange TmSubst(.tm=_M, .f=g, .sub=_N), TmSubst(.tm=_N, .f=f, .sub=_O) by (g, f)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_M, _O, f, g) = match __v {
                                                                         Value::tuple4__TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _M, ref _O, ref f, ref g) => (_M, _O, f, g),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__CtxMorphS_CtxMorphS((g.clone(), f.clone())), Value::tuple2__TmS_TmS((_M.clone(), _O.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "TmSubst(.tm=_M, .f=g, .sub=_N), TmSubst(.tm=_N, .f=f, .sub=_O), Comp(.g=g, .f=f, .gf=gf)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::Comp as RelId,3),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_M, _O) = match *__v1 {
                                                                                            Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _M, ref _O) => (_M, _O),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let gf = match *__v2{
                                                                                            Value::Comp(ref __box) => {
                                                                                                match *__box {
                                                                                                Comp{g: _, f: _, gf: ref gf} => gf,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::TmSubst(TmSubst{tm: _M.clone(), f: gf.clone(), sub: _O.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_M, .f=e, .sub=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D), Extension(.f=f, .tm=_N, .e=e), CtxMorph(.f=e, .from=_, .to=_D). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_M, .f=e, .sub=_N) :- ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D), Extension(.f=f, .tm=_N, .e=e), CtxMorph(.f=e, .from=_, .to=_D).".to_string(),
                              arr: ( Relations::ProjTm as RelId, 2),
                              xform: XFormArrangement::Join{
                                         description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Tm as RelId,1),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_G, s, _M) = match *__v1{
                                                 Value::ProjTm(ref __box) => {
                                                     match *__box {
                                                     ProjTm{ctx: ref _G, ty: ref s, tm: ref _M} => (_G, s, _M),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let t = match *__v2{
                                                 Value::Tm(ref __box) => {
                                                     match *__box {
                                                     Tm{tm: _, ty: ref t} => t,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple2__TmS_TyS((_M.clone(), t.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t) by (t)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_M, t) = match __v {
                                                                         Value::tuple2__TmS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _M, ref t) => (_M, t),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::TyS(t.clone()), Value::TmS(_M.clone())))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::Ty as RelId,0),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let _M = match *__v1 {
                                                                                            Value::TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    ref _M => _M,
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _D = match *__v2{
                                                                                            Value::Ty(ref __box) => {
                                                                                                match *__box {
                                                                                                Ty{ty: _, ctx: ref _D} => _D,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple2__CtxS_TmS((_D.clone(), _M.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D) by ()" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_D, _M) = match __v {
                                                                                                                    Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _D, ref _M) => (_D, _M),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::tuple0__(()), Value::tuple2__CtxS_TmS((_D.clone(), _M.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D), Extension(.f=f, .tm=_N, .e=e)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::Extension as RelId,2),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_D, _M) = match *__v1 {
                                                                                                                                       Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _D, ref _M) => (_D, _M),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let (f, _N, e) = match *__v2{
                                                                                                                                       Value::Extension(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           Extension{f: ref f, tm: ref _N, e: ref e} => (f, _N, e),
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::tuple4__CtxS_TmS_TmS_CtxMorphS((_D.clone(), _M.clone(), _N.clone(), e.clone())))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                       description: "arrange ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D), Extension(.f=f, .tm=_N, .e=e) by (e, _D)" .to_string(),
                                                                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                       {
                                                                                                                                                           let (_D, _M, _N, e) = match __v {
                                                                                                                                                               Value::tuple4__CtxS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                   match *__box {
                                                                                                                                                                       (ref _D, ref _M, ref _N, ref e) => (_D, _M, _N, e),
                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                   }
                                                                                                                                                               },
                                                                                                                                                               _ => unreachable!()
                                                                                                                                                           };
                                                                                                                                                           Some((Value::tuple2__CtxMorphS_CtxS((e.clone(), _D.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), e.clone()))))
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                          description: "ProjTm(.ctx=_G, .ty=s, .tm=_M), Tm(.tm=_M, .ty=t), Ty(.ty=t, .ctx=_D), Extension(.f=f, .tm=_N, .e=e), CtxMorph(.f=e, .from=_, .to=_D)".to_string(),
                                                                                                                                                                          ffun: None,
                                                                                                                                                                          arrangement: (Relations::CtxMorph as RelId,4),
                                                                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                          {
                                                                                                                                                                              let (_M, _N, e) = match *__v1 {
                                                                                                                                                                                  Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                          (ref _M, ref _N, ref e) => (_M, _N, e),
                                                                                                                                                                                          _ => unreachable!(),
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => unreachable!()
                                                                                                                                                                              };
                                                                                                                                                                              let () = match *__v2{
                                                                                                                                                                                  Value::CtxMorph(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                      CtxMorph{f: _, from: _, to: _} => (),
                                                                                                                                                                                      _ => return None
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => return None
                                                                                                                                                                              };
                                                                                                                                                                              Some(Value::TmSubst(TmSubst{tm: _M.clone(), f: e.clone(), sub: _N.clone()}))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(None)
                                                                                                                                                                      })
                                                                                                                                                   }))
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=t, .f=f, .sub=s). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=t, .f=f, .sub=s).".to_string(),
                              arr: ( Relations::__Prefix_7 as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Ty as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, s) = match *__v1{
                                                 Value::tuple2__TmS_TyS(ref __box) => {
                                                     match *__box {
                                                     (ref _M, ref s) => (_M, s),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _G = match *__v2{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: _, ctx: ref _G} => _G,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple3__CtxS_TmS_TyS((_G.clone(), _M.clone(), s.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G) by ()" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_G, _M, s) = match __v {
                                                                         Value::tuple3__CtxS_TmS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _G, ref _M, ref s) => (_G, _M, s),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple0__(()), Value::tuple3__CtxS_TmS_TyS((_G.clone(), _M.clone(), s.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::Refl as RelId,1),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_G, _M, s) = match *__v1 {
                                                                                            Value::tuple3__CtxS_TmS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _G, ref _M, ref s) => (_G, _M, s),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _N = match *__v2{
                                                                                            Value::Refl(ref __box) => {
                                                                                                match *__box {
                                                                                                Refl{tm: ref _N} => _N,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple4__CtxS_TmS_TmS_TyS((_G.clone(), _M.clone(), _N.clone(), s.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N) by (_N)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_G, _M, _N, s) = match __v {
                                                                                                                    Value::tuple4__CtxS_TmS_TmS_TyS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _G, ref _M, ref _N, ref s) => (_G, _M, _N, s),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::TmS(_N.clone()), Value::tuple4__CtxS_TmS_TmS_TyS((_G.clone(), _M.clone(), _N.clone(), s.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::Tm as RelId,1),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_G, _M, _N, s) = match *__v1 {
                                                                                                                                       Value::tuple4__CtxS_TmS_TmS_TyS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _G, ref _M, ref _N, ref s) => (_G, _M, _N, s),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let t = match *__v2{
                                                                                                                                       Value::Tm(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           Tm{tm: _, ty: ref t} => t,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::tuple5__CtxS_TmS_TmS_TyS_TyS(boxed::Box::new((_G.clone(), _M.clone(), _N.clone(), s.clone(), t.clone()))))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                       description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t) by (t)" .to_string(),
                                                                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                       {
                                                                                                                                                           let (_G, _M, _N, s, t) = match __v {
                                                                                                                                                               Value::tuple5__CtxS_TmS_TmS_TyS_TyS(ref __box) => {
                                                                                                                                                                   match **__box {
                                                                                                                                                                       (ref _G, ref _M, ref _N, ref s, ref t) => (_G, _M, _N, s, t),
                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                   }
                                                                                                                                                               },
                                                                                                                                                               _ => unreachable!()
                                                                                                                                                           };
                                                                                                                                                           Some((Value::TyS(t.clone()), Value::tuple5__CtxS_TmS_TmS_TyS_TyS(boxed::Box::new((_G.clone(), _M.clone(), _N.clone(), s.clone(), t.clone())))))
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                          description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D)".to_string(),
                                                                                                                                                                          ffun: None,
                                                                                                                                                                          arrangement: (Relations::Ty as RelId,0),
                                                                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                          {
                                                                                                                                                                              let (_G, _M, _N, s, t) = match *__v1 {
                                                                                                                                                                                  Value::tuple5__CtxS_TmS_TmS_TyS_TyS(ref __box) => {
                                                                                                                                                                                      match **__box {
                                                                                                                                                                                          (ref _G, ref _M, ref _N, ref s, ref t) => (_G, _M, _N, s, t),
                                                                                                                                                                                          _ => unreachable!(),
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => unreachable!()
                                                                                                                                                                              };
                                                                                                                                                                              let _D = match *__v2{
                                                                                                                                                                                  Value::Ty(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                      Ty{ty: _, ctx: ref _D} => _D,
                                                                                                                                                                                      _ => return None
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => return None
                                                                                                                                                                              };
                                                                                                                                                                              Some(Value::tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS(boxed::Box::new((_D.clone(), _G.clone(), _M.clone(), _N.clone(), s.clone(), t.clone()))))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                  description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D) by (_G, _D)" .to_string(),
                                                                                                                                                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let (_D, _G, _M, _N, s, t) = match __v {
                                                                                                                                                                                                          Value::tuple6__CtxS_CtxS_TmS_TmS_TyS_TyS(ref __box) => {
                                                                                                                                                                                                              match **__box {
                                                                                                                                                                                                                  (ref _D, ref _G, ref _M, ref _N, ref s, ref t) => (_D, _G, _M, _N, s, t),
                                                                                                                                                                                                                  _ => unreachable!(),
                                                                                                                                                                                                              }
                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => unreachable!()
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((Value::tuple2__CtxS_CtxS((_G.clone(), _D.clone())), Value::tuple4__TmS_TmS_TyS_TyS((_M.clone(), _N.clone(), s.clone(), t.clone()))))
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                     description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                                                                                                                                                     ffun: None,
                                                                                                                                                                                                                     arrangement: (Relations::CtxMorph as RelId,6),
                                                                                                                                                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let (_M, _N, s, t) = match *__v1 {
                                                                                                                                                                                                                             Value::tuple4__TmS_TmS_TyS_TyS(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                     (ref _M, ref _N, ref s, ref t) => (_M, _N, s, t),
                                                                                                                                                                                                                                     _ => unreachable!(),
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => unreachable!()
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         let f = match *__v2{
                                                                                                                                                                                                                             Value::CtxMorph(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                 CtxMorph{f: ref f, from: _, to: _} => f,
                                                                                                                                                                                                                                 _ => return None
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         Some(Value::tuple5__TmS_TmS_CtxMorphS_TyS_TyS(boxed::Box::new((_M.clone(), _N.clone(), f.clone(), s.clone(), t.clone()))))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                             description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D) by (t, f, s)" .to_string(),
                                                                                                                                                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                 let (_M, _N, f, s, t) = match __v {
                                                                                                                                                                                                                                                     Value::tuple5__TmS_TmS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                                                                                                                                                                                                         match **__box {
                                                                                                                                                                                                                                                             (ref _M, ref _N, ref f, ref s, ref t) => (_M, _N, f, s, t),
                                                                                                                                                                                                                                                             _ => unreachable!(),
                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                     },
                                                                                                                                                                                                                                                     _ => unreachable!()
                                                                                                                                                                                                                                                 };
                                                                                                                                                                                                                                                 Some((Value::tuple3__TyS_CtxMorphS_TyS((t.clone(), f.clone(), s.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), f.clone()))))
                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                             __f},
                                                                                                                                                                                                                                             next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                                                                                                                                                description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_G), Refl(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=t, .f=f, .sub=s)".to_string(),
                                                                                                                                                                                                                                                                ffun: None,
                                                                                                                                                                                                                                                                arrangement: (Relations::TySubst as RelId,2),
                                                                                                                                                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    let (_M, _N, f) = match *__v1 {
                                                                                                                                                                                                                                                                        Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                            match *__box {
                                                                                                                                                                                                                                                                                (ref _M, ref _N, ref f) => (_M, _N, f),
                                                                                                                                                                                                                                                                                _ => unreachable!(),
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                        _ => unreachable!()
                                                                                                                                                                                                                                                                    };
                                                                                                                                                                                                                                                                    Some(Value::TmSubst(TmSubst{tm: _N.clone(), f: f.clone(), sub: _M.clone()}))
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                next: Box::new(None)
                                                                                                                                                                                                                                                            })
                                                                                                                                                                                                                                         }))
                                                                                                                                                                                                                 })
                                                                                                                                                                                              }))
                                                                                                                                                                      })
                                                                                                                                                   }))
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D).".to_string(),
                              arr: ( Relations::__Prefix_6 as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Ty as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, s) = match *__v1{
                                                 Value::tuple2__TmS_TyS(ref __box) => {
                                                     match *__box {
                                                     (ref _M, ref s) => (_M, s),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _G = match *__v2{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: _, ctx: ref _G} => _G,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple2__CtxS_TmS((_G.clone(), _M.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G) by ()" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_G, _M) = match __v {
                                                                         Value::tuple2__CtxS_TmS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _G, ref _M) => (_G, _M),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple0__(()), Value::tuple2__CtxS_TmS((_G.clone(), _M.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::True as RelId,1),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_G, _M) = match *__v1 {
                                                                                            Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _G, ref _M) => (_G, _M),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _N = match *__v2{
                                                                                            Value::True(ref __box) => {
                                                                                                match *__box {
                                                                                                True{tm: ref _N} => _N,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N) by (_N)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_G, _M, _N) = match __v {
                                                                                                                    Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::TmS(_N.clone()), Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::Tm as RelId,1),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_G, _M, _N) = match *__v1 {
                                                                                                                                       Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let t = match *__v2{
                                                                                                                                       Value::Tm(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           Tm{tm: _, ty: ref t} => t,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::tuple4__CtxS_TmS_TmS_TyS((_G.clone(), _M.clone(), _N.clone(), t.clone())))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                       description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t) by (t)" .to_string(),
                                                                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                       {
                                                                                                                                                           let (_G, _M, _N, t) = match __v {
                                                                                                                                                               Value::tuple4__CtxS_TmS_TmS_TyS(ref __box) => {
                                                                                                                                                                   match *__box {
                                                                                                                                                                       (ref _G, ref _M, ref _N, ref t) => (_G, _M, _N, t),
                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                   }
                                                                                                                                                               },
                                                                                                                                                               _ => unreachable!()
                                                                                                                                                           };
                                                                                                                                                           Some((Value::TyS(t.clone()), Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone()))))
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                          description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D)".to_string(),
                                                                                                                                                                          ffun: None,
                                                                                                                                                                          arrangement: (Relations::Ty as RelId,0),
                                                                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                          {
                                                                                                                                                                              let (_G, _M, _N) = match *__v1 {
                                                                                                                                                                                  Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                          (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                                                                                          _ => unreachable!(),
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => unreachable!()
                                                                                                                                                                              };
                                                                                                                                                                              let _D = match *__v2{
                                                                                                                                                                                  Value::Ty(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                      Ty{ty: _, ctx: ref _D} => _D,
                                                                                                                                                                                      _ => return None
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => return None
                                                                                                                                                                              };
                                                                                                                                                                              Some(Value::tuple4__CtxS_CtxS_TmS_TmS((_D.clone(), _G.clone(), _M.clone(), _N.clone())))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                  description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D) by (_G, _D)" .to_string(),
                                                                                                                                                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let (_D, _G, _M, _N) = match __v {
                                                                                                                                                                                                          Value::tuple4__CtxS_CtxS_TmS_TmS(ref __box) => {
                                                                                                                                                                                                              match *__box {
                                                                                                                                                                                                                  (ref _D, ref _G, ref _M, ref _N) => (_D, _G, _M, _N),
                                                                                                                                                                                                                  _ => unreachable!(),
                                                                                                                                                                                                              }
                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => unreachable!()
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((Value::tuple2__CtxS_CtxS((_G.clone(), _D.clone())), Value::tuple2__TmS_TmS((_M.clone(), _N.clone()))))
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                     description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_G), True(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                                                                                                                                                     ffun: None,
                                                                                                                                                                                                                     arrangement: (Relations::CtxMorph as RelId,6),
                                                                                                                                                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let (_M, _N) = match *__v1 {
                                                                                                                                                                                                                             Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                     (ref _M, ref _N) => (_M, _N),
                                                                                                                                                                                                                                     _ => unreachable!(),
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => unreachable!()
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         let f = match *__v2{
                                                                                                                                                                                                                             Value::CtxMorph(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                 CtxMorph{f: ref f, from: _, to: _} => f,
                                                                                                                                                                                                                                 _ => return None
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         Some(Value::TmSubst(TmSubst{tm: _N.clone(), f: f.clone(), sub: _M.clone()}))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(None)
                                                                                                                                                                                                                 })
                                                                                                                                                                                              }))
                                                                                                                                                                      })
                                                                                                                                                   }))
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_N, .f=f, .sub=_M) :- __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D).".to_string(),
                              arr: ( Relations::__Prefix_5 as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Ty as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, s) = match *__v1{
                                                 Value::tuple2__TmS_TyS(ref __box) => {
                                                     match *__box {
                                                     (ref _M, ref s) => (_M, s),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _G = match *__v2{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: _, ctx: ref _G} => _G,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple2__CtxS_TmS((_G.clone(), _M.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G) by ()" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_G, _M) = match __v {
                                                                         Value::tuple2__CtxS_TmS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _G, ref _M) => (_G, _M),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple0__(()), Value::tuple2__CtxS_TmS((_G.clone(), _M.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::False as RelId,1),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_G, _M) = match *__v1 {
                                                                                            Value::tuple2__CtxS_TmS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _G, ref _M) => (_G, _M),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _N = match *__v2{
                                                                                            Value::False(ref __box) => {
                                                                                                match *__box {
                                                                                                False{tm: ref _N} => _N,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N) by (_N)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_G, _M, _N) = match __v {
                                                                                                                    Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::TmS(_N.clone()), Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::Tm as RelId,1),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_G, _M, _N) = match *__v1 {
                                                                                                                                       Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let t = match *__v2{
                                                                                                                                       Value::Tm(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           Tm{tm: _, ty: ref t} => t,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::tuple4__CtxS_TmS_TmS_TyS((_G.clone(), _M.clone(), _N.clone(), t.clone())))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                       description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t) by (t)" .to_string(),
                                                                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                       {
                                                                                                                                                           let (_G, _M, _N, t) = match __v {
                                                                                                                                                               Value::tuple4__CtxS_TmS_TmS_TyS(ref __box) => {
                                                                                                                                                                   match *__box {
                                                                                                                                                                       (ref _G, ref _M, ref _N, ref t) => (_G, _M, _N, t),
                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                   }
                                                                                                                                                               },
                                                                                                                                                               _ => unreachable!()
                                                                                                                                                           };
                                                                                                                                                           Some((Value::TyS(t.clone()), Value::tuple3__CtxS_TmS_TmS((_G.clone(), _M.clone(), _N.clone()))))
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                          description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D)".to_string(),
                                                                                                                                                                          ffun: None,
                                                                                                                                                                          arrangement: (Relations::Ty as RelId,0),
                                                                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                          {
                                                                                                                                                                              let (_G, _M, _N) = match *__v1 {
                                                                                                                                                                                  Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                          (ref _G, ref _M, ref _N) => (_G, _M, _N),
                                                                                                                                                                                          _ => unreachable!(),
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => unreachable!()
                                                                                                                                                                              };
                                                                                                                                                                              let _D = match *__v2{
                                                                                                                                                                                  Value::Ty(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                      Ty{ty: _, ctx: ref _D} => _D,
                                                                                                                                                                                      _ => return None
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => return None
                                                                                                                                                                              };
                                                                                                                                                                              Some(Value::tuple4__CtxS_CtxS_TmS_TmS((_D.clone(), _G.clone(), _M.clone(), _N.clone())))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                  description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D) by (_G, _D)" .to_string(),
                                                                                                                                                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let (_D, _G, _M, _N) = match __v {
                                                                                                                                                                                                          Value::tuple4__CtxS_CtxS_TmS_TmS(ref __box) => {
                                                                                                                                                                                                              match *__box {
                                                                                                                                                                                                                  (ref _D, ref _G, ref _M, ref _N) => (_D, _G, _M, _N),
                                                                                                                                                                                                                  _ => unreachable!(),
                                                                                                                                                                                                              }
                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => unreachable!()
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((Value::tuple2__CtxS_CtxS((_G.clone(), _D.clone())), Value::tuple2__TmS_TmS((_M.clone(), _N.clone()))))
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                     description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_G), False(.tm=_N), Tm(.tm=_N, .ty=t), Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                                                                                                                                                     ffun: None,
                                                                                                                                                                                                                     arrangement: (Relations::CtxMorph as RelId,6),
                                                                                                                                                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let (_M, _N) = match *__v1 {
                                                                                                                                                                                                                             Value::tuple2__TmS_TmS(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                     (ref _M, ref _N) => (_M, _N),
                                                                                                                                                                                                                                     _ => unreachable!(),
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => unreachable!()
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         let f = match *__v2{
                                                                                                                                                                                                                             Value::CtxMorph(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                 CtxMorph{f: ref f, from: _, to: _} => f,
                                                                                                                                                                                                                                 _ => return None
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         Some(Value::TmSubst(TmSubst{tm: _N.clone(), f: f.clone(), sub: _M.clone()}))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(None)
                                                                                                                                                                                                                 })
                                                                                                                                                                                              }))
                                                                                                                                                                      })
                                                                                                                                                   }))
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_O, .f=q, .sub=_P) :- BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_O, .f=q, .sub=_P) :- BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D).".to_string(),
                              arr: ( Relations::BoolElim as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,4),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_Q, _R, _P) = match *__v1{
                                                 Value::BoolElim(ref __box) => {
                                                     match *__box {
                                                     BoolElim{trueCase: ref _Q, falseCase: ref _R, tm: ref _P} => (_Q, _R, _P),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (_M, f) = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _M, f: ref f, sub: _} => (_M, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__TmS_TmS_TmS_CtxMorphS((_M.clone(), _P.clone(), _R.clone(), f.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q) by (f, _R)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_M, _P, _R, f) = match __v {
                                                                         Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _M, ref _P, ref _R, ref f) => (_M, _P, _R, f),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__CtxMorphS_TmS((f.clone(), _R.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _P.clone(), f.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::TmSubst as RelId,1),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_M, _P, f) = match *__v1 {
                                                                                            Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _M, ref _P, ref f) => (_M, _P, f),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let _N = match *__v2{
                                                                                            Value::TmSubst(ref __box) => {
                                                                                                match *__box {
                                                                                                TmSubst{tm: ref _N, f: _, sub: _} => _N,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple4__TmS_TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), _P.clone(), f.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R) by (f)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_M, _N, _P, f) = match __v {
                                                                                                                    Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _M, ref _N, ref _P, ref f) => (_M, _N, _P, f),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::CtxMorphS(f.clone()), Value::tuple4__TmS_TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), _P.clone(), f.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::CtxMorph as RelId,3),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (_M, _N, _P, f) = match *__v1 {
                                                                                                                                       Value::tuple4__TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref _M, ref _N, ref _P, ref f) => (_M, _N, _P, f),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let (_G, _D) = match *__v2{
                                                                                                                                       Value::CtxMorph(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           CtxMorph{f: _, from: ref _G, to: ref _D} => (_G, _D),
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(boxed::Box::new((_D.clone(), _M.clone(), _N.clone(), _P.clone(), f.clone()))))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                       description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D) by (_M, _N)" .to_string(),
                                                                                                                                                       afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                       {
                                                                                                                                                           let (_D, _M, _N, _P, f) = match __v {
                                                                                                                                                               Value::tuple5__CtxS_TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                   match **__box {
                                                                                                                                                                       (ref _D, ref _M, ref _N, ref _P, ref f) => (_D, _M, _N, _P, f),
                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                   }
                                                                                                                                                               },
                                                                                                                                                               _ => unreachable!()
                                                                                                                                                           };
                                                                                                                                                           Some((Value::tuple2__TmS_TmS((_M.clone(), _N.clone())), Value::tuple3__CtxS_TmS_CtxMorphS((_D.clone(), _P.clone(), f.clone()))))
                                                                                                                                                       }
                                                                                                                                                       __f},
                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                          description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O)".to_string(),
                                                                                                                                                                          ffun: None,
                                                                                                                                                                          arrangement: (Relations::BoolElim as RelId,2),
                                                                                                                                                                          jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                          {
                                                                                                                                                                              let (_D, _P, f) = match *__v1 {
                                                                                                                                                                                  Value::tuple3__CtxS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                          (ref _D, ref _P, ref f) => (_D, _P, f),
                                                                                                                                                                                          _ => unreachable!(),
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => unreachable!()
                                                                                                                                                                              };
                                                                                                                                                                              let _O = match *__v2{
                                                                                                                                                                                  Value::BoolElim(ref __box) => {
                                                                                                                                                                                      match *__box {
                                                                                                                                                                                      BoolElim{trueCase: _, falseCase: _, tm: ref _O} => _O,
                                                                                                                                                                                      _ => return None
                                                                                                                                                                                      }
                                                                                                                                                                                  },
                                                                                                                                                                                  _ => return None
                                                                                                                                                                              };
                                                                                                                                                                              Some(Value::tuple4__CtxS_TmS_TmS_CtxMorphS((_D.clone(), _O.clone(), _P.clone(), f.clone())))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                  description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O) by (f)" .to_string(),
                                                                                                                                                                                                  afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                  {
                                                                                                                                                                                                      let (_D, _O, _P, f) = match __v {
                                                                                                                                                                                                          Value::tuple4__CtxS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                              match *__box {
                                                                                                                                                                                                                  (ref _D, ref _O, ref _P, ref f) => (_D, _O, _P, f),
                                                                                                                                                                                                                  _ => unreachable!(),
                                                                                                                                                                                                              }
                                                                                                                                                                                                          },
                                                                                                                                                                                                          _ => unreachable!()
                                                                                                                                                                                                      };
                                                                                                                                                                                                      Some((Value::CtxMorphS(f.clone()), Value::tuple3__CtxS_TmS_TmS((_D.clone(), _O.clone(), _P.clone()))))
                                                                                                                                                                                                  }
                                                                                                                                                                                                  __f},
                                                                                                                                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                     description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q)".to_string(),
                                                                                                                                                                                                                     ffun: None,
                                                                                                                                                                                                                     arrangement: (Relations::Weakening as RelId,0),
                                                                                                                                                                                                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let (_D, _O, _P) = match *__v1 {
                                                                                                                                                                                                                             Value::tuple3__CtxS_TmS_TmS(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                     (ref _D, ref _O, ref _P) => (_D, _O, _P),
                                                                                                                                                                                                                                     _ => unreachable!(),
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => unreachable!()
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         let (s, q) = match *__v2{
                                                                                                                                                                                                                             Value::Weakening(ref __box) => {
                                                                                                                                                                                                                                 match *__box {
                                                                                                                                                                                                                                 Weakening{f: _, ty: ref s, q: ref q} => (s, q),
                                                                                                                                                                                                                                 _ => return None
                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                             },
                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                         };
                                                                                                                                                                                                                         Some(Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _O.clone(), _P.clone(), q.clone(), s.clone()))))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                             description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q) by (s)" .to_string(),
                                                                                                                                                                                                                                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                 let (_D, _O, _P, q, s) = match __v {
                                                                                                                                                                                                                                                     Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                                                                                         match **__box {
                                                                                                                                                                                                                                                             (ref _D, ref _O, ref _P, ref q, ref s) => (_D, _O, _P, q, s),
                                                                                                                                                                                                                                                             _ => unreachable!(),
                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                     },
                                                                                                                                                                                                                                                     _ => unreachable!()
                                                                                                                                                                                                                                                 };
                                                                                                                                                                                                                                                 Some((Value::TyS(s.clone()), Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _O.clone(), _P.clone(), q.clone(), s.clone())))))
                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                             __f},
                                                                                                                                                                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s)".to_string(),
                                                                                                                                                                                                                                                                ffun: None,
                                                                                                                                                                                                                                                                arrangement: (Relations::Bool as RelId,0),
                                                                                                                                                                                                                                                                jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    let (_D, _O, _P, q, s) = match *__v1 {
                                                                                                                                                                                                                                                                        Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                                                                                                            match **__box {
                                                                                                                                                                                                                                                                                (ref _D, ref _O, ref _P, ref q, ref s) => (_D, _O, _P, q, s),
                                                                                                                                                                                                                                                                                _ => unreachable!(),
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                        _ => unreachable!()
                                                                                                                                                                                                                                                                    };
                                                                                                                                                                                                                                                                    let () = match *__v2{
                                                                                                                                                                                                                                                                        Value::Bool(ref __box) => {
                                                                                                                                                                                                                                                                            match *__box {
                                                                                                                                                                                                                                                                            Bool{ty: _} => (),
                                                                                                                                                                                                                                                                            _ => return None
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                                                        _ => return None
                                                                                                                                                                                                                                                                    };
                                                                                                                                                                                                                                                                    Some(Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(boxed::Box::new((_D.clone(), _O.clone(), _P.clone(), q.clone(), s.clone()))))
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                                                        description: "arrange BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s) by (s, _D)" .to_string(),
                                                                                                                                                                                                                                                                                        afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            let (_D, _O, _P, q, s) = match __v {
                                                                                                                                                                                                                                                                                                Value::tuple5__CtxS_TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                                                                                                                                    match **__box {
                                                                                                                                                                                                                                                                                                        (ref _D, ref _O, ref _P, ref q, ref s) => (_D, _O, _P, q, s),
                                                                                                                                                                                                                                                                                                        _ => unreachable!(),
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                },
                                                                                                                                                                                                                                                                                                _ => unreachable!()
                                                                                                                                                                                                                                                                                            };
                                                                                                                                                                                                                                                                                            Some((Value::tuple2__TyS_CtxS((s.clone(), _D.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_O.clone(), _P.clone(), q.clone()))))
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        __f},
                                                                                                                                                                                                                                                                                        next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                                                                                                                                                                                           description: "BoolElim(.trueCase=_Q, .falseCase=_R, .tm=_P), TmSubst(.tm=_M, .f=f, .sub=_Q), TmSubst(.tm=_N, .f=f, .sub=_R), CtxMorph(.f=f, .from=_G, .to=_D), BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Weakening(.f=f, .ty=s, .q=q), Bool(.ty=s), Ty(.ty=s, .ctx=_D)".to_string(),
                                                                                                                                                                                                                                                                                                           ffun: None,
                                                                                                                                                                                                                                                                                                           arrangement: (Relations::Ty as RelId,1),
                                                                                                                                                                                                                                                                                                           jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                               let (_O, _P, q) = match *__v1 {
                                                                                                                                                                                                                                                                                                                   Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                                                                                                                                                                                                                                       match *__box {
                                                                                                                                                                                                                                                                                                                           (ref _O, ref _P, ref q) => (_O, _P, q),
                                                                                                                                                                                                                                                                                                                           _ => unreachable!(),
                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                   },
                                                                                                                                                                                                                                                                                                                   _ => unreachable!()
                                                                                                                                                                                                                                                                                                               };
                                                                                                                                                                                                                                                                                                               Some(Value::TmSubst(TmSubst{tm: _O.clone(), f: q.clone(), sub: _P.clone()}))
                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                           __f},
                                                                                                                                                                                                                                                                                                           next: Box::new(None)
                                                                                                                                                                                                                                                                                                       })
                                                                                                                                                                                                                                                                                    }))
                                                                                                                                                                                                                                                            })
                                                                                                                                                                                                                                         }))
                                                                                                                                                                                                                 })
                                                                                                                                                                                              }))
                                                                                                                                                                      })
                                                                                                                                                   }))
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TmSubst(.tm=_M, .f=f, .sub=_Q) :- __Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_M, .f=f, .sub=_Q) :- __Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q).".to_string(),
                              arr: ( Relations::__Prefix_1 as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,2),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, _N, _O, _P, e, f) = match *__v1{
                                                 Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                     match **__box {
                                                     (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _Q = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::TmSubst(TmSubst{tm: _M.clone(), f: f.clone(), sub: _Q.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          },
                          /* TmSubst(.tm=_O, .f=e, .sub=_Q) :- __Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_M, .f=f, .sub=_Q). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_O, .f=e, .sub=_Q) :- __Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_M, .f=f, .sub=_Q).".to_string(),
                              arr: ( Relations::__Prefix_1 as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_1[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_M, .f=f, .sub=_Q)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,2),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, _N, _O, _P, e, f) = match *__v1{
                                                 Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                     match **__box {
                                                     (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _Q = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::TmSubst(TmSubst{tm: _O.clone(), f: e.clone(), sub: _Q.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          },
                          /* TmSubst(.tm=_N, .f=f, .sub=_Q) :- __Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_N, .f=f, .sub=_Q) :- __Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q).".to_string(),
                              arr: ( Relations::__Prefix_0 as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_O, .f=e, .sub=_Q)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,2),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, _N, _O, _P, e, f) = match *__v1{
                                                 Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                     match **__box {
                                                     (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _Q = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::TmSubst(TmSubst{tm: _N.clone(), f: f.clone(), sub: _Q.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          },
                          /* TmSubst(.tm=_O, .f=e, .sub=_Q) :- __Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_N, .f=f, .sub=_Q). */
                          Rule::ArrangementRule {
                              description: "TmSubst(.tm=_O, .f=e, .sub=_Q) :- __Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_N, .f=f, .sub=_Q).".to_string(),
                              arr: ( Relations::__Prefix_0 as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_0[(_M, _N, _O, _P, e, f)], TmSubst(.tm=_N, .f=f, .sub=_Q)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,2),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, _N, _O, _P, e, f) = match *__v1{
                                                 Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                     match **__box {
                                                     (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _Q = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: _, f: _, sub: ref _Q} => _Q,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::TmSubst(TmSubst{tm: _O.clone(), f: e.clone(), sub: _Q.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     }
                          }],
                      arrangements: vec![
                          Arrangement::Map{
                             name: r###"TmSubst{.tm=_, .f=_0, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TmSubst(__box) = __v {
                                          match __box {
                                          TmSubst{tm: _, f: ref _0, sub: _} => Some(Value::CtxMorphS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TmSubst{.tm=_, .f=_0, .sub=_1}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TmSubst(__box) = __v {
                                          match __box {
                                          TmSubst{tm: _, f: ref _0, sub: ref _1} => Some(Value::tuple2__CtxMorphS_TmS((_0.clone(), _1.clone()))),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TmSubst{.tm=_0, .f=_1, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TmSubst(__box) = __v {
                                          match __box {
                                          TmSubst{tm: ref _0, f: ref _1, sub: _} => Some(Value::tuple2__TmS_CtxMorphS((_0.clone(), _1.clone()))),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TmSubst{.tm=_0, .f=_, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TmSubst(__box) = __v {
                                          match __box {
                                          TmSubst{tm: ref _0, f: _, sub: _} => Some(Value::TmS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TmSubst{.tm=_, .f=_, .sub=_0}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TmSubst(__box) = __v {
                                          match __box {
                                          TmSubst{tm: _, f: _, sub: ref _0} => Some(Value::TmS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          }],
                      change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                  };
    let False = Relation {
                    name:         "False".to_string(),
                    input:        false,
                    distinct:     false,
                    key_func:     None,
                    id:           Relations::False as RelId,
                    rules:        vec![
                        /* False(.tm=tm) :- FalseInput(.tm=tm). */
                        Rule::CollectionRule {
                            description: "False(.tm=tm) :- FalseInput(.tm=tm).".to_string(),
                            rel: Relations::FalseInput as RelId,
                            xform: Some(XFormCollection::FilterMap{
                                            description: "head of False(.tm=tm) :- FalseInput(.tm=tm)." .to_string(),
                                            fmfun: &{fn __f(__v: Value) -> Option<Value>
                                            {
                                                let tm = match __v{
                                                    Value::FalseInput(ref __box) => {
                                                        match *__box {
                                                        FalseInput{tm: ref tm} => tm,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::False(False{tm: tm.clone()}))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        })
                        },
                        /* False(.tm=_N) :- False(.tm=_M), TmEq(.l=_M, .r=_N). */
                        Rule::ArrangementRule {
                            description: "False(.tm=_N) :- False(.tm=_M), TmEq(.l=_M, .r=_N).".to_string(),
                            arr: ( Relations::False as RelId, 0),
                            xform: XFormArrangement::Join{
                                       description: "False(.tm=_M), TmEq(.l=_M, .r=_N)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::TmEq as RelId,0),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let _M = match *__v1{
                                               Value::False(ref __box) => {
                                                   match *__box {
                                                   False{tm: ref _M} => _M,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let _N = match *__v2{
                                               Value::TmEq(ref __box) => {
                                                   match *__box {
                                                   TmEq{l: _, r: ref _N} => _N,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::False(False{tm: _N.clone()}))
                                       }
                                       __f},
                                       next: Box::new(None)
                                   }
                        },
                        /* False(.tm=_O) :- __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O). */
                        Rule::ArrangementRule {
                            description: "False(.tm=_O) :- __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O).".to_string(),
                            arr: ( Relations::__Prefix_5 as RelId, 0),
                            xform: XFormArrangement::Join{
                                       description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::Ty as RelId,0),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let (_M, s) = match *__v1{
                                               Value::tuple2__TmS_TyS(ref __box) => {
                                                   match *__box {
                                                   (ref _M, ref s) => (_M, s),
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let _D = match *__v2{
                                               Value::Ty(ref __box) => {
                                                   match *__box {
                                                   Ty{ty: _, ctx: ref _D} => _D,
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::tuple2__CtxS_TmS((_D.clone(), _M.clone())))
                                       }
                                       __f},
                                       next: Box::new(Some(XFormCollection::Arrange {
                                                               description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D) by (_D)" .to_string(),
                                                               afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                               {
                                                                   let (_D, _M) = match __v {
                                                                       Value::tuple2__CtxS_TmS(ref __box) => {
                                                                           match *__box {
                                                                               (ref _D, ref _M) => (_D, _M),
                                                                               _ => unreachable!(),
                                                                           }
                                                                       },
                                                                       _ => unreachable!()
                                                                   };
                                                                   Some((Value::CtxS(_D.clone()), Value::TmS(_M.clone())))
                                                               }
                                                               __f},
                                                               next: Box::new(XFormArrangement::Join{
                                                                                  description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                  ffun: None,
                                                                                  arrangement: (Relations::CtxMorph as RelId,0),
                                                                                  jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                  {
                                                                                      let _M = match *__v1 {
                                                                                          Value::TmS(ref __box) => {
                                                                                              match *__box {
                                                                                                  ref _M => _M,
                                                                                                  _ => unreachable!(),
                                                                                              }
                                                                                          },
                                                                                          _ => unreachable!()
                                                                                      };
                                                                                      let (f, _G) = match *__v2{
                                                                                          Value::CtxMorph(ref __box) => {
                                                                                              match *__box {
                                                                                              CtxMorph{f: ref f, from: ref _G, to: _} => (f, _G),
                                                                                              _ => return None
                                                                                              }
                                                                                          },
                                                                                          _ => return None
                                                                                      };
                                                                                      Some(Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())))
                                                                                  }
                                                                                  __f},
                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                          description: "arrange __Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D) by (_M, f)" .to_string(),
                                                                                                          afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                          {
                                                                                                              let (_M, f) = match __v {
                                                                                                                  Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                      match *__box {
                                                                                                                          (ref _M, ref f) => (_M, f),
                                                                                                                          _ => unreachable!(),
                                                                                                                      }
                                                                                                                  },
                                                                                                                  _ => unreachable!()
                                                                                                              };
                                                                                                              Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple0__(())))
                                                                                                          }
                                                                                                          __f},
                                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                                             description: "__Prefix_5[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O)".to_string(),
                                                                                                                             ffun: None,
                                                                                                                             arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                             jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                             {
                                                                                                                                 let () = match *__v1 {
                                                                                                                                     Value::tuple0__(ref __box) => {
                                                                                                                                         match *__box {
                                                                                                                                             () => (),
                                                                                                                                             _ => unreachable!(),
                                                                                                                                         }
                                                                                                                                     },
                                                                                                                                     _ => unreachable!()
                                                                                                                                 };
                                                                                                                                 let _O = match *__v2{
                                                                                                                                     Value::TmSubst(ref __box) => {
                                                                                                                                         match *__box {
                                                                                                                                         TmSubst{tm: _, f: _, sub: ref _O} => _O,
                                                                                                                                         _ => return None
                                                                                                                                         }
                                                                                                                                     },
                                                                                                                                     _ => return None
                                                                                                                                 };
                                                                                                                                 Some(Value::False(False{tm: _O.clone()}))
                                                                                                                             }
                                                                                                                             __f},
                                                                                                                             next: Box::new(None)
                                                                                                                         })
                                                                                                      }))
                                                                              })
                                                           }))
                                   }
                        }],
                    arrangements: vec![
                        Arrangement::Map{
                           name: r###"False{.tm=_0}"###.to_string(),
                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                            {
                                let __cloned = __v.clone();
                                {
                                    if let Value::False(__box) = __v {
                                        match __box {
                                        False{tm: ref _0} => Some(Value::TmS(_0.clone())),
                                        _ => None
                                        }
                                    } else { None }
                                }.map(|x|(x,__cloned))
                            }
                            __f},
                            queryable: false
                        },
                        Arrangement::Map{
                           name: r###"_"###.to_string(),
                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                            {
                                let __cloned = __v.clone();
                                {
                                    if let Value::False(__box) = __v {
                                        match __box {
                                        _ => Some(Value::tuple0__(())),
                                        _ => None
                                        }
                                    } else { None }
                                }.map(|x|(x,__cloned))
                            }
                            __f},
                            queryable: false
                        }],
                    change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                };
    let Ty = Relation {
                 name:         "Ty".to_string(),
                 input:        false,
                 distinct:     false,
                 key_func:     None,
                 id:           Relations::Ty as RelId,
                 rules:        vec![
                     /* Ty(.ty=ty, .ctx=ctx) :- TyInput(.ty=ty, .ctx=ctx). */
                     Rule::CollectionRule {
                         description: "Ty(.ty=ty, .ctx=ctx) :- TyInput(.ty=ty, .ctx=ctx).".to_string(),
                         rel: Relations::TyInput as RelId,
                         xform: Some(XFormCollection::FilterMap{
                                         description: "head of Ty(.ty=ty, .ctx=ctx) :- TyInput(.ty=ty, .ctx=ctx)." .to_string(),
                                         fmfun: &{fn __f(__v: Value) -> Option<Value>
                                         {
                                             let (ty, ctx) = match __v{
                                                 Value::TyInput(ref __box) => {
                                                     match *__box {
                                                     TyInput{ty: ref ty, ctx: ref ctx} => (ty, ctx),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::Ty(Ty{ty: ty.clone(), ctx: ctx.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     })
                     },
                     /* Ty(.ty=t, .ctx=_D) :- Ty(.ty=s, .ctx=_G), TyEq(.l=s, .r=t), CtxEq(.l=_G, .r=_D). */
                     Rule::ArrangementRule {
                         description: "Ty(.ty=t, .ctx=_D) :- Ty(.ty=s, .ctx=_G), TyEq(.l=s, .r=t), CtxEq(.l=_G, .r=_D).".to_string(),
                         arr: ( Relations::Ty as RelId, 0),
                         xform: XFormArrangement::Join{
                                    description: "Ty(.ty=s, .ctx=_G), TyEq(.l=s, .r=t)".to_string(),
                                    ffun: None,
                                    arrangement: (Relations::TyEq as RelId,0),
                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                    {
                                        let (s, _G) = match *__v1{
                                            Value::Ty(ref __box) => {
                                                match *__box {
                                                Ty{ty: ref s, ctx: ref _G} => (s, _G),
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        let t = match *__v2{
                                            Value::TyEq(ref __box) => {
                                                match *__box {
                                                TyEq{l: _, r: ref t} => t,
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        Some(Value::tuple2__CtxS_TyS((_G.clone(), t.clone())))
                                    }
                                    __f},
                                    next: Box::new(Some(XFormCollection::Arrange {
                                                            description: "arrange Ty(.ty=s, .ctx=_G), TyEq(.l=s, .r=t) by (_G)" .to_string(),
                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                            {
                                                                let (_G, t) = match __v {
                                                                    Value::tuple2__CtxS_TyS(ref __box) => {
                                                                        match *__box {
                                                                            (ref _G, ref t) => (_G, t),
                                                                            _ => unreachable!(),
                                                                        }
                                                                    },
                                                                    _ => unreachable!()
                                                                };
                                                                Some((Value::CtxS(_G.clone()), Value::TyS(t.clone())))
                                                            }
                                                            __f},
                                                            next: Box::new(XFormArrangement::Join{
                                                                               description: "Ty(.ty=s, .ctx=_G), TyEq(.l=s, .r=t), CtxEq(.l=_G, .r=_D)".to_string(),
                                                                               ffun: None,
                                                                               arrangement: (Relations::CtxEq as RelId,0),
                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                               {
                                                                                   let t = match *__v1 {
                                                                                       Value::TyS(ref __box) => {
                                                                                           match *__box {
                                                                                               ref t => t,
                                                                                               _ => unreachable!(),
                                                                                           }
                                                                                       },
                                                                                       _ => unreachable!()
                                                                                   };
                                                                                   let _D = match *__v2{
                                                                                       Value::CtxEq(ref __box) => {
                                                                                           match *__box {
                                                                                           CtxEq{l: _, r: ref _D} => _D,
                                                                                           _ => return None
                                                                                           }
                                                                                       },
                                                                                       _ => return None
                                                                                   };
                                                                                   Some(Value::Ty(Ty{ty: t.clone(), ctx: _D.clone()}))
                                                                               }
                                                                               __f},
                                                                               next: Box::new(None)
                                                                           })
                                                        }))
                                }
                     }],
                 arrangements: vec![
                     Arrangement::Map{
                        name: r###"Ty{.ty=_0, .ctx=_}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Ty(__box) = __v {
                                     match __box {
                                     Ty{ty: ref _0, ctx: _} => Some(Value::TyS(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     },
                     Arrangement::Set{
                         name: r###"Ty{.ty=_0, .ctx=_1}"###.to_string(),
                         fmfun: &{fn __f(__v: Value) -> Option<Value>
                         {
                             {
                                 if let Value::Ty(__box) = __v {
                                     match __box {
                                     Ty{ty: ref _0, ctx: ref _1} => Some(Value::tuple2__TyS_CtxS((_0.clone(), _1.clone()))),
                                     _ => None
                                     }
                                 } else { None }
                             }
                         }
                         __f},
                         distinct: false
                     },
                     Arrangement::Map{
                        name: r###"_"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Ty(__box) = __v {
                                     match __box {
                                     _ => Some(Value::tuple0__(())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     }],
                 change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
             };
    let __Prefix_5 = Relation {
                         name:         "__Prefix_5".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_5 as RelId,
                         rules:        vec![
                             /* __Prefix_5[(_M, s)] :- False(.tm=_M), Tm(.tm=_M, .ty=s). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_5[(_M, s)] :- False(.tm=_M), Tm(.tm=_M, .ty=s).".to_string(),
                                 arr: ( Relations::False as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "False(.tm=_M), Tm(.tm=_M, .ty=s)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Tm as RelId,1),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let _M = match *__v1{
                                                    Value::False(ref __box) => {
                                                        match *__box {
                                                        False{tm: ref _M} => _M,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let s = match *__v2{
                                                    Value::Tm(ref __box) => {
                                                        match *__box {
                                                        Tm{tm: _, ty: ref s} => s,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__TmS_TyS((_M.clone(), s.clone())))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _0)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             (_, ref _0) => Some(Value::TyS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"_"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             _ => Some(Value::tuple0__(())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let Tm = Relation {
                 name:         "Tm".to_string(),
                 input:        false,
                 distinct:     false,
                 key_func:     None,
                 id:           Relations::Tm as RelId,
                 rules:        vec![
                     /* Tm(.tm=tm, .ty=ty) :- TmInput(.tm=tm, .ty=ty). */
                     Rule::CollectionRule {
                         description: "Tm(.tm=tm, .ty=ty) :- TmInput(.tm=tm, .ty=ty).".to_string(),
                         rel: Relations::TmInput as RelId,
                         xform: Some(XFormCollection::FilterMap{
                                         description: "head of Tm(.tm=tm, .ty=ty) :- TmInput(.tm=tm, .ty=ty)." .to_string(),
                                         fmfun: &{fn __f(__v: Value) -> Option<Value>
                                         {
                                             let (tm, ty) = match __v{
                                                 Value::TmInput(ref __box) => {
                                                     match *__box {
                                                     TmInput{tm: ref tm, ty: ref ty} => (tm, ty),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::Tm(Tm{tm: tm.clone(), ty: ty.clone()}))
                                         }
                                         __f},
                                         next: Box::new(None)
                                     })
                     },
                     /* Tm(.tm=_N, .ty=t) :- Tm(.tm=_M, .ty=s), TmEq(.l=_M, .r=_N), TyEq(.l=s, .r=t). */
                     Rule::ArrangementRule {
                         description: "Tm(.tm=_N, .ty=t) :- Tm(.tm=_M, .ty=s), TmEq(.l=_M, .r=_N), TyEq(.l=s, .r=t).".to_string(),
                         arr: ( Relations::Tm as RelId, 1),
                         xform: XFormArrangement::Join{
                                    description: "Tm(.tm=_M, .ty=s), TmEq(.l=_M, .r=_N)".to_string(),
                                    ffun: None,
                                    arrangement: (Relations::TmEq as RelId,0),
                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                    {
                                        let (_M, s) = match *__v1{
                                            Value::Tm(ref __box) => {
                                                match *__box {
                                                Tm{tm: ref _M, ty: ref s} => (_M, s),
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        let _N = match *__v2{
                                            Value::TmEq(ref __box) => {
                                                match *__box {
                                                TmEq{l: _, r: ref _N} => _N,
                                                _ => return None
                                                }
                                            },
                                            _ => return None
                                        };
                                        Some(Value::tuple2__TmS_TyS((_N.clone(), s.clone())))
                                    }
                                    __f},
                                    next: Box::new(Some(XFormCollection::Arrange {
                                                            description: "arrange Tm(.tm=_M, .ty=s), TmEq(.l=_M, .r=_N) by (s)" .to_string(),
                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                            {
                                                                let (_N, s) = match __v {
                                                                    Value::tuple2__TmS_TyS(ref __box) => {
                                                                        match *__box {
                                                                            (ref _N, ref s) => (_N, s),
                                                                            _ => unreachable!(),
                                                                        }
                                                                    },
                                                                    _ => unreachable!()
                                                                };
                                                                Some((Value::TyS(s.clone()), Value::TmS(_N.clone())))
                                                            }
                                                            __f},
                                                            next: Box::new(XFormArrangement::Join{
                                                                               description: "Tm(.tm=_M, .ty=s), TmEq(.l=_M, .r=_N), TyEq(.l=s, .r=t)".to_string(),
                                                                               ffun: None,
                                                                               arrangement: (Relations::TyEq as RelId,0),
                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                               {
                                                                                   let _N = match *__v1 {
                                                                                       Value::TmS(ref __box) => {
                                                                                           match *__box {
                                                                                               ref _N => _N,
                                                                                               _ => unreachable!(),
                                                                                           }
                                                                                       },
                                                                                       _ => unreachable!()
                                                                                   };
                                                                                   let t = match *__v2{
                                                                                       Value::TyEq(ref __box) => {
                                                                                           match *__box {
                                                                                           TyEq{l: _, r: ref t} => t,
                                                                                           _ => return None
                                                                                           }
                                                                                       },
                                                                                       _ => return None
                                                                                   };
                                                                                   Some(Value::Tm(Tm{tm: _N.clone(), ty: t.clone()}))
                                                                               }
                                                                               __f},
                                                                               next: Box::new(None)
                                                                           })
                                                        }))
                                }
                     }],
                 arrangements: vec![
                     Arrangement::Map{
                        name: r###"Tm{.tm=_, .ty=_0}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Tm(__box) = __v {
                                     match __box {
                                     Tm{tm: _, ty: ref _0} => Some(Value::TyS(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     },
                     Arrangement::Map{
                        name: r###"Tm{.tm=_0, .ty=_}"###.to_string(),
                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                         {
                             let __cloned = __v.clone();
                             {
                                 if let Value::Tm(__box) = __v {
                                     match __box {
                                     Tm{tm: ref _0, ty: _} => Some(Value::TmS(_0.clone())),
                                     _ => None
                                     }
                                 } else { None }
                             }.map(|x|(x,__cloned))
                         }
                         __f},
                         queryable: false
                     },
                     Arrangement::Set{
                         name: r###"Tm{.tm=_0, .ty=_1}"###.to_string(),
                         fmfun: &{fn __f(__v: Value) -> Option<Value>
                         {
                             {
                                 if let Value::Tm(__box) = __v {
                                     match __box {
                                     Tm{tm: ref _0, ty: ref _1} => Some(Value::tuple2__TmS_TyS((_0.clone(), _1.clone()))),
                                     _ => None
                                     }
                                 } else { None }
                             }
                         }
                         __f},
                         distinct: false
                     }],
                 change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
             };
    let Refl = Relation {
                   name:         "Refl".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::Refl as RelId,
                   rules:        vec![
                       /* Refl(.tm=tm) :- ReflInput(.tm=tm). */
                       Rule::CollectionRule {
                           description: "Refl(.tm=tm) :- ReflInput(.tm=tm).".to_string(),
                           rel: Relations::ReflInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of Refl(.tm=tm) :- ReflInput(.tm=tm)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let tm = match __v{
                                                   Value::ReflInput(ref __box) => {
                                                       match *__box {
                                                       ReflInput{tm: ref tm} => tm,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::Refl(Refl{tm: tm.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* Refl(.tm=_N) :- Refl(.tm=_M), TmEq(.l=_M, .r=_N). */
                       Rule::ArrangementRule {
                           description: "Refl(.tm=_N) :- Refl(.tm=_M), TmEq(.l=_M, .r=_N).".to_string(),
                           arr: ( Relations::Refl as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Refl(.tm=_M), TmEq(.l=_M, .r=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TmEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let _M = match *__v1{
                                              Value::Refl(ref __box) => {
                                                  match *__box {
                                                  Refl{tm: ref _M} => _M,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::TmEq(ref __box) => {
                                                  match *__box {
                                                  TmEq{l: _, r: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::Refl(Refl{tm: _N.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* Refl(.tm=_O) :- __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O). */
                       Rule::ArrangementRule {
                           description: "Refl(.tm=_O) :- __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O).".to_string(),
                           arr: ( Relations::__Prefix_7 as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Ty as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::tuple2__TmS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _M, ref s) => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _D = match *__v2{
                                              Value::Ty(ref __box) => {
                                                  match *__box {
                                                  Ty{ty: _, ctx: ref _D} => _D,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple2__CtxS_TmS((_D.clone(), _M.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D) by (_D)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_D, _M) = match __v {
                                                                      Value::tuple2__CtxS_TmS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _D, ref _M) => (_D, _M),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::CtxS(_D.clone()), Value::TmS(_M.clone())))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::CtxMorph as RelId,0),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let _M = match *__v1 {
                                                                                         Value::TmS(ref __box) => {
                                                                                             match *__box {
                                                                                                 ref _M => _M,
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let (f, _G) = match *__v2{
                                                                                         Value::CtxMorph(ref __box) => {
                                                                                             match *__box {
                                                                                             CtxMorph{f: ref f, from: ref _G, to: _} => (f, _G),
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange __Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D) by (_M, f)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (_M, f) = match __v {
                                                                                                                 Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref _M, ref f) => (_M, f),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple0__(())))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "__Prefix_7[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let () = match *__v1 {
                                                                                                                                    Value::tuple0__(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            () => (),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let _O = match *__v2{
                                                                                                                                    Value::TmSubst(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        TmSubst{tm: _, f: _, sub: ref _O} => _O,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::Refl(Refl{tm: _O.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       },
                       /* Refl(.tm=_M) :- Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s). */
                       Rule::ArrangementRule {
                           description: "Refl(.tm=_M) :- Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s).".to_string(),
                           arr: ( Relations::Tm as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "Tm(.tm=_M, .ty=s), Id(.left=_N, .right=_O, .ty=s)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Id as RelId,1),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::Tm(ref __box) => {
                                                  match *__box {
                                                  Tm{tm: ref _M, ty: ref s} => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let (_N, _O) = match *__v2{
                                              Value::Id(ref __box) => {
                                                  match *__box {
                                                  Id{left: ref _N, right: ref _O, ty: _} => (_N, _O),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::Refl(Refl{tm: _M.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"Refl{.tm=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Refl(__box) = __v {
                                       match __box {
                                       Refl{tm: ref _0} => Some(Value::TmS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"_"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::Refl(__box) = __v {
                                       match __box {
                                       _ => Some(Value::tuple0__(())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let __Prefix_7 = Relation {
                         name:         "__Prefix_7".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_7 as RelId,
                         rules:        vec![
                             /* __Prefix_7[(_M, s)] :- Refl(.tm=_M), Tm(.tm=_M, .ty=s). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_7[(_M, s)] :- Refl(.tm=_M), Tm(.tm=_M, .ty=s).".to_string(),
                                 arr: ( Relations::Refl as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "Refl(.tm=_M), Tm(.tm=_M, .ty=s)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Tm as RelId,1),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let _M = match *__v1{
                                                    Value::Refl(ref __box) => {
                                                        match *__box {
                                                        Refl{tm: ref _M} => _M,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let s = match *__v2{
                                                    Value::Tm(ref __box) => {
                                                        match *__box {
                                                        Tm{tm: _, ty: ref s} => s,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__TmS_TyS((_M.clone(), s.clone())))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _0)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             (_, ref _0) => Some(Value::TyS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"_"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             _ => Some(Value::tuple0__(())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let True = Relation {
                   name:         "True".to_string(),
                   input:        false,
                   distinct:     false,
                   key_func:     None,
                   id:           Relations::True as RelId,
                   rules:        vec![
                       /* True(.tm=tm) :- TrueInput(.tm=tm). */
                       Rule::CollectionRule {
                           description: "True(.tm=tm) :- TrueInput(.tm=tm).".to_string(),
                           rel: Relations::TrueInput as RelId,
                           xform: Some(XFormCollection::FilterMap{
                                           description: "head of True(.tm=tm) :- TrueInput(.tm=tm)." .to_string(),
                                           fmfun: &{fn __f(__v: Value) -> Option<Value>
                                           {
                                               let tm = match __v{
                                                   Value::TrueInput(ref __box) => {
                                                       match *__box {
                                                       TrueInput{tm: ref tm} => tm,
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::True(True{tm: tm.clone()}))
                                           }
                                           __f},
                                           next: Box::new(None)
                                       })
                       },
                       /* True(.tm=_N) :- True(.tm=_M), TmEq(.l=_M, .r=_N). */
                       Rule::ArrangementRule {
                           description: "True(.tm=_N) :- True(.tm=_M), TmEq(.l=_M, .r=_N).".to_string(),
                           arr: ( Relations::True as RelId, 0),
                           xform: XFormArrangement::Join{
                                      description: "True(.tm=_M), TmEq(.l=_M, .r=_N)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::TmEq as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let _M = match *__v1{
                                              Value::True(ref __box) => {
                                                  match *__box {
                                                  True{tm: ref _M} => _M,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _N = match *__v2{
                                              Value::TmEq(ref __box) => {
                                                  match *__box {
                                                  TmEq{l: _, r: ref _N} => _N,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::True(True{tm: _N.clone()}))
                                      }
                                      __f},
                                      next: Box::new(None)
                                  }
                       },
                       /* True(.tm=_O) :- __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O). */
                       Rule::ArrangementRule {
                           description: "True(.tm=_O) :- __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O).".to_string(),
                           arr: ( Relations::__Prefix_6 as RelId, 1),
                           xform: XFormArrangement::Join{
                                      description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D)".to_string(),
                                      ffun: None,
                                      arrangement: (Relations::Ty as RelId,0),
                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                      {
                                          let (_M, s) = match *__v1{
                                              Value::tuple2__TmS_TyS(ref __box) => {
                                                  match *__box {
                                                  (ref _M, ref s) => (_M, s),
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          let _D = match *__v2{
                                              Value::Ty(ref __box) => {
                                                  match *__box {
                                                  Ty{ty: _, ctx: ref _D} => _D,
                                                  _ => return None
                                                  }
                                              },
                                              _ => return None
                                          };
                                          Some(Value::tuple2__CtxS_TmS((_D.clone(), _M.clone())))
                                      }
                                      __f},
                                      next: Box::new(Some(XFormCollection::Arrange {
                                                              description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D) by (_D)" .to_string(),
                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                              {
                                                                  let (_D, _M) = match __v {
                                                                      Value::tuple2__CtxS_TmS(ref __box) => {
                                                                          match *__box {
                                                                              (ref _D, ref _M) => (_D, _M),
                                                                              _ => unreachable!(),
                                                                          }
                                                                      },
                                                                      _ => unreachable!()
                                                                  };
                                                                  Some((Value::CtxS(_D.clone()), Value::TmS(_M.clone())))
                                                              }
                                                              __f},
                                                              next: Box::new(XFormArrangement::Join{
                                                                                 description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                 ffun: None,
                                                                                 arrangement: (Relations::CtxMorph as RelId,0),
                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                 {
                                                                                     let _M = match *__v1 {
                                                                                         Value::TmS(ref __box) => {
                                                                                             match *__box {
                                                                                                 ref _M => _M,
                                                                                                 _ => unreachable!(),
                                                                                             }
                                                                                         },
                                                                                         _ => unreachable!()
                                                                                     };
                                                                                     let (f, _G) = match *__v2{
                                                                                         Value::CtxMorph(ref __box) => {
                                                                                             match *__box {
                                                                                             CtxMorph{f: ref f, from: ref _G, to: _} => (f, _G),
                                                                                             _ => return None
                                                                                             }
                                                                                         },
                                                                                         _ => return None
                                                                                     };
                                                                                     Some(Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())))
                                                                                 }
                                                                                 __f},
                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                         description: "arrange __Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D) by (_M, f)" .to_string(),
                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                         {
                                                                                                             let (_M, f) = match __v {
                                                                                                                 Value::tuple2__TmS_CtxMorphS(ref __box) => {
                                                                                                                     match *__box {
                                                                                                                         (ref _M, ref f) => (_M, f),
                                                                                                                         _ => unreachable!(),
                                                                                                                     }
                                                                                                                 },
                                                                                                                 _ => unreachable!()
                                                                                                             };
                                                                                                             Some((Value::tuple2__TmS_CtxMorphS((_M.clone(), f.clone())), Value::tuple0__(())))
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                            description: "__Prefix_6[(_M, s)], Ty(.ty=s, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D), TmSubst(.tm=_M, .f=f, .sub=_O)".to_string(),
                                                                                                                            ffun: None,
                                                                                                                            arrangement: (Relations::TmSubst as RelId,2),
                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                            {
                                                                                                                                let () = match *__v1 {
                                                                                                                                    Value::tuple0__(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                            () => (),
                                                                                                                                            _ => unreachable!(),
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => unreachable!()
                                                                                                                                };
                                                                                                                                let _O = match *__v2{
                                                                                                                                    Value::TmSubst(ref __box) => {
                                                                                                                                        match *__box {
                                                                                                                                        TmSubst{tm: _, f: _, sub: ref _O} => _O,
                                                                                                                                        _ => return None
                                                                                                                                        }
                                                                                                                                    },
                                                                                                                                    _ => return None
                                                                                                                                };
                                                                                                                                Some(Value::True(True{tm: _O.clone()}))
                                                                                                                            }
                                                                                                                            __f},
                                                                                                                            next: Box::new(None)
                                                                                                                        })
                                                                                                     }))
                                                                             })
                                                          }))
                                  }
                       }],
                   arrangements: vec![
                       Arrangement::Map{
                          name: r###"True{.tm=_0}"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::True(__box) = __v {
                                       match __box {
                                       True{tm: ref _0} => Some(Value::TmS(_0.clone())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       },
                       Arrangement::Map{
                          name: r###"_"###.to_string(),
                           afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                           {
                               let __cloned = __v.clone();
                               {
                                   if let Value::True(__box) = __v {
                                       match __box {
                                       _ => Some(Value::tuple0__(())),
                                       _ => None
                                       }
                                   } else { None }
                               }.map(|x|(x,__cloned))
                           }
                           __f},
                           queryable: false
                       }],
                   change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
               };
    let __Prefix_6 = Relation {
                         name:         "__Prefix_6".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_6 as RelId,
                         rules:        vec![
                             /* __Prefix_6[(_M, s)] :- True(.tm=_M), Tm(.tm=_M, .ty=s). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_6[(_M, s)] :- True(.tm=_M), Tm(.tm=_M, .ty=s).".to_string(),
                                 arr: ( Relations::True as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "True(.tm=_M), Tm(.tm=_M, .ty=s)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Tm as RelId,1),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let _M = match *__v1{
                                                    Value::True(ref __box) => {
                                                        match *__box {
                                                        True{tm: ref _M} => _M,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let s = match *__v2{
                                                    Value::Tm(ref __box) => {
                                                        match *__box {
                                                        Tm{tm: _, ty: ref s} => s,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__TmS_TyS((_M.clone(), s.clone())))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"_"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             _ => Some(Value::tuple0__(())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"(_, _0)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__TmS_TyS(__box) = __v {
                                             match __box {
                                             (_, ref _0) => Some(Value::TyS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let TySubst = Relation {
                      name:         "TySubst".to_string(),
                      input:        false,
                      distinct:     false,
                      key_func:     None,
                      id:           Relations::TySubst as RelId,
                      rules:        vec![
                          /* TySubst(.ty=ty, .f=f, .sub=sub) :- TySubstInput(.ty=ty, .f=f, .sub=sub). */
                          Rule::CollectionRule {
                              description: "TySubst(.ty=ty, .f=f, .sub=sub) :- TySubstInput(.ty=ty, .f=f, .sub=sub).".to_string(),
                              rel: Relations::TySubstInput as RelId,
                              xform: Some(XFormCollection::FilterMap{
                                              description: "head of TySubst(.ty=ty, .f=f, .sub=sub) :- TySubstInput(.ty=ty, .f=f, .sub=sub)." .to_string(),
                                              fmfun: &{fn __f(__v: Value) -> Option<Value>
                                              {
                                                  let (ty, f, sub) = match __v{
                                                      Value::TySubstInput(ref __box) => {
                                                          match *__box {
                                                          TySubstInput{ty: ref ty, f: ref f, sub: ref sub} => (ty, f, sub),
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  Some(Value::TySubst(TySubst{ty: ty.clone(), f: f.clone(), sub: sub.clone()}))
                                              }
                                              __f},
                                              next: Box::new(None)
                                          })
                          },
                          /* TySubst(.ty=u, .f=g, .sub=v) :- TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u), CtxMorphEq(.l=f, .r=g), TyEq(.l=t, .r=v). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=u, .f=g, .sub=v) :- TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u), CtxMorphEq(.l=f, .r=g), TyEq(.l=t, .r=v).".to_string(),
                              arr: ( Relations::TySubst as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TyEq as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (s, f, t) = match *__v1{
                                                 Value::TySubst(ref __box) => {
                                                     match *__box {
                                                     TySubst{ty: ref s, f: ref f, sub: ref t} => (s, f, t),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let u = match *__v2{
                                                 Value::TyEq(ref __box) => {
                                                     match *__box {
                                                     TyEq{l: _, r: ref u} => u,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple3__CtxMorphS_TyS_TyS((f.clone(), t.clone(), u.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u) by (f)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (f, t, u) = match __v {
                                                                         Value::tuple3__CtxMorphS_TyS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref f, ref t, ref u) => (f, t, u),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::CtxMorphS(f.clone()), Value::tuple2__TyS_TyS((t.clone(), u.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u), CtxMorphEq(.l=f, .r=g)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::CtxMorphEq as RelId,0),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (t, u) = match *__v1 {
                                                                                            Value::tuple2__TyS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref t, ref u) => (t, u),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let g = match *__v2{
                                                                                            Value::CtxMorphEq(ref __box) => {
                                                                                                match *__box {
                                                                                                CtxMorphEq{l: _, r: ref g} => g,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple3__CtxMorphS_TyS_TyS((g.clone(), t.clone(), u.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u), CtxMorphEq(.l=f, .r=g) by (t)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (g, t, u) = match __v {
                                                                                                                    Value::tuple3__CtxMorphS_TyS_TyS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref g, ref t, ref u) => (g, t, u),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::TyS(t.clone()), Value::tuple2__CtxMorphS_TyS((g.clone(), u.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "TySubst(.ty=s, .f=f, .sub=t), TyEq(.l=s, .r=u), CtxMorphEq(.l=f, .r=g), TyEq(.l=t, .r=v)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::TyEq as RelId,0),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (g, u) = match *__v1 {
                                                                                                                                       Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref g, ref u) => (g, u),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let v = match *__v2{
                                                                                                                                       Value::TyEq(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           TyEq{l: _, r: ref v} => v,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::TySubst(TySubst{ty: u.clone(), f: g.clone(), sub: v.clone()}))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(None)
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TySubst(.ty=s, .f=f, .sub=s) :- Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=s, .f=f, .sub=s) :- Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G).".to_string(),
                              arr: ( Relations::Ty as RelId, 2),
                              xform: XFormArrangement::Join{
                                         description: "Ty(.ty=s, .ctx=_G), IdMorph(.f=f)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::IdMorph as RelId,1),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (s, _G) = match *__v1{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: ref s, ctx: ref _G} => (s, _G),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let f = match *__v2{
                                                 Value::IdMorph(ref __box) => {
                                                     match *__box {
                                                     IdMorph{f: ref f} => f,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple3__CtxS_CtxMorphS_TyS((_G.clone(), f.clone(), s.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange Ty(.ty=s, .ctx=_G), IdMorph(.f=f) by (f, _G, _G)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_G, f, s) = match __v {
                                                                         Value::tuple3__CtxS_CtxMorphS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _G, ref f, ref s) => (_G, f, s),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple3__CtxMorphS_CtxS_CtxS((f.clone(), _G.clone(), _G.clone())), Value::tuple2__CtxMorphS_TyS((f.clone(), s.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Semijoin{
                                                                                    description: "Ty(.ty=s, .ctx=_G), IdMorph(.f=f), CtxMorph(.f=f, .from=_G, .to=_G)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::CtxMorph as RelId,7),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,___v2: &()) -> Option<Value>
                                                                                    {
                                                                                        let (f, s) = match *__v1 {
                                                                                            Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref f, ref s) => (f, s),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        Some(Value::TySubst(TySubst{ty: s.clone(), f: f.clone(), sub: s.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          },
                          /* TySubst(.ty=u, .f=f, .sub=t) :- Comp(.g=g, .f=f, .gf=gf), TySubst(.ty=s, .f=gf, .sub=t), TySubst(.ty=s, .f=g, .sub=u). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=u, .f=f, .sub=t) :- Comp(.g=g, .f=f, .gf=gf), TySubst(.ty=s, .f=gf, .sub=t), TySubst(.ty=s, .f=g, .sub=u).".to_string(),
                              arr: ( Relations::Comp as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "Comp(.g=g, .f=f, .gf=gf), TySubst(.ty=s, .f=gf, .sub=t)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TySubst as RelId,3),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (g, f, gf) = match *__v1{
                                                 Value::Comp(ref __box) => {
                                                     match *__box {
                                                     Comp{g: ref g, f: ref f, gf: ref gf} => (g, f, gf),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (s, t) = match *__v2{
                                                 Value::TySubst(ref __box) => {
                                                     match *__box {
                                                     TySubst{ty: ref s, f: _, sub: ref t} => (s, t),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__CtxMorphS_CtxMorphS_TyS_TyS((f.clone(), g.clone(), s.clone(), t.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange Comp(.g=g, .f=f, .gf=gf), TySubst(.ty=s, .f=gf, .sub=t) by (s, g)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (f, g, s, t) = match __v {
                                                                         Value::tuple4__CtxMorphS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref f, ref g, ref s, ref t) => (f, g, s, t),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__TyS_CtxMorphS((s.clone(), g.clone())), Value::tuple2__CtxMorphS_TyS((f.clone(), t.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "Comp(.g=g, .f=f, .gf=gf), TySubst(.ty=s, .f=gf, .sub=t), TySubst(.ty=s, .f=g, .sub=u)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::TySubst as RelId,0),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (f, t) = match *__v1 {
                                                                                            Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref f, ref t) => (f, t),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let u = match *__v2{
                                                                                            Value::TySubst(ref __box) => {
                                                                                                match *__box {
                                                                                                TySubst{ty: _, f: _, sub: ref u} => u,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::TySubst(TySubst{ty: u.clone(), f: f.clone(), sub: t.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          },
                          /* TySubst(.ty=s, .f=gf, .sub=u) :- TySubst(.ty=s, .f=g, .sub=t), TySubst(.ty=t, .f=f, .sub=u), Comp(.g=g, .f=f, .gf=gf). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=s, .f=gf, .sub=u) :- TySubst(.ty=s, .f=g, .sub=t), TySubst(.ty=t, .f=f, .sub=u), Comp(.g=g, .f=f, .gf=gf).".to_string(),
                              arr: ( Relations::TySubst as RelId, 4),
                              xform: XFormArrangement::Join{
                                         description: "TySubst(.ty=s, .f=g, .sub=t), TySubst(.ty=t, .f=f, .sub=u)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TySubst as RelId,1),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (s, g, t) = match *__v1{
                                                 Value::TySubst(ref __box) => {
                                                     match *__box {
                                                     TySubst{ty: ref s, f: ref g, sub: ref t} => (s, g, t),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (f, u) = match *__v2{
                                                 Value::TySubst(ref __box) => {
                                                     match *__box {
                                                     TySubst{ty: _, f: ref f, sub: ref u} => (f, u),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__CtxMorphS_CtxMorphS_TyS_TyS((f.clone(), g.clone(), s.clone(), u.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange TySubst(.ty=s, .f=g, .sub=t), TySubst(.ty=t, .f=f, .sub=u) by (g, f)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (f, g, s, u) = match __v {
                                                                         Value::tuple4__CtxMorphS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref f, ref g, ref s, ref u) => (f, g, s, u),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__CtxMorphS_CtxMorphS((g.clone(), f.clone())), Value::tuple2__TyS_TyS((s.clone(), u.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "TySubst(.ty=s, .f=g, .sub=t), TySubst(.ty=t, .f=f, .sub=u), Comp(.g=g, .f=f, .gf=gf)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::Comp as RelId,3),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (s, u) = match *__v1 {
                                                                                            Value::tuple2__TyS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref s, ref u) => (s, u),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let gf = match *__v2{
                                                                                            Value::Comp(ref __box) => {
                                                                                                match *__box {
                                                                                                Comp{g: _, f: _, gf: ref gf} => gf,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::TySubst(TySubst{ty: s.clone(), f: gf.clone(), sub: u.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          },
                          /* TySubst(.ty=t, .f=f, .sub=s) :- TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P), Id(.left=_O, .right=_P, .ty=s), Id(.left=_M, .right=_N, .ty=t). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=t, .f=f, .sub=s) :- TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P), Id(.left=_O, .right=_P, .ty=s), Id(.left=_M, .right=_N, .ty=t).".to_string(),
                              arr: ( Relations::TmSubst as RelId, 0),
                              xform: XFormArrangement::Join{
                                         description: "TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::TmSubst as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_M, f, _O) = match *__v1{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _M, f: ref f, sub: ref _O} => (_M, f, _O),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let (_N, _P) = match *__v2{
                                                 Value::TmSubst(ref __box) => {
                                                     match *__box {
                                                     TmSubst{tm: ref _N, f: _, sub: ref _P} => (_N, _P),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple5__TmS_TmS_TmS_TmS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), _P.clone(), f.clone()))))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P) by (_O, _P)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_M, _N, _O, _P, f) = match __v {
                                                                         Value::tuple5__TmS_TmS_TmS_TmS_CtxMorphS(ref __box) => {
                                                                             match **__box {
                                                                                 (ref _M, ref _N, ref _O, ref _P, ref f) => (_M, _N, _O, _P, f),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__TmS_TmS((_O.clone(), _P.clone())), Value::tuple3__TmS_TmS_CtxMorphS((_M.clone(), _N.clone(), f.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P), Id(.left=_O, .right=_P, .ty=s)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::Id as RelId,2),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (_M, _N, f) = match *__v1 {
                                                                                            Value::tuple3__TmS_TmS_CtxMorphS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref _M, ref _N, ref f) => (_M, _N, f),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let s = match *__v2{
                                                                                            Value::Id(ref __box) => {
                                                                                                match *__box {
                                                                                                Id{left: _, right: _, ty: ref s} => s,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::tuple4__TmS_TmS_CtxMorphS_TyS((_M.clone(), _N.clone(), f.clone(), s.clone())))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                            description: "arrange TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P), Id(.left=_O, .right=_P, .ty=s) by (_M, _N)" .to_string(),
                                                                                                            afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                            {
                                                                                                                let (_M, _N, f, s) = match __v {
                                                                                                                    Value::tuple4__TmS_TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                        match *__box {
                                                                                                                            (ref _M, ref _N, ref f, ref s) => (_M, _N, f, s),
                                                                                                                            _ => unreachable!(),
                                                                                                                        }
                                                                                                                    },
                                                                                                                    _ => unreachable!()
                                                                                                                };
                                                                                                                Some((Value::tuple2__TmS_TmS((_M.clone(), _N.clone())), Value::tuple2__CtxMorphS_TyS((f.clone(), s.clone()))))
                                                                                                            }
                                                                                                            __f},
                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                               description: "TmSubst(.tm=_M, .f=f, .sub=_O), TmSubst(.tm=_N, .f=f, .sub=_P), Id(.left=_O, .right=_P, .ty=s), Id(.left=_M, .right=_N, .ty=t)".to_string(),
                                                                                                                               ffun: None,
                                                                                                                               arrangement: (Relations::Id as RelId,2),
                                                                                                                               jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                               {
                                                                                                                                   let (f, s) = match *__v1 {
                                                                                                                                       Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                               (ref f, ref s) => (f, s),
                                                                                                                                               _ => unreachable!(),
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => unreachable!()
                                                                                                                                   };
                                                                                                                                   let t = match *__v2{
                                                                                                                                       Value::Id(ref __box) => {
                                                                                                                                           match *__box {
                                                                                                                                           Id{left: _, right: _, ty: ref t} => t,
                                                                                                                                           _ => return None
                                                                                                                                           }
                                                                                                                                       },
                                                                                                                                       _ => return None
                                                                                                                                   };
                                                                                                                                   Some(Value::TySubst(TySubst{ty: t.clone(), f: f.clone(), sub: s.clone()}))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(None)
                                                                                                                           })
                                                                                                        }))
                                                                                })
                                                             }))
                                     }
                          },
                          /* TySubst(.ty=t, .f=f, .sub=s) :- __Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D). */
                          Rule::ArrangementRule {
                              description: "TySubst(.ty=t, .f=f, .sub=s) :- __Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D).".to_string(),
                              arr: ( Relations::__Prefix_2 as RelId, 1),
                              xform: XFormArrangement::Join{
                                         description: "__Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_D)".to_string(),
                                         ffun: None,
                                         arrangement: (Relations::Ty as RelId,0),
                                         jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                         {
                                             let (_G, s, t) = match *__v1{
                                                 Value::tuple3__CtxS_TyS_TyS(ref __box) => {
                                                     match *__box {
                                                     (ref _G, ref s, ref t) => (_G, s, t),
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             let _D = match *__v2{
                                                 Value::Ty(ref __box) => {
                                                     match *__box {
                                                     Ty{ty: _, ctx: ref _D} => _D,
                                                     _ => return None
                                                     }
                                                 },
                                                 _ => return None
                                             };
                                             Some(Value::tuple4__CtxS_CtxS_TyS_TyS((_D.clone(), _G.clone(), s.clone(), t.clone())))
                                         }
                                         __f},
                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                 description: "arrange __Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_D) by (_G, _D)" .to_string(),
                                                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                 {
                                                                     let (_D, _G, s, t) = match __v {
                                                                         Value::tuple4__CtxS_CtxS_TyS_TyS(ref __box) => {
                                                                             match *__box {
                                                                                 (ref _D, ref _G, ref s, ref t) => (_D, _G, s, t),
                                                                                 _ => unreachable!(),
                                                                             }
                                                                         },
                                                                         _ => unreachable!()
                                                                     };
                                                                     Some((Value::tuple2__CtxS_CtxS((_G.clone(), _D.clone())), Value::tuple2__TyS_TyS((s.clone(), t.clone()))))
                                                                 }
                                                                 __f},
                                                                 next: Box::new(XFormArrangement::Join{
                                                                                    description: "__Prefix_2[(_G, s, t)], Ty(.ty=t, .ctx=_D), CtxMorph(.f=f, .from=_G, .to=_D)".to_string(),
                                                                                    ffun: None,
                                                                                    arrangement: (Relations::CtxMorph as RelId,6),
                                                                                    jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                    {
                                                                                        let (s, t) = match *__v1 {
                                                                                            Value::tuple2__TyS_TyS(ref __box) => {
                                                                                                match *__box {
                                                                                                    (ref s, ref t) => (s, t),
                                                                                                    _ => unreachable!(),
                                                                                                }
                                                                                            },
                                                                                            _ => unreachable!()
                                                                                        };
                                                                                        let f = match *__v2{
                                                                                            Value::CtxMorph(ref __box) => {
                                                                                                match *__box {
                                                                                                CtxMorph{f: ref f, from: _, to: _} => f,
                                                                                                _ => return None
                                                                                                }
                                                                                            },
                                                                                            _ => return None
                                                                                        };
                                                                                        Some(Value::TySubst(TySubst{ty: t.clone(), f: f.clone(), sub: s.clone()}))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(None)
                                                                                })
                                                             }))
                                     }
                          }],
                      arrangements: vec![
                          Arrangement::Map{
                             name: r###"TySubst{.ty=_0, .f=_1, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TySubst(__box) = __v {
                                          match __box {
                                          TySubst{ty: ref _0, f: ref _1, sub: _} => Some(Value::tuple2__TyS_CtxMorphS((_0.clone(), _1.clone()))),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TySubst{.ty=_0, .f=_, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TySubst(__box) = __v {
                                          match __box {
                                          TySubst{ty: ref _0, f: _, sub: _} => Some(Value::TyS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Set{
                              name: r###"TySubst{.ty=_0, .f=_1, .sub=_2}"###.to_string(),
                              fmfun: &{fn __f(__v: Value) -> Option<Value>
                              {
                                  {
                                      if let Value::TySubst(__box) = __v {
                                          match __box {
                                          TySubst{ty: ref _0, f: ref _1, sub: ref _2} => Some(Value::tuple3__TyS_CtxMorphS_TyS((_0.clone(), _1.clone(), _2.clone()))),
                                          _ => None
                                          }
                                      } else { None }
                                  }
                              }
                              __f},
                              distinct: false
                          },
                          Arrangement::Map{
                             name: r###"TySubst{.ty=_, .f=_0, .sub=_}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TySubst(__box) = __v {
                                          match __box {
                                          TySubst{ty: _, f: ref _0, sub: _} => Some(Value::CtxMorphS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          },
                          Arrangement::Map{
                             name: r###"TySubst{.ty=_, .f=_, .sub=_0}"###.to_string(),
                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                              {
                                  let __cloned = __v.clone();
                                  {
                                      if let Value::TySubst(__box) = __v {
                                          match __box {
                                          TySubst{ty: _, f: _, sub: ref _0} => Some(Value::TyS(_0.clone())),
                                          _ => None
                                          }
                                      } else { None }
                                  }.map(|x|(x,__cloned))
                              }
                              __f},
                              queryable: false
                          }],
                      change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                  };
    let __Prefix_2 = Relation {
                         name:         "__Prefix_2".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_2 as RelId,
                         rules:        vec![
                             /* __Prefix_2[(_G, s, t)] :- Bool(.ty=s), Ty(.ty=s, .ctx=_G), Bool(.ty=t). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_2[(_G, s, t)] :- Bool(.ty=s), Ty(.ty=s, .ctx=_G), Bool(.ty=t).".to_string(),
                                 arr: ( Relations::Bool as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "Bool(.ty=s), Ty(.ty=s, .ctx=_G)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Ty as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let s = match *__v1{
                                                    Value::Bool(ref __box) => {
                                                        match *__box {
                                                        Bool{ty: ref s} => s,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let _G = match *__v2{
                                                    Value::Ty(ref __box) => {
                                                        match *__box {
                                                        Ty{ty: _, ctx: ref _G} => _G,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__CtxS_TyS((_G.clone(), s.clone())))
                                            }
                                            __f},
                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                    description: "arrange Bool(.ty=s), Ty(.ty=s, .ctx=_G) by ()" .to_string(),
                                                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                    {
                                                                        let (_G, s) = match __v {
                                                                            Value::tuple2__CtxS_TyS(ref __box) => {
                                                                                match *__box {
                                                                                    (ref _G, ref s) => (_G, s),
                                                                                    _ => unreachable!(),
                                                                                }
                                                                            },
                                                                            _ => unreachable!()
                                                                        };
                                                                        Some((Value::tuple0__(()), Value::tuple2__CtxS_TyS((_G.clone(), s.clone()))))
                                                                    }
                                                                    __f},
                                                                    next: Box::new(XFormArrangement::Join{
                                                                                       description: "Bool(.ty=s), Ty(.ty=s, .ctx=_G), Bool(.ty=t)".to_string(),
                                                                                       ffun: None,
                                                                                       arrangement: (Relations::Bool as RelId,1),
                                                                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                       {
                                                                                           let (_G, s) = match *__v1 {
                                                                                               Value::tuple2__CtxS_TyS(ref __box) => {
                                                                                                   match *__box {
                                                                                                       (ref _G, ref s) => (_G, s),
                                                                                                       _ => unreachable!(),
                                                                                                   }
                                                                                               },
                                                                                               _ => unreachable!()
                                                                                           };
                                                                                           let t = match *__v2{
                                                                                               Value::Bool(ref __box) => {
                                                                                                   match *__box {
                                                                                                   Bool{ty: ref t} => t,
                                                                                                   _ => return None
                                                                                                   }
                                                                                               },
                                                                                               _ => return None
                                                                                           };
                                                                                           Some(Value::tuple3__CtxS_TyS_TyS((_G.clone(), s.clone(), t.clone())))
                                                                                       }
                                                                                       __f},
                                                                                       next: Box::new(None)
                                                                                   })
                                                                }))
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_1, _, _0)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple3__CtxS_TyS_TyS(__box) = __v {
                                             match __box {
                                             (ref _1, _, ref _0) => Some(Value::tuple2__TyS_CtxS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"(_, _, _0)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple3__CtxS_TyS_TyS(__box) = __v {
                                             match __box {
                                             (_, _, ref _0) => Some(Value::TyS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let Weakening = Relation {
                        name:         "Weakening".to_string(),
                        input:        false,
                        distinct:     false,
                        key_func:     None,
                        id:           Relations::Weakening as RelId,
                        rules:        vec![
                            /* Weakening(.f=f, .ty=s, .q=e) :- CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M), Comp(.g=f, .f=p, .gf=g), Extension(.f=f, .tm=_M, .e=e). */
                            Rule::ArrangementRule {
                                description: "Weakening(.f=f, .ty=s, .q=e) :- CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M), Comp(.g=f, .f=p, .gf=g), Extension(.f=f, .tm=_M, .e=e).".to_string(),
                                arr: ( Relations::CtxMorph as RelId, 3),
                                xform: XFormArrangement::Join{
                                           description: "CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t)".to_string(),
                                           ffun: None,
                                           arrangement: (Relations::TySubst as RelId,3),
                                           jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                           {
                                               let (f, _G, _D) = match *__v1{
                                                   Value::CtxMorph(ref __box) => {
                                                       match *__box {
                                                       CtxMorph{f: ref f, from: ref _G, to: ref _D} => (f, _G, _D),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               let (s, t) = match *__v2{
                                                   Value::TySubst(ref __box) => {
                                                       match *__box {
                                                       TySubst{ty: ref s, f: _, sub: ref t} => (s, t),
                                                       _ => return None
                                                       }
                                                   },
                                                   _ => return None
                                               };
                                               Some(Value::tuple4__CtxS_CtxMorphS_TyS_TyS((_D.clone(), f.clone(), s.clone(), t.clone())))
                                           }
                                           __f},
                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                   description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t) by (_D, t)" .to_string(),
                                                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                   {
                                                                       let (_D, f, s, t) = match __v {
                                                                           Value::tuple4__CtxS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                               match *__box {
                                                                                   (ref _D, ref f, ref s, ref t) => (_D, f, s, t),
                                                                                   _ => unreachable!(),
                                                                               }
                                                                           },
                                                                           _ => unreachable!()
                                                                       };
                                                                       Some((Value::tuple2__CtxS_TyS((_D.clone(), t.clone())), Value::tuple4__CtxS_CtxMorphS_TyS_TyS((_D.clone(), f.clone(), s.clone(), t.clone()))))
                                                                   }
                                                                   __f},
                                                                   next: Box::new(XFormArrangement::Join{
                                                                                      description: "CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p)".to_string(),
                                                                                      ffun: None,
                                                                                      arrangement: (Relations::ProjCtx as RelId,1),
                                                                                      jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                      {
                                                                                          let (_D, f, s, t) = match *__v1 {
                                                                                              Value::tuple4__CtxS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                                                  match *__box {
                                                                                                      (ref _D, ref f, ref s, ref t) => (_D, f, s, t),
                                                                                                      _ => unreachable!(),
                                                                                                  }
                                                                                              },
                                                                                              _ => unreachable!()
                                                                                          };
                                                                                          let p = match *__v2{
                                                                                              Value::ProjCtx(ref __box) => {
                                                                                                  match *__box {
                                                                                                  ProjCtx{ctx: _, ty: _, f: ref p} => p,
                                                                                                  _ => return None
                                                                                                  }
                                                                                              },
                                                                                              _ => return None
                                                                                          };
                                                                                          Some(Value::tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS(boxed::Box::new((_D.clone(), f.clone(), p.clone(), s.clone(), t.clone()))))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                              description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p) by (_D, t)" .to_string(),
                                                                                                              afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                              {
                                                                                                                  let (_D, f, p, s, t) = match __v {
                                                                                                                      Value::tuple5__CtxS_CtxMorphS_CtxMorphS_TyS_TyS(ref __box) => {
                                                                                                                          match **__box {
                                                                                                                              (ref _D, ref f, ref p, ref s, ref t) => (_D, f, p, s, t),
                                                                                                                              _ => unreachable!(),
                                                                                                                          }
                                                                                                                      },
                                                                                                                      _ => unreachable!()
                                                                                                                  };
                                                                                                                  Some((Value::tuple2__CtxS_TyS((_D.clone(), t.clone())), Value::tuple3__CtxMorphS_CtxMorphS_TyS((f.clone(), p.clone(), s.clone()))))
                                                                                                              }
                                                                                                              __f},
                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                 description: "CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M)".to_string(),
                                                                                                                                 ffun: None,
                                                                                                                                 arrangement: (Relations::ProjTm as RelId,0),
                                                                                                                                 jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                 {
                                                                                                                                     let (f, p, s) = match *__v1 {
                                                                                                                                         Value::tuple3__CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                                 (ref f, ref p, ref s) => (f, p, s),
                                                                                                                                                 _ => unreachable!(),
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => unreachable!()
                                                                                                                                     };
                                                                                                                                     let _M = match *__v2{
                                                                                                                                         Value::ProjTm(ref __box) => {
                                                                                                                                             match *__box {
                                                                                                                                             ProjTm{ctx: _, ty: _, tm: ref _M} => _M,
                                                                                                                                             _ => return None
                                                                                                                                             }
                                                                                                                                         },
                                                                                                                                         _ => return None
                                                                                                                                     };
                                                                                                                                     Some(Value::tuple4__TmS_CtxMorphS_CtxMorphS_TyS((_M.clone(), f.clone(), p.clone(), s.clone())))
                                                                                                                                 }
                                                                                                                                 __f},
                                                                                                                                 next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                         description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M) by (f, p)" .to_string(),
                                                                                                                                                         afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                         {
                                                                                                                                                             let (_M, f, p, s) = match __v {
                                                                                                                                                                 Value::tuple4__TmS_CtxMorphS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                     match *__box {
                                                                                                                                                                         (ref _M, ref f, ref p, ref s) => (_M, f, p, s),
                                                                                                                                                                         _ => unreachable!(),
                                                                                                                                                                     }
                                                                                                                                                                 },
                                                                                                                                                                 _ => unreachable!()
                                                                                                                                                             };
                                                                                                                                                             Some((Value::tuple2__CtxMorphS_CtxMorphS((f.clone(), p.clone())), Value::tuple3__TmS_CtxMorphS_TyS((_M.clone(), f.clone(), s.clone()))))
                                                                                                                                                         }
                                                                                                                                                         __f},
                                                                                                                                                         next: Box::new(XFormArrangement::Join{
                                                                                                                                                                            description: "CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M), Comp(.g=f, .f=p, .gf=g)".to_string(),
                                                                                                                                                                            ffun: None,
                                                                                                                                                                            arrangement: (Relations::Comp as RelId,3),
                                                                                                                                                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                            {
                                                                                                                                                                                let (_M, f, s) = match *__v1 {
                                                                                                                                                                                    Value::tuple3__TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                        match *__box {
                                                                                                                                                                                            (ref _M, ref f, ref s) => (_M, f, s),
                                                                                                                                                                                            _ => unreachable!(),
                                                                                                                                                                                        }
                                                                                                                                                                                    },
                                                                                                                                                                                    _ => unreachable!()
                                                                                                                                                                                };
                                                                                                                                                                                let g = match *__v2{
                                                                                                                                                                                    Value::Comp(ref __box) => {
                                                                                                                                                                                        match *__box {
                                                                                                                                                                                        Comp{g: _, f: _, gf: ref g} => g,
                                                                                                                                                                                        _ => return None
                                                                                                                                                                                        }
                                                                                                                                                                                    },
                                                                                                                                                                                    _ => return None
                                                                                                                                                                                };
                                                                                                                                                                                Some(Value::tuple3__TmS_CtxMorphS_TyS((_M.clone(), f.clone(), s.clone())))
                                                                                                                                                                            }
                                                                                                                                                                            __f},
                                                                                                                                                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                    description: "arrange CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M), Comp(.g=f, .f=p, .gf=g) by (f, _M)" .to_string(),
                                                                                                                                                                                                    afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                                                                                                                                                                                    {
                                                                                                                                                                                                        let (_M, f, s) = match __v {
                                                                                                                                                                                                            Value::tuple3__TmS_CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                                                match *__box {
                                                                                                                                                                                                                    (ref _M, ref f, ref s) => (_M, f, s),
                                                                                                                                                                                                                    _ => unreachable!(),
                                                                                                                                                                                                                }
                                                                                                                                                                                                            },
                                                                                                                                                                                                            _ => unreachable!()
                                                                                                                                                                                                        };
                                                                                                                                                                                                        Some((Value::tuple2__CtxMorphS_TmS((f.clone(), _M.clone())), Value::tuple2__CtxMorphS_TyS((f.clone(), s.clone()))))
                                                                                                                                                                                                    }
                                                                                                                                                                                                    __f},
                                                                                                                                                                                                    next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                       description: "CtxMorph(.f=f, .from=_G, .to=_D), TySubst(.ty=s, .f=f, .sub=t), ProjCtx(.ctx=_D, .ty=t, .f=p), ProjTm(.ctx=_D, .ty=t, .tm=_M), Comp(.g=f, .f=p, .gf=g), Extension(.f=f, .tm=_M, .e=e)".to_string(),
                                                                                                                                                                                                                       ffun: None,
                                                                                                                                                                                                                       arrangement: (Relations::Extension as RelId,3),
                                                                                                                                                                                                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                                                                                                                                                                                                       {
                                                                                                                                                                                                                           let (f, s) = match *__v1 {
                                                                                                                                                                                                                               Value::tuple2__CtxMorphS_TyS(ref __box) => {
                                                                                                                                                                                                                                   match *__box {
                                                                                                                                                                                                                                       (ref f, ref s) => (f, s),
                                                                                                                                                                                                                                       _ => unreachable!(),
                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                               },
                                                                                                                                                                                                                               _ => unreachable!()
                                                                                                                                                                                                                           };
                                                                                                                                                                                                                           let e = match *__v2{
                                                                                                                                                                                                                               Value::Extension(ref __box) => {
                                                                                                                                                                                                                                   match *__box {
                                                                                                                                                                                                                                   Extension{f: _, tm: _, e: ref e} => e,
                                                                                                                                                                                                                                   _ => return None
                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                               },
                                                                                                                                                                                                                               _ => return None
                                                                                                                                                                                                                           };
                                                                                                                                                                                                                           Some(Value::Weakening(Weakening{f: f.clone(), ty: s.clone(), q: e.clone()}))
                                                                                                                                                                                                                       }
                                                                                                                                                                                                                       __f},
                                                                                                                                                                                                                       next: Box::new(None)
                                                                                                                                                                                                                   })
                                                                                                                                                                                                }))
                                                                                                                                                                        })
                                                                                                                                                     }))
                                                                                                                             })
                                                                                                          }))
                                                                                  })
                                                               }))
                                       }
                            }],
                        arrangements: vec![
                            Arrangement::Map{
                               name: r###"Weakening{.f=_0, .ty=_, .q=_}"###.to_string(),
                                afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                {
                                    let __cloned = __v.clone();
                                    {
                                        if let Value::Weakening(__box) = __v {
                                            match __box {
                                            Weakening{f: ref _0, ty: _, q: _} => Some(Value::CtxMorphS(_0.clone())),
                                            _ => None
                                            }
                                        } else { None }
                                    }.map(|x|(x,__cloned))
                                }
                                __f},
                                queryable: false
                            }],
                        change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                    };
    let __Prefix_0 = Relation {
                         name:         "__Prefix_0".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_0 as RelId,
                         rules:        vec![
                             /* __Prefix_0[(_M, _N, _O, _P, e, f)] :- __Prefix_8[(_M, _N, _O, _P, e, f)], False(.tm=_P). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_0[(_M, _N, _O, _P, e, f)] :- __Prefix_8[(_M, _N, _O, _P, e, f)], False(.tm=_P).".to_string(),
                                 arr: ( Relations::__Prefix_8 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_8[(_M, _N, _O, _P, e, f)], False(.tm=_P)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::False as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (_M, _N, _O, _P, e, f) = match *__v1{
                                                    Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                        match **__box {
                                                        (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let () = match *__v2{
                                                    Value::False(ref __box) => {
                                                        match *__box {
                                                        False{tm: _} => (),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), _P.clone(), e.clone(), f.clone()))))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _, _0, _, _1, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(__box) = __v {
                                             match *__box {
                                             (_, _, ref _0, _, ref _1, _) => Some(Value::tuple2__TmS_CtxMorphS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"(_, _0, _, _, _, _1)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(__box) = __v {
                                             match *__box {
                                             (_, ref _0, _, _, _, ref _1) => Some(Value::tuple2__TmS_CtxMorphS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_8 = Relation {
                         name:         "__Prefix_8".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_8 as RelId,
                         rules:        vec![
                             /* __Prefix_8[(_M, _N, _O, _P, e, f)] :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Extension(.f=f, .tm=_P, .e=e). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_8[(_M, _N, _O, _P, e, f)] :- BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Extension(.f=f, .tm=_P, .e=e).".to_string(),
                                 arr: ( Relations::BoolElim as RelId, 1),
                                 xform: XFormArrangement::Join{
                                            description: "BoolElim(.trueCase=_M, .falseCase=_N, .tm=_O), Extension(.f=f, .tm=_P, .e=e)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::Extension as RelId,2),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (_M, _N, _O) = match *__v1{
                                                    Value::BoolElim(ref __box) => {
                                                        match *__box {
                                                        BoolElim{trueCase: ref _M, falseCase: ref _N, tm: ref _O} => (_M, _N, _O),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let (f, _P, e) = match *__v2{
                                                    Value::Extension(ref __box) => {
                                                        match *__box {
                                                        Extension{f: ref f, tm: ref _P, e: ref e} => (f, _P, e),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), _P.clone(), e.clone(), f.clone()))))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _, _, _0, _, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(__box) = __v {
                                             match *__box {
                                             (_, _, _, ref _0, _, _) => Some(Value::TmS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_1 = Relation {
                         name:         "__Prefix_1".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_1 as RelId,
                         rules:        vec![
                             /* __Prefix_1[(_M, _N, _O, _P, e, f)] :- __Prefix_8[(_M, _N, _O, _P, e, f)], True(.tm=_P). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_1[(_M, _N, _O, _P, e, f)] :- __Prefix_8[(_M, _N, _O, _P, e, f)], True(.tm=_P).".to_string(),
                                 arr: ( Relations::__Prefix_8 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_8[(_M, _N, _O, _P, e, f)], True(.tm=_P)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::True as RelId,0),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let (_M, _N, _O, _P, e, f) = match *__v1{
                                                    Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(ref __box) => {
                                                        match **__box {
                                                        (ref _M, ref _N, ref _O, ref _P, ref e, ref f) => (_M, _N, _O, _P, e, f),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let () = match *__v2{
                                                    Value::True(ref __box) => {
                                                        match *__box {
                                                        True{tm: _} => (),
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(boxed::Box::new((_M.clone(), _N.clone(), _O.clone(), _P.clone(), e.clone(), f.clone()))))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_, _, _0, _, _1, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(__box) = __v {
                                             match *__box {
                                             (_, _, ref _0, _, ref _1, _) => Some(Value::tuple2__TmS_CtxMorphS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"(_0, _, _, _, _, _1)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple6__TmS_TmS_TmS_TmS_CtxMorphS_CtxMorphS(__box) = __v {
                                             match *__box {
                                             (ref _0, _, _, _, _, ref _1) => Some(Value::tuple2__TmS_CtxMorphS((_0.clone(), _1.clone()))),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_4 = Relation {
                         name:         "__Prefix_4".to_string(),
                         input:        false,
                         distinct:     false,
                         key_func:     None,
                         id:           Relations::__Prefix_4 as RelId,
                         rules:        vec![
                             /* __Prefix_4[(ctx, id)] :- IdMorph(.f=id), CtxMorph(.f=id, .from=ctx, .to=_). */
                             Rule::ArrangementRule {
                                 description: "__Prefix_4[(ctx, id)] :- IdMorph(.f=id), CtxMorph(.f=id, .from=ctx, .to=_).".to_string(),
                                 arr: ( Relations::IdMorph as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "IdMorph(.f=id), CtxMorph(.f=id, .from=ctx, .to=_)".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::CtxMorph as RelId,3),
                                            jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                            {
                                                let id = match *__v1{
                                                    Value::IdMorph(ref __box) => {
                                                        match *__box {
                                                        IdMorph{f: ref id} => id,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                let ctx = match *__v2{
                                                    Value::CtxMorph(ref __box) => {
                                                        match *__box {
                                                        CtxMorph{f: _, from: ref ctx, to: _} => ctx,
                                                        _ => return None
                                                        }
                                                    },
                                                    _ => return None
                                                };
                                                Some(Value::tuple2__CtxS_CtxMorphS((ctx.clone(), id.clone())))
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(_0, _)"###.to_string(),
                                 afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                 {
                                     let __cloned = __v.clone();
                                     {
                                         if let Value::tuple2__CtxS_CtxMorphS(__box) = __v {
                                             match __box {
                                             (ref _0, _) => Some(Value::CtxS(_0.clone())),
                                             _ => None
                                             }
                                         } else { None }
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let Ctx = Relation {
                  name:         "Ctx".to_string(),
                  input:        false,
                  distinct:     false,
                  key_func:     None,
                  id:           Relations::Ctx as RelId,
                  rules:        vec![
                      /* Ctx(.ctx=ctx) :- CtxInput(.ctx=ctx). */
                      Rule::CollectionRule {
                          description: "Ctx(.ctx=ctx) :- CtxInput(.ctx=ctx).".to_string(),
                          rel: Relations::CtxInput as RelId,
                          xform: Some(XFormCollection::FilterMap{
                                          description: "head of Ctx(.ctx=ctx) :- CtxInput(.ctx=ctx)." .to_string(),
                                          fmfun: &{fn __f(__v: Value) -> Option<Value>
                                          {
                                              let ctx = match __v{
                                                  Value::CtxInput(ref __box) => {
                                                      match *__box {
                                                      CtxInput{ctx: ref ctx} => ctx,
                                                      _ => return None
                                                      }
                                                  },
                                                  _ => return None
                                              };
                                              Some(Value::Ctx(Ctx{ctx: ctx.clone()}))
                                          }
                                          __f},
                                          next: Box::new(None)
                                      })
                      },
                      /* Ctx(.ctx=_D) :- Ctx(.ctx=_G), CtxEq(.l=_G, .r=_D). */
                      Rule::ArrangementRule {
                          description: "Ctx(.ctx=_D) :- Ctx(.ctx=_G), CtxEq(.l=_G, .r=_D).".to_string(),
                          arr: ( Relations::Ctx as RelId, 0),
                          xform: XFormArrangement::Join{
                                     description: "Ctx(.ctx=_G), CtxEq(.l=_G, .r=_D)".to_string(),
                                     ffun: None,
                                     arrangement: (Relations::CtxEq as RelId,0),
                                     jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                     {
                                         let _G = match *__v1{
                                             Value::Ctx(ref __box) => {
                                                 match *__box {
                                                 Ctx{ctx: ref _G} => _G,
                                                 _ => return None
                                                 }
                                             },
                                             _ => return None
                                         };
                                         let _D = match *__v2{
                                             Value::CtxEq(ref __box) => {
                                                 match *__box {
                                                 CtxEq{l: _, r: ref _D} => _D,
                                                 _ => return None
                                                 }
                                             },
                                             _ => return None
                                         };
                                         Some(Value::Ctx(Ctx{ctx: _D.clone()}))
                                     }
                                     __f},
                                     next: Box::new(None)
                                 }
                      }],
                  arrangements: vec![
                      Arrangement::Map{
                         name: r###"Ctx{.ctx=_0}"###.to_string(),
                          afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                          {
                              let __cloned = __v.clone();
                              {
                                  if let Value::Ctx(__box) = __v {
                                      match __box {
                                      Ctx{ctx: ref _0} => Some(Value::CtxS(_0.clone())),
                                      _ => None
                                      }
                                  } else { None }
                              }.map(|x|(x,__cloned))
                          }
                          __f},
                          queryable: false
                      }],
                  change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
              };
    let TmBar = Relation {
                    name:         "TmBar".to_string(),
                    input:        false,
                    distinct:     true,
                    key_func:     None,
                    id:           Relations::TmBar as RelId,
                    rules:        vec![
                        /* TmBar(.tm=_M, .f=e) :- Extension(.f=f, .tm=_M, .e=e), IdMorph(.f=f). */
                        Rule::ArrangementRule {
                            description: "TmBar(.tm=_M, .f=e) :- Extension(.f=f, .tm=_M, .e=e), IdMorph(.f=f).".to_string(),
                            arr: ( Relations::Extension as RelId, 1),
                            xform: XFormArrangement::Join{
                                       description: "Extension(.f=f, .tm=_M, .e=e), IdMorph(.f=f)".to_string(),
                                       ffun: None,
                                       arrangement: (Relations::IdMorph as RelId,0),
                                       jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                       {
                                           let (f, _M, e) = match *__v1{
                                               Value::Extension(ref __box) => {
                                                   match *__box {
                                                   Extension{f: ref f, tm: ref _M, e: ref e} => (f, _M, e),
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           let () = match *__v2{
                                               Value::IdMorph(ref __box) => {
                                                   match *__box {
                                                   IdMorph{f: _} => (),
                                                   _ => return None
                                                   }
                                               },
                                               _ => return None
                                           };
                                           Some(Value::TmBar(TmBar{tm: _M.clone(), f: e.clone()}))
                                       }
                                       __f},
                                       next: Box::new(None)
                                   }
                        }],
                    arrangements: vec![
                        ],
                    change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                };
    let __Null = Relation {
                     name:         "__Null".to_string(),
                     input:        false,
                     distinct:     false,
                     key_func:     None,
                     id:           Relations::__Null as RelId,
                     rules:        vec![
                         ],
                     arrangements: vec![
                         Arrangement::Map{
                            name: r###"_"###.to_string(),
                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                             {
                                 let __cloned = __v.clone();
                                 {
                                     if let Value::tuple0__(__box) = __v {
                                         match __box {
                                         _ => Some(Value::tuple0__(())),
                                         _ => None
                                         }
                                     } else { None }
                                 }.map(|x|(x,__cloned))
                             }
                             __f},
                             queryable: true
                         }],
                     change_cb:    None
                 };
    Program {
        nodes: vec![
            ProgNode::Rel{rel: BoolElimInput},
            ProgNode::Rel{rel: BoolInput},
            ProgNode::Rel{rel: CompInput},
            ProgNode::Rel{rel: ComprehensionInput},
            ProgNode::Rel{rel: CtxEmptyInput},
            ProgNode::Rel{rel: CtxEqInput},
            ProgNode::Rel{rel: CtxInput},
            ProgNode::Rel{rel: CtxMorphEqInput},
            ProgNode::Rel{rel: CtxMorphInput},
            ProgNode::Rel{rel: ExtensionInput},
            ProgNode::Rel{rel: FalseInput},
            ProgNode::Rel{rel: IdInput},
            ProgNode::Rel{rel: IdMorphInput},
            ProgNode::Rel{rel: ProjCtxInput},
            ProgNode::Rel{rel: ProjTmInput},
            ProgNode::Rel{rel: ReflInput},
            ProgNode::Rel{rel: TmEqInput},
            ProgNode::Rel{rel: TmInput},
            ProgNode::Rel{rel: TmSubstInput},
            ProgNode::Rel{rel: TrueInput},
            ProgNode::Rel{rel: TyEqInput},
            ProgNode::Rel{rel: TyInput},
            ProgNode::Rel{rel: TySubstInput},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: Bool, distinct: true}, RecursiveRelation{rel: CtxMorph, distinct: true}, RecursiveRelation{rel: CtxEq, distinct: true}, RecursiveRelation{rel: Comprehension, distinct: true}, RecursiveRelation{rel: TyEq, distinct: true}, RecursiveRelation{rel: Id, distinct: true}, RecursiveRelation{rel: TmEq, distinct: true}, RecursiveRelation{rel: BoolElim, distinct: true}, RecursiveRelation{rel: Extension, distinct: true}, RecursiveRelation{rel: Comp, distinct: true}, RecursiveRelation{rel: CtxMorphEq, distinct: true}, RecursiveRelation{rel: CtxEmpty, distinct: true}, RecursiveRelation{rel: IdMorph, distinct: true}, RecursiveRelation{rel: __Prefix_3, distinct: true}, RecursiveRelation{rel: ProjCtx, distinct: true}, RecursiveRelation{rel: ProjTm, distinct: true}, RecursiveRelation{rel: TmSubst, distinct: true}, RecursiveRelation{rel: False, distinct: true}, RecursiveRelation{rel: Ty, distinct: true}, RecursiveRelation{rel: __Prefix_5, distinct: true}, RecursiveRelation{rel: Tm, distinct: true}, RecursiveRelation{rel: Refl, distinct: true}, RecursiveRelation{rel: __Prefix_7, distinct: true}, RecursiveRelation{rel: True, distinct: true}, RecursiveRelation{rel: __Prefix_6, distinct: true}, RecursiveRelation{rel: TySubst, distinct: true}, RecursiveRelation{rel: __Prefix_2, distinct: true}, RecursiveRelation{rel: Weakening, distinct: true}, RecursiveRelation{rel: __Prefix_0, distinct: true}, RecursiveRelation{rel: __Prefix_8, distinct: true}, RecursiveRelation{rel: __Prefix_1, distinct: true}, RecursiveRelation{rel: __Prefix_4, distinct: true}, RecursiveRelation{rel: Ctx, distinct: true}]},
            ProgNode::Rel{rel: TmBar},
            ProgNode::Rel{rel: __Null}
        ],
        init_data: vec![
        ]
    }
}